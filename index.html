<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveSlayers - Space Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0033 50%, #000d1a 100%);
            color: #fff;
            font-family: 'Orbitron', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 15px;
            background: linear-gradient(180deg, #000428 0%, #004e92 100%);
            box-shadow: 0 0 30px #00ffff;
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border-radius: 12px;
        }
        
        /* Menu Principal */
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 12px;
        }
        
        #menuBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 30, 0.3);
            z-index: 1;
            border-radius: 12px;
        }
        
        .menu-content {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .menu-buttons-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px 20px;
            margin-top: 20px;
            max-width: 700px;
            width: 100%;
        }
        
        #mainMenu h1 {
            font-size: 3.5em;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 10px #00ffff); }
            to { filter: drop-shadow(0 0 30px #ff00ff); }
        }
        
        .menu-button {
            background: linear-gradient(45deg, #00ffff, #0099cc);
            border: none;
            padding: 12px 20px;
            margin: 0;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #000;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 4px 12px rgba(0,255,255,0.3);
            min-width: 180px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,255,255,0.5);
            background: linear-gradient(45deg, #ff00ff, #cc0099);
        }
        
        /* Menu de Mundos */
        #worldsMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,20,40,0.95) 0%, rgba(40,0,60,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Menu de Progress√£o */
        #progressionMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(20,0,40,0.95) 0%, rgba(60,0,40,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Menu de Conquistas */
        #achievementsMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(40,20,0,0.95) 0%, rgba(80,40,0,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Menu Battle Pass */
        #battlepassMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,40,20,0.95) 0%, rgba(0,80,40,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        .battlepass-header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 2px solid #00ff44;
        }
        
        .battlepass-level {
            font-size: 28px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 0 0 10px #FFD700;
            margin: 10px 0;
        }
        
        .xp-bar-container {
            margin: 20px 0;
        }
        
        .xp-bar {
            width: 100%;
            height: 25px;
            background: rgba(0,0,0,0.5);
            border-radius: 15px;
            border: 2px solid #00ff44;
            overflow: hidden;
            position: relative;
            margin-top: 10px;
        }
        
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff44, #00cc33);
            border-radius: 15px;
            transition: width 0.5s ease;
            box-shadow: 0 0 15px #00ff44;
        }
        
        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        
        #battlepassTiers {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }
        
        .battlepass-tier {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #333;
            transition: all 0.3s ease;
        }
        
        .battlepass-tier.current-tier {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
            transform: scale(1.02);
        }
        
        .tier-level {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #00ff44, #00cc33);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            margin-right: 20px;
            border: 3px solid #fff;
        }
        
        .tier-rewards {
            flex: 1;
            display: flex;
            gap: 20px;
        }
        
        .reward-track {
            flex: 1;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #666;
        }
        
        .reward-track.premium-track.unlocked {
            border-color: #FFD700;
            background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(255,165,0,0.1));
        }
        
        .reward-track.premium-track.locked {
            opacity: 0.5;
            border-color: #999;
        }
        
        .reward-header {
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 5px;
        }
        
        .free-track .reward-header {
            background: #00ff44;
            color: black;
        }
        
        .premium-track .reward-header {
            background: #FFD700;
            color: black;
        }
        
        .reward-item {
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        .reward-item.locked {
            opacity: 0.5;
            filter: grayscale(100%);
        }
        
        .reward-item.available {
            background: rgba(0,255,68,0.1);
            border: 1px solid #00ff44;
        }
        
        .claim-button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border: none;
            border-radius: 5px;
            background: #00ff44;
            color: black;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .claim-button:hover:not(:disabled) {
            background: #00cc33;
            transform: translateY(-2px);
        }
        
        .claim-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .claim-button.claimed {
            background: #666;
            color: #ccc;
        }
        
        .claim-button.premium {
            background: #FFD700;
        }
        
        .claim-button.premium:hover:not(:disabled) {
            background: #FFA500;
        }
        
        .premium-upgrade {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(255,215,0,0.2), rgba(255,165,0,0.2));
            border-radius: 12px;
            border: 2px solid #FFD700;
        }
        
        .upgrade-premium-button {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: black;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: none;
        }
        
        .upgrade-premium-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255,215,0,0.4);
        }
        
        /* Menu Arsenal */
        #arsenalMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(40,0,20,0.95) 0%, rgba(80,20,40,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }

        /* Menu de Naves */
        #shipCustomizationMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,30,60,0.95) 0%, rgba(30,0,60,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }

        .ship-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .ship-header h2 {
            font-size: 2.5em;
            color: #00ffff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ffff;
        }

        .ship-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .ship-tab {
            background: linear-gradient(45deg, #004466, #0066aa);
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #333;
        }

        .ship-tab.active {
            background: linear-gradient(45deg, #0088cc, #00aaff);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
        }

        .ship-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,255,0.3);
        }

        .ships-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .ship-card {
            background: linear-gradient(135deg, rgba(0,50,100,0.3) 0%, rgba(0,30,60,0.3) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ship-card.equipped {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.4);
        }

        .ship-card.legendary {
            border-color: #ff6600;
            box-shadow: 0 0 20px rgba(255,102,0,0.4);
            background: linear-gradient(135deg, rgba(255,102,0,0.1) 0%, rgba(200,50,0,0.1) 100%);
        }

        .ship-card.epic {
            border-color: #9932cc;
            box-shadow: 0 0 20px rgba(153,50,204,0.4);
            background: linear-gradient(135deg, rgba(153,50,204,0.1) 0%, rgba(100,20,150,0.1) 100%);
        }

        .ship-card.rare {
            border-color: #0080ff;
            box-shadow: 0 0 20px rgba(0,128,255,0.4);
            background: linear-gradient(135deg, rgba(0,128,255,0.1) 0%, rgba(0,80,200,0.1) 100%);
        }

        .ship-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,255,255,0.2);
        }

        .ship-preview {
            width: 100%;
            height: 120px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #444;
            position: relative;
            overflow: hidden;
        }

        .ship-model {
            font-size: 3em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .ship-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 10px;
            text-align: center;
        }

        .ship-description {
            color: #ccc;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 15px;
        }

        .ship-stats {
            margin-bottom: 15px;
        }

        .ship-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .ship-stat-bar {
            width: 100px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .ship-stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff6600);
            transition: width 0.3s ease;
        }

        .ship-abilities {
            margin-bottom: 15px;
        }

        .ship-ability {
            background: rgba(0,255,255,0.1);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 5px 0;
            font-size: 0.85em;
            color: #00ffff;
        }

        .ship-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .ship-action {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .ship-action:hover {
            transform: translateY(-2px);
        }

        .ship-action.equipped {
            background: linear-gradient(45deg, #00aa00, #00ff00);
            color: #000;
        }

        .ship-action.equip {
            background: linear-gradient(45deg, #0066aa, #00aaff);
            color: #fff;
        }

        .ship-action.upgrade {
            background: linear-gradient(45deg, #aa6600, #ff9900);
            color: #fff;
        }

        .ship-action.unlock {
            background: linear-gradient(45deg, #666, #999);
            color: #fff;
        }

        .ship-action:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .upgrade-section {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .upgrade-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .upgrade-header h3 {
            color: #ffaa00;
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .upgrade-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .upgrade-category {
            background: rgba(255,170,0,0.1);
            border: 2px solid #ffaa00;
            border-radius: 12px;
            padding: 15px;
        }

        .upgrade-category h4 {
            color: #ffaa00;
            margin-bottom: 15px;
            text-align: center;
        }

        .upgrade-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            border: 1px solid #444;
        }

        .upgrade-option.equipped {
            border-color: #00ff00;
            background: rgba(0,255,0,0.1);
        }

        .upgrade-option:hover {
            background: rgba(255,255,255,0.1);
        }

        .upgrade-cost {
            color: #ffaa00;
            font-weight: bold;
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .skin-card {
            background: linear-gradient(135deg, rgba(100,0,100,0.3) 0%, rgba(50,0,100,0.3) 100%);
            border: 2px solid #666;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .skin-card.equipped {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
        }

        .skin-card.animated {
            border-color: #ff6600;
            animation: pulse 2s ease-in-out infinite;
        }

        .skin-card.holographic {
            border-color: #9932cc;
            background: linear-gradient(45deg, rgba(153,50,204,0.2), rgba(255,0,255,0.2), rgba(0,255,255,0.2));
            background-size: 400% 400%;
            animation: hologram 3s ease-in-out infinite;
        }

        @keyframes hologram {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .skin-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255,255,255,0.2);
        }

        .skin-preview {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
        }

        .skin-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .skin-rarity {
            font-size: 0.8em;
            opacity: 0.7;
        }

        .ship-tab-content {
            display: block;
        }
        
        .arsenal-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .arsenal-header h2 {
            font-size: 2.5em;
            color: #ff6600;
            margin-bottom: 10px;
        }
        
        .arsenal-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }
        
        .arsenal-tab {
            background: linear-gradient(45deg, #666, #999);
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .arsenal-tab.active {
            background: linear-gradient(45deg, #ff6600, #ff9900);
            box-shadow: 0 0 15px rgba(255,102,0,0.5);
        }
        
        .arsenal-tab:hover {
            transform: translateY(-2px);
        }
        
        .weapons-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .weapon-card {
            background: linear-gradient(135deg, rgba(80,20,0,0.8) 0%, rgba(120,40,20,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .weapon-card.equipped {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.3);
        }
        
        .weapon-card.legendary {
            border-color: #ffaa00;
            box-shadow: 0 0 25px rgba(255,170,0,0.5);
            background: linear-gradient(135deg, rgba(100,50,0,0.8) 0%, rgba(150,75,25,0.8) 100%);
        }
        
        .weapon-card.epic {
            border-color: #9900ff;
            box-shadow: 0 0 20px rgba(153,0,255,0.4);
        }
        
        .weapon-card.rare {
            border-color: #0099ff;
            box-shadow: 0 0 15px rgba(0,153,255,0.3);
        }
        
        .weapon-card:hover {
            transform: scale(1.05);
        }
        
        .weapon-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .weapon-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #ff6600;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .weapon-stats {
            margin: 15px 0;
        }
        
        .weapon-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        
        .weapon-stat-bar {
            width: 60%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .weapon-stat-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .weapon-modifiers {
            margin: 15px 0;
        }
        
        .weapon-modifier {
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 10px;
            font-size: 0.8em;
            color: #ccc;
        }
        
        .weapon-modifier.positive {
            color: #00ff00;
            border-left: 3px solid #00ff00;
        }
        
        .weapon-modifier.negative {
            color: #ff6666;
            border-left: 3px solid #ff6666;
        }
        
        .weapon-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .weapon-action {
            flex: 1;
            background: linear-gradient(45deg, #00aa00, #00ff00);
            border: none;
            padding: 8px 12px;
            border-radius: 15px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
        }
        
        .weapon-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,0,0.3);
        }
        
        .weapon-action.equipped {
            background: linear-gradient(45deg, #666, #999);
            color: #fff;
            cursor: default;
        }
        
        .weapon-action.upgrade {
            background: linear-gradient(45deg, #0099ff, #00ccff);
        }
        
        .weapon-action.craft {
            background: linear-gradient(45deg, #ffaa00, #ffcc00);
        }
        
        .crafting-section {
            background: linear-gradient(135deg, rgba(0,20,40,0.8) 0%, rgba(20,40,60,0.8) 100%);
            border: 2px solid #0099ff;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .crafting-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .crafting-header h3 {
            color: #0099ff;
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        
        .materials-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .material-card {
            background: rgba(0,0,0,0.5);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .material-card:hover {
            border-color: #0099ff;
            transform: scale(1.05);
        }
        
        .material-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .material-name {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0099ff;
        }
        
        .material-count {
            color: #ffff00;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .craft-recipe {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .recipe-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .recipe-requirements {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .recipe-requirement {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .recipe-requirement.available {
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        
        .recipe-requirement.missing {
            color: #ff6666;
            border: 1px solid #ff6666;
        }
        
        .craft-button {
            background: linear-gradient(45deg, #ffaa00, #ffcc00);
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .craft-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,170,0,0.3);
        }
        
        .craft-button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }
        
        .progression-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .progression-header h2 {
            font-size: 2.5em;
            color: #ff00ff;
            margin-bottom: 10px;
        }
        
        .player-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .stat-card {
            background: linear-gradient(135deg, rgba(0,50,100,0.8) 0%, rgba(50,0,100,0.8) 100%);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            min-width: 150px;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: 900;
            color: #ffff00;
            display: block;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #ccc;
            margin-top: 5px;
        }
        
        .xp-bar-container {
            margin: 20px 0;
            text-align: center;
        }
        
        .xp-bar {
            width: 80%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            border: 2px solid #00ffff;
            overflow: hidden;
            margin: 10px auto;
            position: relative;
        }
        
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff8800);
            transition: width 0.5s ease;
            border-radius: 8px;
        }
        
        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-weight: bold;
            font-size: 12px;
        }
        
        .skill-tree {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        
        .skill-branch {
            background: linear-gradient(135deg, rgba(0,30,60,0.8) 0%, rgba(30,0,60,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        
        .skill-branch.unlocked {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        
        .skill-branch h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .skill-node {
            background: #222;
            border: 2px solid #555;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .skill-node.unlocked {
            border-color: #00ff00;
            background: linear-gradient(45deg, #00aa00, #00ff00);
            box-shadow: 0 0 10px rgba(0,255,0,0.5);
        }
        
        .skill-node.available {
            border-color: #ffff00;
            background: linear-gradient(45deg, #aa8800, #ffff00);
            animation: pulse 2s infinite;
        }
        
        .skill-node:hover.available {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,255,0,0.7);
        }
        
        .skill-cost {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #ffff00;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .achievement-card {
            background: linear-gradient(135deg, rgba(60,30,0,0.8) 0%, rgba(100,50,0,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .achievement-card.unlocked {
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255,170,0,0.3);
        }
        
        .achievement-card.hidden {
            opacity: 0.3;
        }
        
        .achievement-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .achievement-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffaa00;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .achievement-description {
            color: #ccc;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .achievement-progress {
            background: #333;
            border-radius: 10px;
            height: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ff6600);
            transition: width 0.3s ease;
        }
        
        .achievement-reward {
            text-align: center;
            font-size: 0.9em;
            color: #00ff00;
            font-weight: bold;
        }
        
        .battlepass-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .battlepass-level {
            font-size: 3em;
            color: #00ff00;
            font-weight: 900;
        }
        
        .battlepass-tier {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(0,50,30,0.8) 0%, rgba(0,80,50,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .battlepass-tier.unlocked {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
        }
        
        .battlepass-tier.current {
            border-color: #ffff00;
            box-shadow: 0 0 20px rgba(255,255,0,0.5);
            animation: glow-yellow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow-yellow {
            from { box-shadow: 0 0 20px rgba(255,255,0,0.5); }
            to { box-shadow: 0 0 30px rgba(255,255,0,0.8); }
        }
        
        .tier-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .tier-level {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff00;
            min-width: 50px;
        }
        
        .tier-rewards {
            display: flex;
            gap: 10px;
        }
        
        .reward-item {
            background: #333;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            min-width: 80px;
        }
        
        .reward-item.free {
            border-color: #00ff00;
        }
        
        .reward-item.premium {
            border-color: #ffaa00;
        }
        
        .daily-challenges {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .challenge-card {
            background: linear-gradient(135deg, rgba(0,30,60,0.8) 0%, rgba(30,0,60,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .challenge-card.completed {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
        }
        
        .challenge-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .challenge-description {
            color: #ccc;
            margin-bottom: 15px;
        }
        
        .challenge-progress {
            background: #333;
            border-radius: 10px;
            height: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .challenge-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            transition: width 0.3s ease;
        }
        
        .challenge-reward {
            text-align: center;
            font-weight: bold;
            color: #ffff00;
        }
        
        .worlds-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .worlds-header h2 {
            font-size: 2.5em;
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .coins-display {
            font-size: 1.3em;
            color: #ffff00;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .worlds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .world-card {
            background: linear-gradient(135deg, rgba(0,50,100,0.8) 0%, rgba(50,0,100,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .world-card.unlocked {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        
        .world-card.locked {
            border-color: #666;
            opacity: 0.6;
        }
        
        .world-card:hover.unlocked {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0,255,255,0.5);
        }
        
        .world-preview {
            width: 100%;
            height: 120px;
            background: #222;
            border-radius: 10px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .world-name {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 10px;
            color: #00ffff;
        }
        
        .world-description {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .world-price {
            background: linear-gradient(45deg, #ffff00, #ff8800);
            color: #000;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 700;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .world-action {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .world-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,0,0.3);
        }
        
        .world-action:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }
        
        .back-button {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: center;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,0,0,0.3);
        }
        
        /* Interface do Jogo */
        #gameUI {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 16px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
            display: none;
        }
        
        .ui-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 20px;
        }
        
        .health-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .health-bar {
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s ease;
            border-radius: 8px;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid #00ffff;
        }
        
        .stat-icon {
            width: 16px;
            height: 16px;
            background: #ffff00;
            border-radius: 50%;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 3px solid #ff0000;
            border-radius: 20px;
            display: none;
            z-index: 20;
        }
        
        #gameOver h2 {
            color: #ff0000;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #888;
            text-align: center;
            display: none;
        }
        
        .world-select-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(45deg, #9400d3, #4b0082);
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 15;
            display: none;
        }
        
        .world-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(148,0,211,0.3);
        }

        /* Loading screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,0,50,0.95) 0%, rgba(20,0,50,0.95) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            border-radius: 12px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #333;
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.5em;
            color: #00ffff;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        
        <!-- Menu Principal -->
        <div id="mainMenu">
            <canvas id="menuBackground" width="900" height="600"></canvas>
            <div class="menu-overlay"></div>
            <div class="menu-content">
                <h1>WAVESLAYERS</h1>
                <p style="font-size: 1.2em; color: #ccc; margin-bottom: 30px;">Conquiste as Gal√°xias</p>
                <div class="menu-buttons-container">
                    <button class="menu-button" onclick="startGame()">üöÄ Iniciar Jogo</button>
                    <button class="menu-button" onclick="openWorldsMenu()">üåç Mundos</button>
                    <button class="menu-button" onclick="openShipCustomizationMenu()">üõ∏ Naves</button>
                    <button class="menu-button" onclick="openProgressionMenu()">‚≠ê Progress√£o</button>
                    <button class="menu-button" onclick="openAchievementsMenu()">üèÜ Conquistas</button>
                    <button class="menu-button" onclick="openBattlepassMenu()">üéØ Battle Pass</button>
                    <button class="menu-button" onclick="showInstructions()">üìã Controles</button>
                </div>
            </div>
        </div>
        
        <!-- Menu de Mundos -->
        <div id="worldsMenu">
            <div class="worlds-header">
                <h2>MUNDOS DISPON√çVEIS</h2>
                <div class="coins-display">
                    <div class="stat-icon"></div>
                    <span id="coinsAmount">0</span> Moedas
                </div>
            </div>
            <div class="worlds-grid" id="worldsGrid">
                <!-- Mundos ser√£o inseridos aqui dinamicamente -->
            </div>
            <button class="back-button" onclick="closeWorldsMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu de Progress√£o -->
        <div id="progressionMenu">
            <div class="progression-header">
                <h2>PROGRESS√ÉO DO PILOTO</h2>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value" id="playerLevelDisplay">1</span>
                        <div class="stat-label">N√≠vel</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="skillPointsDisplay">0</span>
                        <div class="stat-label">Pontos de Habilidade</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="gemsDisplay">0</span>
                        <div class="stat-label">Gemas</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="darkMatterDisplay">0</span>
                        <div class="stat-label">Mat√©ria Escura</div>
                    </div>
                </div>
                <div class="xp-bar-container">
                    <div>Experi√™ncia para o pr√≥ximo n√≠vel</div>
                    <div class="xp-bar">
                        <div class="xp-fill" id="xpFill"></div>
                        <div class="xp-text" id="xpText">0 / 100</div>
                    </div>
                </div>
            </div>
            
            <h3 style="text-align: center; color: #ff00ff; margin-bottom: 20px;">√ÅRVORE DE HABILIDADES</h3>
            <div class="skill-tree" id="skillTreeContainer">
                <!-- Skill tree ser√° gerada dinamicamente -->
            </div>
            
            <h3 style="text-align: center; color: #00ffff; margin-bottom: 20px;">DESAFIOS DI√ÅRIOS</h3>
            <div class="daily-challenges" id="dailyChallengesContainer">
                <!-- Desafios di√°rios ser√£o gerados dinamicamente -->
            </div>
            
            <button class="back-button" onclick="closeProgressionMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu de Conquistas -->
        <div id="achievementsMenu">
            <div class="progression-header">
                <h2>üèÜ CONQUISTAS</h2>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value" id="achievementsUnlocked">0</span>
                        <div class="stat-label">Desbloqueadas</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="achievementsTotal">50</span>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="achievementPoints">0</span>
                        <div class="stat-label">Pontos de Conquista</div>
                    </div>
                </div>
            </div>
            
            <div class="achievements-grid" id="achievementsGrid">
                <!-- Conquistas ser√£o geradas dinamicamente -->
            </div>
            
            <button class="back-button" onclick="closeAchievementsMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu Battle Pass -->
        <div id="battlepassMenu">
            <div class="battlepass-header">
                <h2>üéØ BATTLE PASS</h2>
                <div class="battlepass-level">
                    N√≠vel <span id="battlepassLevelDisplay">0</span>
                </div>
                <div class="xp-bar-container">
                    <div>Progresso do Battle Pass</div>
                    <div class="xp-bar">
                        <div class="xp-fill" id="battlepassXpFill"></div>
                        <div class="xp-text" id="battlepassXpText">0 / 1000</div>
                    </div>
                </div>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value">Temporada 1</span>
                        <div class="stat-label">Gal√°xia Perdida</div>
                    </div>
                    <div class="stat-card" style="cursor: pointer;" onclick="upgradeBattlepass()">
                        <span class="stat-value" id="battlepassStatus">GR√ÅTIS</span>
                        <div class="stat-label">Status Premium</div>
                    </div>
                </div>
            </div>
            
            <div id="battlepassTiers">
                <!-- Tiers do Battle Pass ser√£o gerados dinamicamente -->
            </div>
            
            <button class="back-button" onclick="closeBattlepassMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu de Customiza√ß√£o de Naves -->
        <div id="shipCustomizationMenu">
            <div class="ship-header">
                <h2>üõ∏ HANGAR DE NAVES</h2>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value" id="currentShipName">Interceptor</span>
                        <div class="stat-label">Nave Atual</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="shipsUnlocked">1</span>
                        <div class="stat-label">Naves Desbloqueadas</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="skinsUnlocked">3</span>
                        <div class="stat-label">Skins Desbloqueadas</div>
                    </div>
                </div>
            </div>
            
            <div class="ship-tabs">
                <button class="ship-tab active" onclick="switchShipTab('models')">üöÅ Modelos</button>
                <button class="ship-tab" onclick="switchShipTab('upgrades')">‚öôÔ∏è Upgrades</button>
                <button class="ship-tab" onclick="switchShipTab('skins')">üé® Skins</button>
                <button class="ship-tab" onclick="switchShipTab('effects')">‚ú® Efeitos</button>
            </div>
            
            <!-- Aba de Modelos -->
            <div id="modelsTab" class="ship-tab-content">
                <div class="ships-grid" id="shipsGrid">
                    <!-- Naves ser√£o geradas dinamicamente -->
                </div>
            </div>
            
            <!-- Aba de Upgrades -->
            <div id="upgradesTab" class="ship-tab-content" style="display: none;">
                <div class="upgrade-section">
                    <div class="upgrade-header">
                        <h3>üîß SISTEMA DE UPGRADES</h3>
                        <p>Melhore sua nave com componentes avan√ßados</p>
                    </div>
                    <div class="upgrade-categories" id="upgradeCategories">
                        <!-- Categorias de upgrade ser√£o geradas dinamicamente -->
                    </div>
                </div>
            </div>
            
            <!-- Aba de Skins -->
            <div id="skinsTab" class="ship-tab-content" style="display: none;">
                <div class="upgrade-section">
                    <div class="upgrade-header">
                        <h3>üé® SKINS √âPICAS</h3>
                        <p>Personalize o visual da sua nave</p>
                    </div>
                    <div class="skins-grid" id="skinsGrid">
                        <!-- Skins ser√£o geradas dinamicamente -->
                    </div>
                </div>
            </div>
            
            <!-- Aba de Efeitos -->
            <div id="effectsTab" class="ship-tab-content" style="display: none;">
                <div class="upgrade-section">
                    <div class="upgrade-header">
                        <h3>‚ú® EFEITOS VISUAIS</h3>
                        <p>Rastros, auras e modifica√ß√µes visuais</p>
                    </div>
                    <div class="skins-grid" id="effectsGrid">
                        <!-- Efeitos ser√£o gerados dinamicamente -->
                    </div>
                </div>
            </div>
            
            <button class="back-button" onclick="closeShipCustomizationMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">
                <div id="loadingMessage">Carregando mundo...</div>
            </div>
        </div>
        
        <!-- Interface do Jogo -->
        <div id="gameUI">
            <div class="ui-row">
                <div class="health-bar-container">
                    <span>VIDA:</span>
                    <div class="health-bar">
                        <div class="health-fill" id="healthFill"></div>
                        <div class="health-text" id="healthText">100/100</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon"></div>
                    <span id="coinsUI">0</span>
                </div>
            </div>
            <div class="ui-row">
                <div class="stat-item">
                    <span>PONTOS: <span id="score">0</span></span>
                </div>
                <div class="stat-item">
                    <span>N√çVEL: <span id="level">1</span></span>
                </div>
                <div class="stat-item">
                    <span>MUNDO: <span id="currentWorldName">Terra</span></span>
                </div>
            </div>
        </div>
        
        <button class="world-select-btn" id="worldSelectBtn" onclick="openWorldsMenu()">üåç Mundos</button>
        
        <div id="gameOver">
            <h2>MISS√ÉO FALHOU</h2>
            <p style="font-size: 1.2em; margin-bottom: 20px;">Pontua√ß√£o Final: <span id="finalScore">0</span></p>
            <p style="font-size: 1em; color: #ffff00; margin-bottom: 20px;">Moedas Coletadas: <span id="coinsEarned">0</span></p>
            <button class="menu-button" onclick="restartGame()">üîÑ Tentar Novamente</button>
            <button class="menu-button" onclick="goToMainMenu()">üè† Menu Principal</button>
        </div>
        
        <div id="instructions">
            Use WASD ou setas para mover ‚Ä¢ ESPA√áO para atirar ‚Ä¢ P para pausar
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameOver', 'progression', 'achievements', 'battlepass'
        let gameRunning = false;
        let isPaused = false;
        let score = 0;
        let level = 1;
        let lastTime = 0;
        let gameStartTime = 0;
        let survivalTime = 0;
        let coins = parseInt(localStorage.getItem('waveslayers_coins') || '100');
        let coinsThisRound = 0;
        let currentWorldId = localStorage.getItem('waveslayers_current_world') || 'earth';
        
        // Progression System
        let playerLevel = parseInt(localStorage.getItem('waveslayers_player_level') || '1');
        let playerXP = parseInt(localStorage.getItem('waveslayers_player_xp') || '0');
        let skillPoints = parseInt(localStorage.getItem('waveslayers_skill_points') || '0');
        let gems = parseInt(localStorage.getItem('waveslayers_gems') || '0');
        let darkMatter = parseInt(localStorage.getItem('waveslayers_dark_matter') || '0');
        
        // Skill Tree   
        let skillTree = JSON.parse(localStorage.getItem('waveslayers_skills') || '{}');
        
        // Achievements System
        let achievements = JSON.parse(localStorage.getItem('waveslayers_achievements') || '{}');
        let achievementProgress = JSON.parse(localStorage.getItem('waveslayers_achievement_progress') || '{}');
        
        // Daily Challenges
        let dailyChallenges = JSON.parse(localStorage.getItem('waveslayers_daily_challenges') || '{}');
        let lastDailyReset = localStorage.getItem('waveslayers_last_daily_reset') || '';
        
        // Battle Pass
        let battlePassLevel = parseInt(localStorage.getItem('waveslayers_battlepass_level') || '0');
        let battlePassXP = parseInt(localStorage.getItem('waveslayers_battlepass_xp') || '0');
        let battlePassPremium = localStorage.getItem('waveslayers_battlepass_premium') === 'true';
        let battlePassSeason = localStorage.getItem('waveslayers_battlepass_season') || '1';
        let battlePassClaimedRewards = JSON.parse(localStorage.getItem('waveslayers_battlepass_claimed') || '[]');
        
        // Ship Customization System
        let currentShipId = localStorage.getItem('waveslayers_current_ship') || 'interceptor';
        let unlockedShips = JSON.parse(localStorage.getItem('waveslayers_unlocked_ships') || '["interceptor"]');
        let shipUpgrades = JSON.parse(localStorage.getItem('waveslayers_ship_upgrades') || '{}');
        let currentSkinId = localStorage.getItem('waveslayers_current_skin') || 'default';
        let unlockedSkins = JSON.parse(localStorage.getItem('waveslayers_unlocked_skins') || '["default", "blue", "red"]');
        let currentEffectId = localStorage.getItem('waveslayers_current_effect') || 'none';
        let unlockedEffects = JSON.parse(localStorage.getItem('waveslayers_unlocked_effects') || '["none"]');
        
        // Menu animation objects
        let menuStars = [];
        let menuShips = [];
        let menuBullets = [];
        let menuExplosions = [];
        let menuAnimationRunning = false;
        
        // Menu Ship class
        class MenuShip {
            constructor(x, y, type, team, target = null) {
                this.x = x;
                this.y = y;
                this.type = type; // 'player', 'enemy'
                this.team = team;
                this.target = target;
                this.width = type === 'player' ? 20 : 24;
                this.height = type === 'player' ? 20 : 24;
                this.speed = 2 + Math.random() * 2;
                this.angle = Math.random() * Math.PI * 2;
                this.health = 100;
                this.maxHealth = 100;
                this.shootTimer = Math.random() * 1000;
                this.behavior = Math.random() < 0.5 ? 'patrol' : 'chase';
                this.patrolTarget = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
                this.life = 8000 + Math.random() * 5000; // Life span
                this.maxLife = this.life;
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.shootTimer -= deltaTime;
                
                // Find nearest enemy
                if (this.behavior === 'chase' && !this.target) {
                    let nearestEnemy = null;
                    let nearestDistance = Infinity;
                    
                    menuShips.forEach(ship => {
                        if (ship.team !== this.team && ship.health > 0) {
                            const dist = Math.hypot(ship.x - this.x, ship.y - this.y);
                            if (dist < nearestDistance && dist < 200) {
                                nearestDistance = dist;
                                nearestEnemy = ship;
                            }
                        }
                    });
                    
                    this.target = nearestEnemy;
                }
                
                // Movement AI
                let targetX, targetY;
                
                if (this.behavior === 'chase' && this.target && this.target.health > 0) {
                    targetX = this.target.x;
                    targetY = this.target.y;
                } else {
                    // Patrol behavior
                    const distToPatrol = Math.hypot(this.patrolTarget.x - this.x, this.patrolTarget.y - this.y);
                    if (distToPatrol < 50) {
                        this.patrolTarget = {
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height
                        };
                    }
                    targetX = this.patrolTarget.x;
                    targetY = this.patrolTarget.y;
                }
                
                // Move towards target
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                    this.angle = Math.atan2(dy, dx);
                }
                
                // Keep in bounds with wrapping
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50;
                if (this.y > canvas.height + 50) this.y = -50;
                
                // Shooting
                if (this.shootTimer <= 0 && this.target && this.target.health > 0) {
                    const distToTarget = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                    if (distToTarget < 150) {
                        this.shoot();
                        this.shootTimer = 800 + Math.random() * 1200;
                    }
                }
            }
            
            shoot() {
                const bulletSpeed = 6;
                const bulletX = this.x + Math.cos(this.angle) * this.width;
                const bulletY = this.y + Math.sin(this.angle) * this.height;
                const vx = Math.cos(this.angle) * bulletSpeed;
                const vy = Math.sin(this.angle) * bulletSpeed;
                
                menuBullets.push(new MenuBullet(bulletX, bulletY, vx, vy, this.team, this.type));
            }
            
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.explode();
                    return true;
                }
                return false;
            }
            
            explode() {
                menuExplosions.push(new MenuExplosion(this.x, this.y));
            }
            
            draw(ctx) {
                if (this.health <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                if (this.type === 'player') {
                    this.drawPlayerShip(ctx);
                } else {
                    this.drawEnemyShip(ctx);
                }
                
                ctx.restore();
            }
            
            drawPlayerShip(ctx) {
                // Blue player ship
                ctx.fillStyle = '#00aaff';
                ctx.fillRect(-10, -6, 20, 4);
                ctx.fillRect(-8, -4, 16, 8);
                ctx.fillRect(-6, -8, 12, 4);
                ctx.fillRect(-6, 4, 12, 4);
                
                ctx.fillStyle = '#0088cc';
                ctx.fillRect(-4, -2, 8, 4);
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(6, -1, 4, 2);
            }
            
            drawEnemyShip(ctx) {
                // Red enemy ship
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(-12, -8, 24, 6);
                ctx.fillRect(-10, -6, 20, 12);
                ctx.fillRect(-8, -10, 16, 6);
                ctx.fillRect(-8, 4, 16, 6);
                
                ctx.fillStyle = '#cc0000';
                ctx.fillRect(-6, -4, 12, 8);
                
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(8, -2, 4, 4);
            }
            
            isDead() {
                return this.health <= 0 || this.life <= 0;
            }
        }
        
        // Menu Bullet class
        class MenuBullet {
            constructor(x, y, vx, vy, team, shipType) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.team = team;
                this.shipType = shipType;
                this.width = 4;
                this.height = 2;
                this.life = 2000;
                this.damage = 25;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
            }
            
            draw(ctx) {
                ctx.fillStyle = this.shipType === 'player' ? '#ffff00' : '#ff6666';
                ctx.fillRect(this.x - 2, this.y - 1, this.width, this.height);
                
                // Glow effect
                ctx.shadowColor = this.shipType === 'player' ? '#ffff00' : '#ff6666';
                ctx.shadowBlur = 3;
                ctx.fillRect(this.x - 2, this.y - 1, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.x < -10 || this.x > canvas.width + 10 || 
                       this.y < -10 || this.y > canvas.height + 10 || 
                       this.life <= 0;
            }
        }
        
        // Menu Explosion class
        class MenuExplosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI * 2 * i) / 12;
                    const speed = 2 + Math.random() * 4;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 800 + Math.random() * 400,
                        maxLife: 800 + Math.random() * 400,
                        size: 2 + Math.random() * 3,
                        color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00'
                    });
                }
            }
            
            update(deltaTime) {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= deltaTime;
                    particle.vy += 0.05; // gravity
                    return particle.life > 0;
                });
            }
            
            draw(ctx) {
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = particle.color;
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                });
                ctx.globalAlpha = 1;
            }
            
            isDead() {
                return this.particles.length === 0;
            }
        }
        
        // Menu Star class
        class MenuStar {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 1 + 0.3;
                this.size = Math.random() * 2 + 0.5;
                this.brightness = Math.random() * 0.8 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            
            update(deltaTime) {
                this.y += this.speed;
                this.twinkle += 0.02;
                
                if (this.y > canvas.height + 10) {
                    this.y = -10;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            draw(ctx) {
                const twinkleBrightness = this.brightness + Math.sin(this.twinkle) * 0.3;
                ctx.globalAlpha = Math.max(0.1, twinkleBrightness);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        function initMenuAnimation() {
            const menuCanvas = document.getElementById('menuBackground');
            if (!menuCanvas) return;
            
            // Create background stars
            menuStars = [];
            for (let i = 0; i < 80; i++) {
                menuStars.push(new MenuStar());
            }
            
            // Create initial ships
            menuShips = [];
            menuBullets = [];
            menuExplosions = [];
            
            spawnMenuShips();
            menuAnimationRunning = true;
        }
        
        function spawnMenuShips() {
            // Spawn player ships
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                menuShips.push(new MenuShip(x, y, 'player', 'player'));
            }
            
            // Spawn enemy ships
            for (let i = 0; i < 4; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                menuShips.push(new MenuShip(x, y, 'enemy', 'enemy'));
            }
        }
        
        function updateMenuAnimation(deltaTime) {
            if (!menuAnimationRunning) return;
            
            const menuCanvas = document.getElementById('menuBackground');
            if (!menuCanvas) return;
            
            const menuCtx = menuCanvas.getContext('2d');
            
            // Clear canvas with space gradient
            const gradient = menuCtx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000428');
            gradient.addColorStop(0.5, '#004e92');
            gradient.addColorStop(1, '#000000');
            menuCtx.fillStyle = gradient;
            menuCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw stars
            menuStars.forEach(star => {
                star.update(deltaTime);
                star.draw(menuCtx);
            });
            
            // Update ships
            menuShips = menuShips.filter(ship => {
                ship.update(deltaTime);
                ship.draw(menuCtx);
                return !ship.isDead();
            });
            
            // Update bullets
            menuBullets = menuBullets.filter(bullet => {
                bullet.update(deltaTime);
                bullet.draw(menuCtx);
                return !bullet.isOffScreen();
            });
            
            // Update explosions
            menuExplosions = menuExplosions.filter(explosion => {
                explosion.update(deltaTime);
                explosion.draw(menuCtx);
                return !explosion.isDead();
            });
            
            // Check bullet collisions
            for (let i = menuBullets.length - 1; i >= 0; i--) {
                const bullet = menuBullets[i];
                for (let j = menuShips.length - 1; j >= 0; j--) {
                    const ship = menuShips[j];
                    
                    if (ship.team !== bullet.team && ship.health > 0) {
                        const dx = bullet.x - ship.x;
                        const dy = bullet.y - ship.y;
                        const distance = Math.hypot(dx, dy);
                        
                        if (distance < ship.width / 2) {
                            menuBullets.splice(i, 1);
                            ship.takeDamage(bullet.damage);
                            break;
                        }
                    }
                }
            }
            
            // Spawn new ships periodically
            if (menuShips.length < 8 && Math.random() < 0.002) {
                const type = Math.random() < 0.4 ? 'player' : 'enemy';
                const edge = Math.floor(Math.random() * 4);
                let x, y;
                
                switch (edge) {
                    case 0: x = -30; y = Math.random() * canvas.height; break;
                    case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = -30; break;
                    case 3: x = Math.random() * canvas.width; y = canvas.height + 30; break;
                }
                
                menuShips.push(new MenuShip(x, y, type, type));
            }
        }
        
        // Player stats
        let playerHealth = 100;
        let playerMaxHealth = 100;
        
        function getEffectiveMaxHealth() {
            let maxHealth = 100;
            if (skillTree['health1']) maxHealth = 150;
            if (skillTree['health2']) maxHealth = 200;
            return maxHealth;
        }
        
        function updatePlayerStats() {
            const newMaxHealth = getEffectiveMaxHealth();
            if (newMaxHealth !== playerMaxHealth) {
                const healthRatio = playerHealth / playerMaxHealth;
                playerMaxHealth = newMaxHealth;
                playerHealth = Math.floor(playerMaxHealth * healthRatio);
            }
        }
        
        // Input handling
        const keys = {};
        
        // Game objects
        let player;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let particles = [];
        let powerups = [];
        let stars = [];
        
        // Timers
        let enemySpawnTimer = 0;
        let powerupSpawnTimer = 0;
        
        // Worlds system
        const worlds = {
            earth: {
                id: 'earth',
                name: 'Terra',
                description: 'O lar da humanidade. C√©us azuis e nuvens brancas.',
                price: 0,
                unlocked: true,
                colors: {
                    bg: ['#87CEEB', '#E0F6FF'],
                    stars: '#FFFFFF',
                    enemies: ['#FF6B6B', '#4ECDC4', '#45B7D1']
                },
                difficulty: 1
            },
            mars: {
                id: 'mars',
                name: 'Marte',
                description: 'O planeta vermelho. Tempestades de areia e paisagens √°ridas.',
                price: 250,
                unlocked: false,
                colors: {
                    bg: ['#CD5C5C', '#A0522D'],
                    stars: '#FFD700',
                    enemies: ['#FF4500', '#DC143C', '#B22222']
                },
                difficulty: 1.5
            },
            jupiter: {
                id: 'jupiter',
                name: 'J√∫piter',
                description: 'Gigante gasoso. Tempestades colossais e radia√ß√£o intensa.',
                price: 500,
                unlocked: false,
                colors: {
                    bg: ['#DEB887', '#F4A460'],
                    stars: '#FFA500',
                    enemies: ['#FF8C00', '#DAA520', '#B8860B']
                },
                difficulty: 2
            },
            saturn: {
                id: 'saturn',
                name: 'Saturno',
                description: 'Senhor dos an√©is. Beleza hipnotizante e gravidade trai√ßoeira.',
                price: 750,
                unlocked: false,
                colors: {
                    bg: ['#F0E68C', '#EEE8AA'],
                    stars: '#FFFFE0',
                    enemies: ['#FFD700', '#FFA500', '#FF8C00']
                },
                difficulty: 2.5
            },
            neptune: {
                id: 'neptune',
                name: 'Netuno',
                description: 'Mundo gelado. Ventos supers√¥nicos e mist√©rios profundos.',
                price: 1000,
                unlocked: false,
                colors: {
                    bg: ['#4169E1', '#000080'],
                    stars: '#ADD8E6',
                    enemies: ['#0000FF', '#4169E1', '#6495ED']
                },
                difficulty: 3
            },
            blackhole: {
                id: 'blackhole',
                name: 'Buraco Negro',
                description: 'O vazio absoluto. Onde apenas os mais corajosos se aventuram.',
                price: 2000,
                unlocked: false,
                colors: {
                    bg: ['#2F2F2F', '#000000'],
                    stars: '#800080',
                    enemies: ['#8B008B', '#4B0082', '#9400D3']
                },
                difficulty: 4
            }
        };
        
        // Load unlocked worlds
        const unlockedWorlds = JSON.parse(localStorage.getItem('waveslayers_unlocked_worlds') || '["earth"]');
        unlockedWorlds.forEach(worldId => {
            if (worlds[worldId]) {
                worlds[worldId].unlocked = true;
            }
        });
        
        // Ship Models System
        const shipModels = {
            // Naves B√°sicas
            interceptor: {
                id: 'interceptor',
                name: 'Interceptor',
                description: 'Nave b√°sica e confi√°vel. Boa para iniciantes.',
                rarity: 'common',
                price: 0,
                unlocked: true,
                stats: {
                    speed: 6,
                    health: 100,
                    damage: 25,
                    fireRate: 150,
                    shield: 0
                },
                abilities: ['Manobra B√°sica'],
                sprite: 'üõ∏'
            },
            fighter: {
                id: 'fighter',
                name: 'Ca√ßa Estelar',
                description: 'Nave de combate com maior poder de fogo.',
                rarity: 'common',
                price: 500,
                unlocked: false,
                stats: {
                    speed: 5,
                    health: 120,
                    damage: 35,
                    fireRate: 120,
                    shield: 20
                },
                abilities: ['Rajada Dupla', 'Escudo B√°sico'],
                sprite: 'üöÅ'
            },
            scout: {
                id: 'scout',
                name: 'Explorador',
                description: 'Nave r√°pida e √°gil, perfeita para evas√£o.',
                rarity: 'common',
                price: 400,
                unlocked: false,
                stats: {
                    speed: 8,
                    health: 80,
                    damage: 20,
                    fireRate: 100,
                    shield: 10
                },
                abilities: ['Velocidade M√°xima', 'Evas√£o'],
                sprite: '‚úàÔ∏è'
            },
            
            // Naves Raras
            destroyer: {
                id: 'destroyer',
                name: 'Destruidor',
                description: 'Nave pesada com poder de fogo devastador.',
                rarity: 'rare',
                price: 1200,
                unlocked: false,
                stats: {
                    speed: 4,
                    health: 180,
                    damage: 50,
                    fireRate: 200,
                    shield: 40
                },
                abilities: ['Tiro Perfurador', 'Casco Refor√ßado', 'Escudo Avan√ßado'],
                sprite: 'üöÄ'
            },
            stealth: {
                id: 'stealth',
                name: 'Furtiva',
                description: 'Tecnologia de camuflagem e ataques surpresa.',
                rarity: 'rare',
                price: 1000,
                unlocked: false,
                stats: {
                    speed: 7,
                    health: 90,
                    damage: 40,
                    fireRate: 80,
                    shield: 15
                },
                abilities: ['Camuflagem', 'Ataque Cr√≠tico', 'Furtividade'],
                sprite: 'üëª'
            },
            bomber: {
                id: 'bomber',
                name: 'Bombardeiro',
                description: 'Especialista em ataques de √°rea devastadores.',
                rarity: 'rare',
                price: 1500,
                unlocked: false,
                stats: {
                    speed: 3,
                    health: 200,
                    damage: 60,
                    fireRate: 300,
                    shield: 50
                },
                abilities: ['M√≠sseis Explosivos', 'Bombardeio', 'Casco Blindado'],
                sprite: 'üí£'
            },
            
            // Naves √âpicas
            vortex: {
                id: 'vortex',
                name: 'V√≥rtice',
                description: 'Manipula energia espacial para ataques √∫nicos.',
                rarity: 'epic',
                price: 2500,
                unlocked: false,
                stats: {
                    speed: 6,
                    health: 150,
                    damage: 45,
                    fireRate: 120,
                    shield: 60
                },
                abilities: ['V√≥rtice Energ√©tico', 'Distor√ß√£o Temporal', 'Campo de For√ßa'],
                sprite: 'üåÄ'
            },
            phoenix: {
                id: 'phoenix',
                name: 'F√™nix',
                description: 'Renascimento autom√°tico e poder crescente.',
                rarity: 'epic',
                price: 3000,
                unlocked: false,
                stats: {
                    speed: 5,
                    health: 160,
                    damage: 55,
                    fireRate: 100,
                    shield: 40
                },
                abilities: ['Renascimento', 'Chamas Eternas', 'Poder Crescente'],
                sprite: 'üî•'
            },
            quantum: {
                id: 'quantum',
                name: 'Quantum',
                description: 'Tecnologia qu√¢ntica avan√ßada e teletransporte.',
                rarity: 'epic',
                price: 3500,
                unlocked: false,
                stats: {
                    speed: 8,
                    health: 120,
                    damage: 50,
                    fireRate: 90,
                    shield: 80
                },
                abilities: ['Teletransporte', 'Duplica√ß√£o Qu√¢ntica', 'Fase Fantasma'],
                sprite: '‚öõÔ∏è'
            },
            
            // Naves Lend√°rias
            titan: {
                id: 'titan',
                name: 'Tit√£',
                description: 'A m√°quina de guerra definitiva.',
                rarity: 'legendary',
                price: 5000,
                unlocked: false,
                stats: {
                    speed: 4,
                    health: 300,
                    damage: 80,
                    fireRate: 150,
                    shield: 100
                },
                abilities: ['Modo Berserk', 'Canh√£o Tit√¢nico', 'Escudo Indestrut√≠vel', 'Regenera√ß√£o'],
                sprite: 'ü§ñ'
            },
            void: {
                id: 'void',
                name: 'Devorador do Vazio',
                description: 'Consome energia dos inimigos para se fortalecer.',
                rarity: 'legendary',
                price: 6000,
                unlocked: false,
                stats: {
                    speed: 6,
                    health: 200,
                    damage: 70,
                    fireRate: 80,
                    shield: 120
                },
                abilities: ['Drenar Vida', 'Buraco Negro', 'Absor√ß√£o Energ√©tica', 'Void Walk'],
                sprite: 'üï≥Ô∏è'
            },
            godmode: {
                id: 'godmode',
                name: 'Ascens√£o',
                description: 'Transcendeu os limites da tecnologia conhecida.',
                rarity: 'legendary',
                price: 10000,
                unlocked: false,
                stats: {
                    speed: 10,
                    health: 500,
                    damage: 100,
                    fireRate: 50,
                    shield: 200
                },
                abilities: ['Modo Deus', 'Onipresen√ßa', 'Destrui√ß√£o Total', 'Imortalidade', 'Cria√ß√£o'],
                sprite: 'üëë'
            }
        };
        
        // Ship Upgrades System
        const upgradeCategories = {
            engine: {
                name: 'Motor',
                icon: 'üöÄ',
                upgrades: {
                    basic: { name: 'Motor B√°sico', cost: 0, speedBonus: 0, equipped: true },
                    improved: { name: 'Motor Melhorado', cost: 200, speedBonus: 1, equipped: false },
                    advanced: { name: 'Motor Avan√ßado', cost: 500, speedBonus: 2, equipped: false },
                    quantum: { name: 'Motor Qu√¢ntico', cost: 1000, speedBonus: 4, equipped: false }
                }
            },
            shield: {
                name: 'Escudo',
                icon: 'üõ°Ô∏è',
                upgrades: {
                    none: { name: 'Sem Escudo', cost: 0, shieldBonus: 0, equipped: true },
                    basic: { name: 'Escudo B√°sico', cost: 300, shieldBonus: 50, equipped: false },
                    enhanced: { name: 'Escudo Refor√ßado', cost: 600, shieldBonus: 100, equipped: false },
                    quantum: { name: 'Escudo Qu√¢ntico', cost: 1200, shieldBonus: 200, equipped: false }
                }
            },
            weapons: {
                name: 'Armas',
                icon: '‚öîÔ∏è',
                upgrades: {
                    basic: { name: 'Laser B√°sico', cost: 0, damageBonus: 0, equipped: true },
                    plasma: { name: 'Canh√£o Plasma', cost: 400, damageBonus: 15, equipped: false },
                    photon: { name: 'Torpedos F√≥ton', cost: 800, damageBonus: 30, equipped: false },
                    antimatter: { name: 'Canh√£o Antimat√©ria', cost: 1500, damageBonus: 50, equipped: false }
                }
            },
            hull: {
                name: 'Casco',
                icon: 'üîß',
                upgrades: {
                    basic: { name: 'Casco B√°sico', cost: 0, healthBonus: 0, equipped: true },
                    reinforced: { name: 'Casco Refor√ßado', cost: 350, healthBonus: 50, equipped: false },
                    armored: { name: 'Casco Blindado', cost: 700, healthBonus: 100, equipped: false },
                    nanotube: { name: 'Nanotubos de Carbono', cost: 1400, healthBonus: 200, equipped: false }
                }
            }
        };
        
        // Ship Skins System
        const shipSkins = {
            default: {
                id: 'default',
                name: 'Padr√£o',
                description: 'Visual cl√°ssico da nave',
                rarity: 'common',
                price: 0,
                unlocked: true,
                colors: ['#00ccff', '#ffffff'],
                animated: false
            },
            blue: {
                id: 'blue',
                name: 'Azul Glacial',
                description: 'Tons de azul gelado',
                rarity: 'common',
                price: 0,
                unlocked: true,
                colors: ['#0080ff', '#40a0ff'],
                animated: false
            },
            red: {
                id: 'red',
                name: 'Vermelho Fogo',
                description: 'Chamas vermelhas intensas',
                rarity: 'common',
                price: 0,
                unlocked: true,
                colors: ['#ff4040', '#ff8080'],
                animated: false
            },
            gold: {
                id: 'gold',
                name: 'Dourado Real',
                description: 'Luxo e eleg√¢ncia',
                rarity: 'rare',
                price: 800,
                unlocked: false,
                colors: ['#ffd700', '#ffff80'],
                animated: false
            },
            stealth: {
                id: 'stealth',
                name: 'Modo Furtivo',
                description: 'Camuflagem ativa',
                rarity: 'rare',
                price: 1000,
                unlocked: false,
                colors: ['#404040', '#808080'],
                animated: false
            },
            neon: {
                id: 'neon',
                name: 'Neon Cyberpunk',
                description: 'Luzes neon pulsantes',
                rarity: 'epic',
                price: 1500,
                unlocked: false,
                colors: ['#ff00ff', '#00ffff'],
                animated: true
            },
            plasma: {
                id: 'plasma',
                name: 'Plasma Energ√©tico',
                description: 'Energia pura vis√≠vel',
                rarity: 'epic',
                price: 2000,
                unlocked: false,
                colors: ['#8040ff', '#ff40ff'],
                animated: true
            },
            hologram: {
                id: 'hologram',
                name: 'Holograma',
                description: 'Proje√ß√£o hologr√°fica',
                rarity: 'legendary',
                price: 3000,
                unlocked: false,
                colors: ['#40ffff', '#ff40ff', '#ffff40'],
                animated: true,
                holographic: true
            },
            void: {
                id: 'void',
                name: 'Ess√™ncia do Vazio',
                description: 'Absorve a luz ao redor',
                rarity: 'legendary',
                price: 4000,
                unlocked: false,
                colors: ['#200020', '#800080'],
                animated: true
            }
        };
        
        // Visual Effects System
        const visualEffects = {
            none: {
                id: 'none',
                name: 'Nenhum',
                description: 'Sem efeitos adicionais',
                rarity: 'common',
                price: 0,
                unlocked: true
            },
            trail_basic: {
                id: 'trail_basic',
                name: 'Rastro B√°sico',
                description: 'Rastro simples de part√≠culas',
                rarity: 'common',
                price: 300,
                unlocked: false
            },
            trail_fire: {
                id: 'trail_fire',
                name: 'Rastro de Fogo',
                description: 'Chamas ardentes atr√°s da nave',
                rarity: 'rare',
                price: 600,
                unlocked: false
            },
            aura_energy: {
                id: 'aura_energy',
                name: 'Aura Energ√©tica',
                description: 'Campo de energia ao redor da nave',
                rarity: 'rare',
                price: 800,
                unlocked: false
            },
            portal: {
                id: 'portal',
                name: 'Portal Dimensional',
                description: 'Portais se abrem durante o movimento',
                rarity: 'epic',
                price: 1200,
                unlocked: false
            },
            lightning: {
                id: 'lightning',
                name: 'Raios El√©tricos',
                description: 'Descargas el√©tricas constantes',
                rarity: 'epic',
                price: 1500,
                unlocked: false
            },
            galaxy: {
                id: 'galaxy',
                name: 'Ess√™ncia Gal√°ctica',
                description: 'Estrelas e nebulosas orbitam a nave',
                rarity: 'legendary',
                price: 2500,
                unlocked: false
            }
        };
        
        // Battle Pass System
        const battlePassTiers = [
            // Tier 1-10
            { level: 1, xpRequired: 100, freeReward: { coins: 50 }, premiumReward: { coins: 100, gems: 5 } },
            { level: 2, xpRequired: 150, freeReward: { coins: 75 }, premiumReward: { coins: 150, xp: 200 } },
            { level: 3, xpRequired: 200, freeReward: { xp: 100 }, premiumReward: { coins: 200, gems: 10 } },
            { level: 4, xpRequired: 250, freeReward: { coins: 100 }, premiumReward: { skin: 'gold' } },
            { level: 5, xpRequired: 300, freeReward: { gems: 5 }, premiumReward: { coins: 300, gems: 15, darkMatter: 1 } },
            
            { level: 6, xpRequired: 400, freeReward: { coins: 125 }, premiumReward: { ship: 'fighter' } },
            { level: 7, xpRequired: 500, freeReward: { xp: 200 }, premiumReward: { coins: 400, gems: 20 } },
            { level: 8, xpRequired: 600, freeReward: { coins: 150 }, premiumReward: { effect: 'trail_fire' } },
            { level: 9, xpRequired: 700, freeReward: { gems: 8 }, premiumReward: { coins: 500, xp: 500 } },
            { level: 10, xpRequired: 800, freeReward: { coins: 200 }, premiumReward: { skin: 'stealth', gems: 25 } },
            
            // Tier 11-20
            { level: 11, xpRequired: 1000, freeReward: { xp: 300 }, premiumReward: { ship: 'scout' } },
            { level: 12, xpRequired: 1200, freeReward: { coins: 250 }, premiumReward: { coins: 600, gems: 30 } },
            { level: 13, xpRequired: 1400, freeReward: { gems: 10 }, premiumReward: { effect: 'aura_energy' } },
            { level: 14, xpRequired: 1600, freeReward: { coins: 300 }, premiumReward: { coins: 700, darkMatter: 3 } },
            { level: 15, xpRequired: 1800, freeReward: { darkMatter: 1 }, premiumReward: { skin: 'neon', gems: 35 } },
            
            { level: 16, xpRequired: 2000, freeReward: { coins: 350 }, premiumReward: { ship: 'destroyer' } },
            { level: 17, xpRequired: 2200, freeReward: { gems: 12 }, premiumReward: { coins: 800, xp: 800 } },
            { level: 18, xpRequired: 2400, freeReward: { xp: 500 }, premiumReward: { effect: 'portal' } },
            { level: 19, xpRequired: 2600, freeReward: { coins: 400 }, premiumReward: { coins: 900, gems: 40 } },
            { level: 20, xpRequired: 2800, freeReward: { gems: 15 }, premiumReward: { skin: 'plasma', darkMatter: 5 } },
            
            // Tier 21-30
            { level: 21, xpRequired: 3200, freeReward: { coins: 450 }, premiumReward: { ship: 'stealth' } },
            { level: 22, xpRequired: 3600, freeReward: { darkMatter: 2 }, premiumReward: { coins: 1000, gems: 45 } },
            { level: 23, xpRequired: 4000, freeReward: { coins: 500 }, premiumReward: { effect: 'lightning' } },
            { level: 24, xpRequired: 4400, freeReward: { gems: 18 }, premiumReward: { coins: 1200, xp: 1000 } },
            { level: 25, xpRequired: 4800, freeReward: { xp: 700 }, premiumReward: { ship: 'bomber', gems: 50 } },
            
            { level: 26, xpRequired: 5400, freeReward: { coins: 600 }, premiumReward: { skin: 'hologram' } },
            { level: 27, xpRequired: 6000, freeReward: { gems: 20 }, premiumReward: { coins: 1500, darkMatter: 8 } },
            { level: 28, xpRequired: 6600, freeReward: { darkMatter: 3 }, premiumReward: { effect: 'galaxy' } },
            { level: 29, xpRequired: 7200, freeReward: { coins: 700 }, premiumReward: { coins: 1800, gems: 60 } },
            { level: 30, xpRequired: 8000, freeReward: { gems: 25 }, premiumReward: { ship: 'vortex', darkMatter: 10 } },
            
            // Tier 31-40 (Epic Rewards)
            { level: 31, xpRequired: 9000, freeReward: { coins: 800 }, premiumReward: { ship: 'phoenix' } },
            { level: 32, xpRequired: 10000, freeReward: { darkMatter: 4 }, premiumReward: { coins: 2000, gems: 70 } },
            { level: 33, xpRequired: 11000, freeReward: { gems: 30 }, premiumReward: { skin: 'void' } },
            { level: 34, xpRequired: 12000, freeReward: { coins: 1000 }, premiumReward: { coins: 2500, darkMatter: 15 } },
            { level: 35, xpRequired: 13000, freeReward: { xp: 1000 }, premiumReward: { ship: 'quantum', gems: 80 } },
            
            { level: 36, xpRequired: 14500, freeReward: { gems: 35 }, premiumReward: { coins: 3000, xp: 2000 } },
            { level: 37, xpRequired: 16000, freeReward: { darkMatter: 5 }, premiumReward: { specialTitle: 'Destruidor Gal√°ctico' } },
            { level: 38, xpRequired: 17500, freeReward: { coins: 1200 }, premiumReward: { coins: 3500, gems: 90 } },
            { level: 39, xpRequired: 19000, freeReward: { gems: 40 }, premiumReward: { ship: 'titan' } },
            { level: 40, xpRequired: 20000, freeReward: { darkMatter: 8 }, premiumReward: { coins: 4000, darkMatter: 25 } },
            
            // Tier 41-50 (Legendary Rewards)
            { level: 41, xpRequired: 22000, freeReward: { coins: 1500 }, premiumReward: { ship: 'void' } },
            { level: 42, xpRequired: 24000, freeReward: { gems: 45 }, premiumReward: { coins: 4500, gems: 100 } },
            { level: 43, xpRequired: 26000, freeReward: { darkMatter: 10 }, premiumReward: { exclusiveEffect: 'cosmic_storm' } },
            { level: 44, xpRequired: 28000, freeReward: { coins: 1800 }, premiumReward: { coins: 5000, xp: 3000 } },
            { level: 45, xpRequired: 30000, freeReward: { gems: 50 }, premiumReward: { exclusiveSkin: 'cosmic_emperor' } },
            
            { level: 46, xpRequired: 33000, freeReward: { darkMatter: 12 }, premiumReward: { coins: 6000, gems: 120 } },
            { level: 47, xpRequired: 36000, freeReward: { coins: 2000 }, premiumReward: { specialTitle: 'Imperador C√≥smico' } },
            { level: 48, xpRequired: 39000, freeReward: { gems: 60 }, premiumReward: { coins: 7000, darkMatter: 40 } },
            { level: 49, xpRequired: 42000, freeReward: { darkMatter: 15 }, premiumReward: { exclusiveShip: 'ascension_proto' } },
            { level: 50, xpRequired: 50000, freeReward: { gems: 100, darkMatter: 20 }, premiumReward: { ship: 'godmode', exclusiveTitle: 'Deus das Gal√°xias', coins: 10000, gems: 200, darkMatter: 100 } }
        ];
        
        // Battle Pass Exclusive Items
        const battlePassExclusives = {
            // Exclusive Ships
            ascension_proto: {
                id: 'ascension_proto',
                name: 'Prot√≥tipo Ascens√£o',
                description: 'Vers√£o experimental da nave definitiva',
                rarity: 'exclusive',
                stats: {
                    speed: 9,
                    health: 400,
                    damage: 90,
                    fireRate: 60,
                    shield: 150
                },
                abilities: ['Modo Experimental', 'Energia Infinita', 'Transcend√™ncia'],
                sprite: 'üåü'
            },
            
            // Exclusive Skins
            cosmic_emperor: {
                id: 'cosmic_emperor',
                name: 'Imperador C√≥smico',
                description: 'Skin exclusiva para os conquistadores das gal√°xias',
                rarity: 'exclusive',
                colors: ['#FFD700', '#FF6B35', '#9B59B6', '#3498DB'],
                animated: true,
                holographic: true,
                exclusive: true
            },
            
            // Exclusive Effects
            cosmic_storm: {
                id: 'cosmic_storm',
                name: 'Tempestade C√≥smica',
                description: 'Tempestade de energia c√≥smica ao redor da nave',
                rarity: 'exclusive',
                exclusive: true
            }
        };
        
        // Player class
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 70;
                this.width = 24;
                this.height = 24;
                
                // Initialize with current ship stats
                const ship = shipModels[currentShipId];
                this.baseSpeed = ship.stats.speed;
                this.baseDamage = ship.stats.damage;
                this.baseFireRate = ship.stats.fireRate;
                
                this.speed = this.getEffectiveSpeed();
                this.shootCooldown = 0;
                this.invulnerable = 0;
                this.powerLevel = 1;
                
                // Update player health based on ship
                this.updateFromShip();
            }
            
            updateFromShip() {
                const ship = shipModels[currentShipId];
                playerMaxHealth = ship.stats.health;
                
                // Apply upgrades if they exist
                updatePlayerFromShip();
            }
            
            getEffectiveSpeed() {
                let speedMultiplier = 1;
                if (skillTree['speed1']) speedMultiplier *= 1.3;
                if (skillTree['speed2']) speedMultiplier *= 1.6;
                return this.baseSpeed * speedMultiplier;
            }
            
            getFireRate() {
                let fireRate = this.baseFireRate || 150;
                if (skillTree['firerate1']) fireRate *= 0.8;
                if (skillTree['firerate2']) fireRate *= 0.6;
                return fireRate;
            }
            
            getDamageMultiplier() {
                let damageMultiplier = 1;
                if (skillTree['damage1']) damageMultiplier *= 1.2;
                if (skillTree['damage2']) damageMultiplier *= 1.5;
                return damageMultiplier;
            }
            
            update(deltaTime) {
                this.speed = this.getEffectiveSpeed();
                
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) this.x -= this.speed;
                if (keys['ArrowRight'] || keys['d'] || keys['D']) this.x += this.speed;
                if (keys['ArrowUp'] || keys['w'] || keys['W']) this.y -= this.speed;
                if (keys['ArrowDown'] || keys['s'] || keys['S']) this.y += this.speed;
                
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
                
                if ((keys[' '] || keys['Space']) && this.shootCooldown <= 0) {
                    this.shoot();
                    this.shootCooldown = this.getFireRate();
                }
                
                if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;
                if (this.invulnerable > 0) this.invulnerable -= deltaTime;
            }
            
            shoot() {
                const world = worlds[currentWorldId];
                const baseBullets = [];
                
                if (this.powerLevel === 1) {
                    baseBullets.push({ x: this.x + this.width/2 - 2, y: this.y, vx: 0, vy: -10 });
                } else if (this.powerLevel === 2) {
                    baseBullets.push({ x: this.x + this.width/2 - 6, y: this.y, vx: 0, vy: -10 });
                    baseBullets.push({ x: this.x + this.width/2 + 2, y: this.y, vx: 0, vy: -10 });
                } else {
                    baseBullets.push({ x: this.x + this.width/2 - 2, y: this.y, vx: 0, vy: -10 });
                    baseBullets.push({ x: this.x + this.width/2 - 12, y: this.y, vx: -2, vy: -10 });
                    baseBullets.push({ x: this.x + this.width/2 + 8, y: this.y, vx: 2, vy: -10 });
                }
                
                // Apply multishot skill
                if (skillTree['multishot']) {
                    const extraBullets = [];
                    baseBullets.forEach(bullet => {
                        extraBullets.push({ x: bullet.x - 8, y: bullet.y, vx: bullet.vx - 1, vy: bullet.vy });
                        extraBullets.push({ x: bullet.x + 8, y: bullet.y, vx: bullet.vx + 1, vy: bullet.vy });
                    });
                    baseBullets.push(...extraBullets);
                }
                
                // Create bullets with base damage from ship + multipliers
                const baseDamage = this.baseDamage || 25;
                const damageMultiplier = this.getDamageMultiplier();
                const finalDamage = baseDamage * damageMultiplier;
                
                baseBullets.forEach(bulletData => {
                    const bullet = new Bullet(bulletData.x, bulletData.y, bulletData.vx, bulletData.vy, true);
                    bullet.damage = finalDamage;
                    bullets.push(bullet);
                });
            }
            
            takeDamage(damage) {
                if (this.invulnerable <= 0) {
                    playerHealth = Math.max(0, playerHealth - damage);
                    this.invulnerable = 1500;
                    createExplosion(this.x + this.width/2, this.y + this.height/2, '#ff0000', 8);
                    
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
            }
            
            draw() {
                const flash = this.invulnerable > 0 && Math.floor(this.invulnerable / 100) % 2;
                if (!flash) {
                    this.drawPixelSprite();
                }
            }
            
            drawPixelSprite() {
                const pixels = [
                    '      ****      ',
                    '     ******     ',
                    '    ********    ',
                    '   **********   ',
                    '  ************  ',
                    ' ************** ',
                    '****************',
                    '****************',
                    '***  ******  ***',
                    '**   ****   ***',
                    '*     **     **',
                    '      **      '
                ];
                
                // Get current skin colors
                const currentSkin = shipSkins[currentSkinId];
                const primaryColor = currentSkin.colors[0] || '#00ccff';
                const secondaryColor = currentSkin.colors[1] || primaryColor;
                
                const pixelSize = 2;
                for (let y = 0; y < pixels.length; y++) {
                    for (let x = 0; x < pixels[y].length; x++) {
                        if (pixels[y][x] === '*') {
                            // Alternate between primary and secondary colors for effect
                            const useSecondary = (x + y) % 3 === 0;
                            ctx.fillStyle = useSecondary ? secondaryColor : primaryColor;
                            
                            // Add glow effect for special skins
                            if (currentSkin.animated) {
                                ctx.shadowColor = primaryColor;
                                ctx.shadowBlur = 5;
                            }
                            
                            ctx.fillRect(
                                this.x + x * pixelSize,
                                this.y + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                            
                            ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // Draw visual effects
                this.drawVisualEffects();
            }
            
            drawVisualEffects() {
                const effect = visualEffects[currentEffectId];
                if (!effect || effect.id === 'none') return;
                
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                switch(effect.id) {
                    case 'trail_basic':
                        // Basic particle trail
                        if (Math.random() < 0.3) {
                            particles.push(new Particle(
                                centerX + (Math.random() - 0.5) * this.width,
                                this.y + this.height,
                                0, 2,
                                '#ffffff',
                                500
                            ));
                        }
                        break;
                        
                    case 'trail_fire':
                        // Fire trail
                        if (Math.random() < 0.5) {
                            const colors = ['#ff4400', '#ff8800', '#ffaa00'];
                            particles.push(new Particle(
                                centerX + (Math.random() - 0.5) * this.width,
                                this.y + this.height,
                                (Math.random() - 0.5) * 2, 
                                2 + Math.random() * 2,
                                colors[Math.floor(Math.random() * colors.length)],
                                300 + Math.random() * 200
                            ));
                        }
                        break;
                        
                    case 'aura_energy':
                        // Energy aura
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.width/2 + 5 + Math.sin(Date.now() * 0.01) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'lightning':
                        // Lightning effects
                        if (Math.random() < 0.1) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(centerX, centerY);
                            ctx.lineTo(
                                centerX + (Math.random() - 0.5) * 40,
                                centerY + (Math.random() - 0.5) * 40
                            );
                            ctx.stroke();
                        }
                        break;
                }
            }
        }
        
        // Bullet class
        class Bullet {
            constructor(x, y, vx, vy, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = 4;
                this.height = 8;
                this.isPlayer = isPlayer;
                this.damage = isPlayer ? 25 : 20;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
            }
            
            draw() {
                const world = worlds[currentWorldId];
                ctx.fillStyle = this.isPlayer ? '#ffff00' : world.colors.enemies[0];
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.shadowColor = this.isPlayer ? '#ffff00' : world.colors.enemies[0];
                ctx.shadowBlur = 5;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.y < -10 || this.y > canvas.height + 10 || 
                       this.x < -10 || this.x > canvas.width + 10;
            }
        }
        
        // Enemy class
        class Enemy {
            constructor(x, y, type = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = type === 1 ? 20 : type === 2 ? 30 : 40;
                this.height = this.width;
                const world = worlds[currentWorldId];
                this.speed = (type === 1 ? 2 : type === 2 ? 1.5 : 1) * world.difficulty;
                this.hp = Math.ceil(type * world.difficulty * 25);
                this.maxHp = this.hp;
                this.shootTimer = Math.random() * 2000;
                this.zigzag = Math.random() * Math.PI * 2;
                this.coinValue = type * Math.ceil(world.difficulty);
            }
            
            update(deltaTime) {
                this.y += this.speed;
                this.x += Math.sin(this.zigzag) * 0.8;
                this.zigzag += 0.02;
                
                this.shootTimer -= deltaTime;
                if (this.shootTimer <= 0 && this.y > 50 && this.y < canvas.height - 100) {
                    this.shoot();
                    this.shootTimer = 1500 + Math.random() * 2000;
                }
            }
            
            shoot() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const speed = 4;
                
                enemyBullets.push(new Bullet(
                    this.x + this.width/2,
                    this.y + this.height,
                    (dx / dist) * speed,
                    (dy / dist) * speed,
                    false
                ));
            }
            
            takeDamage(damage) {
                this.hp -= damage;
                return this.hp <= 0;
            }
            
            draw() {
                if (this.type === 1) {
                    this.drawType1();
                } else if (this.type === 2) {
                    this.drawType2();
                } else {
                    this.drawType3();
                }
                
                if (this.hp < this.maxHp) {
                    const barWidth = this.width;
                    const barHeight = 4;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x, this.y - 10, barWidth, barHeight);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x, this.y - 10, (this.hp / this.maxHp) * barWidth, barHeight);
                }
            }
            
            drawType1() {
                const pixels = [
                    ' *** *** ',
                    '*********',
                    '**** ****',
                    ' ******* ',
                    '  *****  ',
                    '   ***   '
                ];
                const world = worlds[currentWorldId];
                this.drawPixels(pixels, world.colors.enemies[0], 2);
            }
            
            drawType2() {
                const pixels = [
                    '  *******  ',
                    ' ********* ',
                    '***********',
                    '***  *  ***',
                    '**  ***  **',
                    '*  *****  *',
                    '   *****   ',
                    '    ***    '
                ];
                const world = worlds[currentWorldId];
                this.drawPixels(pixels, world.colors.enemies[1], 2);
            }
            
            drawType3() {
                const pixels = [
                    '    *****    ',
                    '   *******   ',
                    '  *********  ',
                    ' *********** ',
                    '*************',
                    '**  *****  **',
                    '*   *****   *',
                    '    *****    ',
                    '   *******   ',
                    '    *****    '
                ];
                const world = worlds[currentWorldId];
                this.drawPixels(pixels, world.colors.enemies[2], 2);
            }
            
            drawPixels(pixels, color, pixelSize) {
                ctx.fillStyle = color;
                for (let y = 0; y < pixels.length; y++) {
                    for (let x = 0; x < pixels[y].length; x++) {
                        if (pixels[y][x] === '*') {
                            ctx.fillRect(
                                this.x + x * pixelSize,
                                this.y + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                        }
                    }
                }
            }
            
            isOffScreen() {
                return this.y > canvas.height + 50;
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 4 + 2;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
                this.vy += 0.1;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        // Star background
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 3 + 0.5;
                this.size = Math.random() * 2 + 1;
                this.brightness = Math.random();
            }
            
            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = -10;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            draw() {
                const world = worlds[currentWorldId];
                ctx.globalAlpha = this.brightness;
                ctx.fillStyle = world.colors.stars;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        // Powerup class
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 16;
                this.height = 16;
                this.speed = 2;
                this.bob = 0;
            }
            
            update() {
                this.y += this.speed;
                this.bob += 0.1;
            }
            
            draw() {
                const offsetY = Math.sin(this.bob) * 3;
                let color = this.type === 'weapon' ? '#00ff00' : 
                           this.type === 'health' ? '#ff00ff' : '#00ffff';
                
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y + offsetY, this.width, this.height);
                
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y + offsetY, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.y > canvas.height + 20;
            }
        }
        
        // Game functions
        function createExplosion(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = Math.random() * 5 + 2;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    color,
                    500 + Math.random() * 500
                ));
            }
        }
        
        function spawnEnemy() {
            const world = worlds[currentWorldId];
            const rand = Math.random();
            const type = rand < 0.6 ? 1 : rand < 0.8 ? 2 : 3;
            const enemy = new Enemy(
                Math.random() * (canvas.width - 50) + 25,
                -50,
                type
            );
            enemies.push(enemy);
        }
        
        function spawnPowerup(x, y) {
            if (Math.random() < 0.25) {
                const types = ['weapon', 'health'];
                const type = types[Math.floor(Math.random() * types.length)];
                powerups.push(new Powerup(x - 8, y - 8, type));
            }
        }
        
        function checkCollisions() {
            // Player bullets vs enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        bullets.splice(i, 1);
                        
                        if (enemy.takeDamage(bullet.damage)) {
                            const world = worlds[currentWorldId];
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, world.colors.enemies[0]);
                            const scoreGained = enemy.type * 10 * Math.ceil(world.difficulty);
                            score += scoreGained;
                            coins += enemy.coinValue;
                            coinsThisRound += enemy.coinValue;
                            
                            // Progression system updates
                            addXP(scoreGained); // Gain XP equal to score
                            addBattlePassXP(Math.floor(scoreGained / 2)); // Battle Pass XP = half of score XP
                            achievementProgress.totalKills = (achievementProgress.totalKills || 0) + 1;
                            achievementProgress.totalCoinsCollected = (achievementProgress.totalCoinsCollected || 0) + enemy.coinValue;
                            achievementProgress.highScore = Math.max(achievementProgress.highScore || 0, score);
                            
                            // Update challenges
                            updateChallenges('kills', 1);
                            updateChallenges('coins', enemy.coinValue);
                            updateChallenges('score', score);
                            
                            checkAchievements();
                            
                            spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
            
            // Enemy bullets vs player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                if (bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {
                    
                    enemyBullets.splice(i, 1);
                    player.takeDamage(bullet.damage);
                }
            }
            
            // Enemies vs player
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    const world = worlds[currentWorldId];
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, world.colors.enemies[0]);
                    enemies.splice(i, 1);
                    player.takeDamage(40);
                }
            }
            
            // Player vs powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                if (player.x < powerup.x + powerup.width &&
                    player.x + player.width > powerup.x &&
                    player.y < powerup.y + powerup.height &&
                    player.y + player.height > powerup.y) {
                    
                    collectPowerup(powerup.type);
                    powerups.splice(i, 1);
                }
            }
        }
        
        function collectPowerup(type) {
            if (type === 'weapon') {
                player.powerLevel = Math.min(3, player.powerLevel + 1);
            } else if (type === 'health') {
                playerHealth = Math.min(playerMaxHealth, playerHealth + 30);
            }
            
            // Progression system updates
            achievementProgress.powerupsCollected = (achievementProgress.powerupsCollected || 0) + 1;
            updateChallenges('powerups', 1);
            checkAchievements();
        }
        
        function updateHealthBar() {
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercentage + '%';
            document.getElementById('healthText').textContent = `${playerHealth}/${playerMaxHealth}`;
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('coinsUI').textContent = coins;
            document.getElementById('currentWorldName').textContent = worlds[currentWorldId].name;
            updateHealthBar();
        }
        
        function drawBackground() {
            const world = worlds[currentWorldId];
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, world.colors.bg[0]);
            gradient.addColorStop(1, world.colors.bg[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function gameOver() {
            gameRunning = false;
            gameState = 'gameOver';
            
            // Calculate survival time
            survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
            
            // Update progression
            achievementProgress.longestSurvival = Math.max(achievementProgress.longestSurvival || 0, survivalTime);
            achievementProgress.highScore = Math.max(achievementProgress.highScore || 0, score);
            
            // Update challenges
            updateChallenges('survival', survivalTime);
            updateChallenges('score', score);
            
            checkAchievements();
            saveProgressionData();
            
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('coinsEarned').textContent = coinsThisRound;
            saveGameData();
        }
        
        // Battle Pass Functions
        function updateBattlePassProgress() {
            const currentTier = battlePassTiers.find(tier => tier.level === battlePassLevel);
            const nextTier = battlePassTiers.find(tier => tier.level === battlePassLevel + 1);
            
            if (!currentTier) return;
            
            // Verifica se pode subir de n√≠vel
            if (nextTier && battlePassXP >= currentTier.xpRequired) {
                battlePassLevel++;
                battlePassXP -= currentTier.xpRequired;
                
                // Efeito visual de level up
                showNotification(`üéâ Battle Pass N√≠vel ${battlePassLevel}! Novas recompensas dispon√≠veis!`);
                updateBattlePassProgress(); // Recursivo para m√∫ltiplos n√≠veis
            }
        }
        
        function addBattlePassXP(amount) {
            battlePassXP += amount;
            updateBattlePassProgress();
            saveGameData();
        }
        
        function claimBattlePassReward(tier, isPremium = false) {
            const rewardKey = `${tier}-${isPremium ? 'premium' : 'free'}`;
            
            if (battlePassClaimedRewards.includes(rewardKey)) {
                showNotification('‚ùå Recompensa j√° coletada!');
                return false;
            }
            
            const tierData = battlePassTiers.find(t => t.level === tier);
            if (!tierData || tier > battlePassLevel) {
                showNotification('‚ùå N√≠vel n√£o alcan√ßado ainda!');
                return false;
            }
            
            if (isPremium && !battlePassPremium) {
                showNotification('‚ùå Vers√£o Premium necess√°ria!');
                return false;
            }
            
            const reward = isPremium ? tierData.premiumReward : tierData.freeReward;
            
            // Aplicar recompensas
            if (reward.coins) {
                coins += reward.coins;
                showNotification(`üí∞ +${reward.coins} Moedas!`);
            }
            
            if (reward.gems) {
                gems += reward.gems;
                showNotification(`üíé +${reward.gems} Gemas!`);
            }
            
            if (reward.darkMatter) {
                if (!playerStats.darkMatter) playerStats.darkMatter = 0;
                playerStats.darkMatter += reward.darkMatter;
                showNotification(`üåå +${reward.darkMatter} Mat√©ria Escura!`);
            }
            
            if (reward.xp) {
                playerStats.experience += reward.xp;
                showNotification(`‚≠ê +${reward.xp} XP!`);
            }
            
            if (reward.ship) {
                if (shipModels[reward.ship]) {
                    shipModels[reward.ship].unlocked = true;
                    showNotification(`üöÄ Nova nave desbloqueada: ${shipModels[reward.ship].name}!`);
                }
            }
            
            if (reward.skin) {
                if (shipSkins[reward.skin]) {
                    shipSkins[reward.skin].unlocked = true;
                    showNotification(`üé® Nova skin desbloqueada: ${shipSkins[reward.skin].name}!`);
                }
            }
            
            if (reward.effect) {
                if (visualEffects[reward.effect]) {
                    visualEffects[reward.effect].unlocked = true;
                    showNotification(`‚ú® Novo efeito visual: ${visualEffects[reward.effect].name}!`);
                }
            }
            
            if (reward.exclusiveShip) {
                if (battlePassExclusives[reward.exclusiveShip]) {
                    // Adiciona nave exclusiva ao invent√°rio
                    if (!playerStats.exclusiveItems) playerStats.exclusiveItems = {};
                    playerStats.exclusiveItems[reward.exclusiveShip] = true;
                    showNotification(`üåü EXCLUSIVA! ${battlePassExclusives[reward.exclusiveShip].name}!`);
                }
            }
            
            if (reward.exclusiveSkin) {
                if (battlePassExclusives[reward.exclusiveSkin]) {
                    if (!playerStats.exclusiveItems) playerStats.exclusiveItems = {};
                    playerStats.exclusiveItems[reward.exclusiveSkin] = true;
                    showNotification(`üåü SKIN EXCLUSIVA! ${battlePassExclusives[reward.exclusiveSkin].name}!`);
                }
            }
            
            if (reward.specialTitle) {
                if (!playerStats.titles) playerStats.titles = [];
                playerStats.titles.push(reward.specialTitle);
                showNotification(`üëë Novo t√≠tulo: ${reward.specialTitle}!`);
            }
            
            battlePassClaimedRewards.push(rewardKey);
            saveGameData();
            return true;
        }
        
        function buyBattlePassPremium() {
            if (gems >= 500) {
                gems -= 500;
                battlePassPremium = true;
                showNotification('üåü Battle Pass Premium ativado! Recompensas especiais liberadas!');
                saveGameData();
                return true;
            } else {
                showNotification('‚ùå Voc√™ precisa de 500 gemas para o Battle Pass Premium!');
                return false;
            }
        }
        
        function resetBattlePass() {
            // Novo season
            battlePassSeason++;
            battlePassLevel = 1;
            battlePassXP = 0;
            battlePassPremium = false;
            battlePassClaimedRewards = [];
            
            showNotification(`üéä Nova temporada do Battle Pass! Season ${battlePassSeason}`);
            saveGameData();
        }
        
        function saveGameData() {
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_gems', gems.toString());
            localStorage.setItem('waveslayers_current_world', currentWorldId);
            const unlockedWorldIds = Object.keys(worlds).filter(id => worlds[id].unlocked);
            localStorage.setItem('waveslayers_unlocked_worlds', JSON.stringify(unlockedWorldIds));
            
            // Save Battle Pass data
            localStorage.setItem('waveslayers_battlepass_level', battlePassLevel.toString());
            localStorage.setItem('waveslayers_battlepass_xp', battlePassXP.toString());
            localStorage.setItem('waveslayers_battlepass_premium', battlePassPremium.toString());
            localStorage.setItem('waveslayers_battlepass_season', battlePassSeason.toString());
            localStorage.setItem('waveslayers_battlepass_claimed', JSON.stringify(battlePassClaimedRewards));
            
            // Save ship customization data
            localStorage.setItem('waveslayers_current_ship', currentShip);
            localStorage.setItem('waveslayers_ship_models', JSON.stringify(shipModels));
            localStorage.setItem('waveslayers_ship_skins', JSON.stringify(shipSkins));
            localStorage.setItem('waveslayers_visual_effects', JSON.stringify(visualEffects));
            localStorage.setItem('waveslayers_ship_upgrades', JSON.stringify(shipUpgrades));
            localStorage.setItem('waveslayers_current_skin', currentSkin);
            localStorage.setItem('waveslayers_current_effect', currentEffect);
            
            // Save player stats
            localStorage.setItem('waveslayers_player_stats', JSON.stringify(playerStats));
        }
        
        function loadGameData() {
            // Load basic data
            const savedCoins = localStorage.getItem('waveslayers_coins');
            if (savedCoins) coins = parseInt(savedCoins);
            
            const savedGems = localStorage.getItem('waveslayers_gems');
            if (savedGems) gems = parseInt(savedGems);
            
            const savedWorld = localStorage.getItem('waveslayers_current_world');
            if (savedWorld) currentWorldId = savedWorld;
            
            const savedUnlockedWorlds = localStorage.getItem('waveslayers_unlocked_worlds');
            if (savedUnlockedWorlds) {
                const unlockedIds = JSON.parse(savedUnlockedWorlds);
                unlockedIds.forEach(id => {
                    if (worlds[id]) worlds[id].unlocked = true;
                });
            }
            
            // Load Battle Pass data
            const savedBPLevel = localStorage.getItem('waveslayers_battlepass_level');
            if (savedBPLevel) battlePassLevel = parseInt(savedBPLevel);
            
            const savedBPXP = localStorage.getItem('waveslayers_battlepass_xp');
            if (savedBPXP) battlePassXP = parseInt(savedBPXP);
            
            const savedBPPremium = localStorage.getItem('waveslayers_battlepass_premium');
            if (savedBPPremium) battlePassPremium = savedBPPremium === 'true';
            
            const savedBPSeason = localStorage.getItem('waveslayers_battlepass_season');
            if (savedBPSeason) battlePassSeason = parseInt(savedBPSeason);
            
            const savedBPClaimed = localStorage.getItem('waveslayers_battlepass_claimed');
            if (savedBPClaimed) battlePassClaimedRewards = JSON.parse(savedBPClaimed);
            
            // Load ship customization data
            const savedCurrentShip = localStorage.getItem('waveslayers_current_ship');
            if (savedCurrentShip) currentShip = savedCurrentShip;
            
            const savedShipModels = localStorage.getItem('waveslayers_ship_models');
            if (savedShipModels) {
                const loadedModels = JSON.parse(savedShipModels);
                Object.keys(loadedModels).forEach(key => {
                    if (shipModels[key]) {
                        shipModels[key].unlocked = loadedModels[key].unlocked;
                    }
                });
            }
            
            const savedShipSkins = localStorage.getItem('waveslayers_ship_skins');
            if (savedShipSkins) {
                const loadedSkins = JSON.parse(savedShipSkins);
                Object.keys(loadedSkins).forEach(key => {
                    if (shipSkins[key]) {
                        shipSkins[key].unlocked = loadedSkins[key].unlocked;
                    }
                });
            }
            
            const savedVisualEffects = localStorage.getItem('waveslayers_visual_effects');
            if (savedVisualEffects) {
                const loadedEffects = JSON.parse(savedVisualEffects);
                Object.keys(loadedEffects).forEach(key => {
                    if (visualEffects[key]) {
                        visualEffects[key].unlocked = loadedEffects[key].unlocked;
                    }
                });
            }
            
            const savedUpgrades = localStorage.getItem('waveslayers_ship_upgrades');
            if (savedUpgrades) shipUpgrades = JSON.parse(savedUpgrades);
            
            const savedCurrentSkin = localStorage.getItem('waveslayers_current_skin');
            if (savedCurrentSkin) currentSkin = savedCurrentSkin;
            
            const savedCurrentEffect = localStorage.getItem('waveslayers_current_effect');
            if (savedCurrentEffect) currentEffect = savedCurrentEffect;
            
            const savedPlayerStats = localStorage.getItem('waveslayers_player_stats');
            if (savedPlayerStats) playerStats = {...playerStats, ...JSON.parse(savedPlayerStats)};
        }
        
        function startGame() {
            gameState = 'playing';
            gameRunning = true;
            isPaused = false;
            score = 0;
            level = 1;
            
            // Apply skill bonuses
            updatePlayerStats();
            playerHealth = playerMaxHealth;
            coinsThisRound = 0;
            gameStartTime = Date.now();
            survivalTime = 0;
            
            player = new Player();
            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            powerups = [];
            
            enemySpawnTimer = 0;
            powerupSpawnTimer = 0;
            
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('worldSelectBtn').style.display = 'block';
            document.getElementById('gameOver').style.display = 'none';
            
            // Stop menu animation
            menuAnimationRunning = false;
        }
        
        function restartGame() {
            startGame();
        }
        
        function goToMainMenu() {
            gameState = 'menu';
            gameRunning = false;
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('worldSelectBtn').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('worldsMenu').style.display = 'none';
            
            // Start menu animation
            initMenuAnimation();
        }
        
        function openWorldsMenu() {
            document.getElementById('worldsMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('worldSelectBtn').style.display = 'none';
            updateCoinsDisplay();
            renderWorldsGrid();
            
            // Stop menu animation
            menuAnimationRunning = false;
        }
        
        function closeWorldsMenu() {
            document.getElementById('worldsMenu').style.display = 'none';
            if (gameState === 'playing') {
                document.getElementById('gameUI').style.display = 'block';
                document.getElementById('worldSelectBtn').style.display = 'block';
            } else {
                document.getElementById('mainMenu').style.display = 'flex';
                // Restart menu animation
                initMenuAnimation();
            }
        }
        
        function updateCoinsDisplay() {
            document.getElementById('coinsAmount').textContent = coins;
        }
        
        function renderWorldsGrid() {
            const grid = document.getElementById('worldsGrid');
            grid.innerHTML = '';
            
            Object.values(worlds).forEach(world => {
                const card = document.createElement('div');
                card.className = `world-card ${world.unlocked ? 'unlocked' : 'locked'}`;
                
                const preview = document.createElement('div');
                preview.className = 'world-preview';
                preview.style.background = `linear-gradient(135deg, ${world.colors.bg[0]}, ${world.colors.bg[1]})`;
                
                // Add some stars to preview
                for (let i = 0; i < 8; i++) {
                    const star = document.createElement('div');
                    star.style.position = 'absolute';
                    star.style.width = '2px';
                    star.style.height = '2px';
                    star.style.background = world.colors.stars;
                    star.style.left = Math.random() * 100 + '%';
                    star.style.top = Math.random() * 100 + '%';
                    preview.appendChild(star);
                }
                
                card.innerHTML = `
                    <div class="world-name">${world.name}</div>
                    <div class="world-description">${world.description}</div>
                    ${!world.unlocked ? `<div class="world-price">üí∞ ${world.price} Moedas</div>` : ''}
                    <button class="world-action" 
                            ${!world.unlocked && coins < world.price ? 'disabled' : ''} 
                            onclick="${world.unlocked ? `selectWorld('${world.id}')` : `buyWorld('${world.id}')`}">
                        ${world.unlocked ? (world.id === currentWorldId ? 'üåü Atual' : 'üöÄ Selecionar') : 
                          (coins >= world.price ? 'üí≥ Comprar' : 'üîí Bloqueado')}
                    </button>
                `;
                
                card.insertBefore(preview, card.firstChild);
                grid.appendChild(card);
            });
        }
        
        function buyWorld(worldId) {
            const world = worlds[worldId];
            if (coins >= world.price && !world.unlocked) {
                coins -= world.price;
                world.unlocked = true;
                
                // Update progression
                achievementProgress.worldsUnlocked = (achievementProgress.worldsUnlocked || 1) + 1;
                checkAchievements();
                saveProgressionData();
                
                saveGameData();
                updateCoinsDisplay();
                renderWorldsGrid();
                
                // Show success message
                alert(`üéâ Mundo ${world.name} desbloqueado com sucesso!`);
            }
        }
        
        function selectWorld(worldId) {
            if (worlds[worldId].unlocked) {
                showLoadingScreen(`Viajando para ${worlds[worldId].name}...`);
                
                setTimeout(() => {
                    currentWorldId = worldId;
                    saveGameData();
                    
                    // Reset stars for new world
                    stars = [];
                    for (let i = 0; i < 120; i++) {
                        stars.push(new Star());
                    }
                    
                    hideLoadingScreen();
                    closeWorldsMenu();
                    
                    if (gameState === 'playing') {
                        // Reset some game elements for new world
                        enemies = [];
                        enemyBullets = [];
                        particles = [];
                    }
                }, 1500);
            }
        }
        
        function showLoadingScreen(message) {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'flex';
        }
        
        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }
        
        function showInstructions() {
            alert(`üéÆ CONTROLES DO WAVESLAYERS:

üöÄ MOVIMENTO:
‚Ä¢ WASD ou Setas: Mover nave
‚Ä¢ Espa√ßo: Atirar
‚Ä¢ P: Pausar/Despausar

üí∞ SISTEMA DE MOEDAS:
‚Ä¢ Destrua inimigos para ganhar moedas
‚Ä¢ Use moedas para desbloquear novos mundos
‚Ä¢ Cada mundo tem desafios √∫nicos

‚ö° POWER-UPS:
‚Ä¢ Verde: Melhora armas
‚Ä¢ Rosa: Restaura vida

üåç MUNDOS:
‚Ä¢ Cada mundo tem inimigos √∫nicos
‚Ä¢ Dificuldade aumenta por mundo
‚Ä¢ Explore gal√°xias distantes!

Boa sorte, comandante! üöÄ‚ú®`);
        }
        
        // ===== SISTEMA DE PROGRESS√ÉO =====
        
        // Dados dos Skills
        const skillBranches = {
            attack: {
                name: 'Ataque',
                icon: '‚öîÔ∏è',
                color: '#ff4444',
                skills: [
                    { id: 'damage1', name: 'For√ßa B√°sica', cost: 1, effect: 'damage', value: 1.2, description: '+20% Dano' },
                    { id: 'damage2', name: 'For√ßa Avan√ßada', cost: 2, effect: 'damage', value: 1.5, description: '+50% Dano', requires: ['damage1'] },
                    { id: 'firerate1', name: 'Tiro R√°pido', cost: 1, effect: 'firerate', value: 0.8, description: '+25% Vel. Tiro' },
                    { id: 'firerate2', name: 'Rajada', cost: 3, effect: 'firerate', value: 0.6, description: '+67% Vel. Tiro', requires: ['firerate1'] },
                    { id: 'multishot', name: 'Tiro M√∫ltiplo', cost: 5, effect: 'multishot', value: 2, description: 'Atira 2 proj√©teis', requires: ['damage2', 'firerate2'] }
                ]
            },
            defense: {
                name: 'Defesa',
                icon: 'üõ°Ô∏è',
                color: '#4444ff',
                skills: [
                    { id: 'health1', name: 'Vida Extra', cost: 1, effect: 'health', value: 150, description: '+50% Vida M√°xima' },
                    { id: 'health2', name: 'Tanque', cost: 2, effect: 'health', value: 200, description: '+100% Vida M√°xima', requires: ['health1'] },
                    { id: 'shield1', name: 'Escudo B√°sico', cost: 2, effect: 'shield', value: 50, description: '+50% Escudo' },
                    { id: 'shield2', name: 'Escudo Avan√ßado', cost: 3, effect: 'shield', value: 100, description: '+100% Escudo', requires: ['shield1'] },
                    { id: 'regen', name: 'Regenera√ß√£o', cost: 4, effect: 'regen', value: 1, description: 'Regenera vida', requires: ['health2', 'shield2'] }
                ]
            },
            speed: {
                name: 'Velocidade',
                icon: '‚ö°',
                color: '#ffff44',
                skills: [
                    { id: 'speed1', name: 'Propuls√£o', cost: 1, effect: 'speed', value: 1.3, description: '+30% Velocidade' },
                    { id: 'speed2', name: 'Turbina', cost: 2, effect: 'speed', value: 1.6, description: '+60% Velocidade', requires: ['speed1'] },
                    { id: 'dash1', name: 'Dash B√°sico', cost: 2, effect: 'dash', value: 1, description: 'Habilidade Dash' },
                    { id: 'dash2', name: 'Dash Avan√ßado', cost: 3, effect: 'dash', value: 2, description: 'Dash mais r√°pido', requires: ['dash1'] },
                    { id: 'teleport', name: 'Teletransporte', cost: 5, effect: 'teleport', value: 1, description: 'Teleporte instant√¢neo', requires: ['speed2', 'dash2'] }
                ]
            },
            special: {
                name: 'Especiais',
                icon: '‚ú®',
                color: '#ff44ff',
                skills: [
                    { id: 'magnet1', name: 'Magnetismo', cost: 2, effect: 'magnet', value: 1.5, description: 'Atrai power-ups' },
                    { id: 'magnet2', name: 'Super √çm√£', cost: 3, effect: 'magnet', value: 3, description: 'Maior alcance', requires: ['magnet1'] },
                    { id: 'luck1', name: 'Sorte', cost: 2, effect: 'luck', value: 1.5, description: '+50% drop rate' },
                    { id: 'luck2', name: 'Super Sorte', cost: 4, effect: 'luck', value: 2.5, description: '+150% drop rate', requires: ['luck1'] },
                    { id: 'ultimate', name: 'Ultimate', cost: 10, effect: 'ultimate', value: 1, description: 'Poder devastador', requires: ['magnet2', 'luck2'] }
                ]
            }
        };
        
        // Dados das Conquistas
        const achievementsList = [
            { id: 'first_kill', name: 'Primeiro Sangue', icon: 'üéØ', description: 'Destrua seu primeiro inimigo', reward: { coins: 50, xp: 100 }, target: 1, type: 'kills' },
            { id: 'kill_100', name: 'Ca√ßador', icon: 'üèπ', description: 'Destrua 100 inimigos', reward: { coins: 200, xp: 500, gems: 10 }, target: 100, type: 'kills' },
            { id: 'kill_1000', name: 'Exterminador', icon: 'üíÄ', description: 'Destrua 1000 inimigos', reward: { coins: 1000, xp: 2000, gems: 50 }, target: 1000, type: 'kills' },
            { id: 'kill_10000', name: 'Lenda', icon: 'üëë', description: 'Destrua 10000 inimigos', reward: { coins: 5000, xp: 10000, gems: 200, darkMatter: 10 }, target: 10000, type: 'kills' },
            
            { id: 'score_1k', name: 'Novato', icon: '‚≠ê', description: 'Atinja 1.000 pontos', reward: { coins: 100, xp: 200 }, target: 1000, type: 'score' },
            { id: 'score_10k', name: 'Veterano', icon: 'üåü', description: 'Atinja 10.000 pontos', reward: { coins: 500, xp: 1000, gems: 25 }, target: 10000, type: 'score' },
            { id: 'score_100k', name: 'Mestre', icon: 'üí´', description: 'Atinja 100.000 pontos', reward: { coins: 2500, xp: 5000, gems: 100 }, target: 100000, type: 'score' },
            { id: 'score_1m', name: 'Deus', icon: 'üåå', description: 'Atinja 1.000.000 pontos', reward: { coins: 10000, xp: 20000, gems: 500, darkMatter: 50 }, target: 1000000, type: 'score' },
            
            { id: 'survival_30s', name: 'Sobrevivente', icon: '‚è±Ô∏è', description: 'Sobreviva 30 segundos', reward: { coins: 75, xp: 150 }, target: 30, type: 'survival' },
            { id: 'survival_5m', name: 'Resistente', icon: 'üïê', description: 'Sobreviva 5 minutos', reward: { coins: 300, xp: 600, gems: 15 }, target: 300, type: 'survival' },
            { id: 'survival_15m', name: 'Imortal', icon: '‚ôæÔ∏è', description: 'Sobreviva 15 minutos', reward: { coins: 1500, xp: 3000, gems: 75, darkMatter: 5 }, target: 900, type: 'survival' },
            
            { id: 'collect_100_coins', name: 'Colecionador', icon: 'üí∞', description: 'Colete 100 moedas', reward: { xp: 200, gems: 5 }, target: 100, type: 'coins_collected' },
            { id: 'collect_1000_coins', name: 'Magnata', icon: 'üíé', description: 'Colete 1000 moedas', reward: { xp: 1000, gems: 50 }, target: 1000, type: 'coins_collected' },
            
            { id: 'unlock_world_2', name: 'Explorador', icon: 'üåç', description: 'Desbloqueie o segundo mundo', reward: { coins: 200, xp: 400, gems: 20 }, target: 1, type: 'worlds_unlocked' },
            { id: 'unlock_all_worlds', name: 'Conquistador', icon: 'üèÜ', description: 'Desbloqueie todos os mundos', reward: { coins: 5000, xp: 10000, gems: 500, darkMatter: 100 }, target: 6, type: 'worlds_unlocked' },
            
            { id: 'powerup_collector', name: 'Energizado', icon: '‚ö°', description: 'Colete 50 power-ups', reward: { coins: 150, xp: 300, gems: 10 }, target: 50, type: 'powerups_collected' },
            { id: 'speed_demon', name: 'Dem√¥nio da Velocidade', icon: 'üèÉ', description: 'Invista todos os pontos em velocidade', reward: { coins: 1000, xp: 2000, gems: 100 }, target: 1, type: 'special' },
            { id: 'tank_build', name: 'Tanque', icon: 'üõ°Ô∏è', description: 'Invista todos os pontos em defesa', reward: { coins: 1000, xp: 2000, gems: 100 }, target: 1, type: 'special' },
            { id: 'glass_cannon', name: 'Canh√£o de Vidro', icon: 'üí•', description: 'Invista todos os pontos em ataque', reward: { coins: 1000, xp: 2000, gems: 100 }, target: 1, type: 'special' }
        ];
        
        // Fun√ß√µes de Menu
        function openProgressionMenu() {
            document.getElementById('progressionMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateProgressionDisplay();
            renderSkillTree();
            renderDailyChallenges();
            menuAnimationRunning = false;
        }
        
        function closeProgressionMenu() {
            document.getElementById('progressionMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        function openAchievementsMenu() {
            document.getElementById('achievementsMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateAchievementsDisplay();
            renderAchievements();
            menuAnimationRunning = false;
        }
        
        function closeAchievementsMenu() {
            document.getElementById('achievementsMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        function openBattlepassMenu() {
            document.getElementById('battlepassMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateBattlepassDisplay();
            renderBattlepassTiers();
            menuAnimationRunning = false;
        }
        
        function closeBattlepassMenu() {
            document.getElementById('battlepassMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        function updateBattlepassDisplay() {
            // Atualizar n√≠vel
            document.getElementById('battlepassLevelDisplay').textContent = battlePassLevel;
            
            // Atualizar status premium
            const statusElement = document.getElementById('battlepassStatus');
            if (battlePassPremium) {
                statusElement.textContent = 'PREMIUM';
                statusElement.style.color = '#FFD700';
            } else {
                statusElement.textContent = 'GR√ÅTIS';
                statusElement.style.color = '#FFFFFF';
            }
            
            // Atualizar barra de XP
            const currentTier = battlePassTiers.find(tier => tier.level === battlePassLevel);
            const nextTier = battlePassTiers.find(tier => tier.level === battlePassLevel + 1);
            
            if (currentTier && nextTier) {
                const xpProgress = (battlePassXP / currentTier.xpRequired) * 100;
                document.getElementById('battlepassXpFill').style.width = Math.min(xpProgress, 100) + '%';
                document.getElementById('battlepassXpText').textContent = `${battlePassXP} / ${currentTier.xpRequired}`;
            } else if (battlePassLevel >= 50) {
                document.getElementById('battlepassXpFill').style.width = '100%';
                document.getElementById('battlepassXpText').textContent = 'M√ÅXIMO';
            }
        }
        
        function renderBattlepassTiers() {
            const tiersContainer = document.getElementById('battlepassTiers');
            tiersContainer.innerHTML = '';
            
            battlePassTiers.forEach((tier, index) => {
                const tierElement = document.createElement('div');
                tierElement.className = 'battlepass-tier';
                tierElement.innerHTML = `
                    <div class="tier-level">${tier.level}</div>
                    <div class="tier-rewards">
                        <div class="reward-track free-track">
                            <div class="reward-header">GR√ÅTIS</div>
                            <div class="reward-item ${battlePassLevel >= tier.level ? 'available' : 'locked'}">
                                ${formatReward(tier.freeReward)}
                                <button 
                                    class="claim-button ${battlePassClaimedRewards.includes(`${tier.level}-free`) ? 'claimed' : ''}"
                                    onclick="claimBattlePassReward(${tier.level}, false)"
                                    ${battlePassLevel < tier.level || battlePassClaimedRewards.includes(`${tier.level}-free`) ? 'disabled' : ''}
                                >
                                    ${battlePassClaimedRewards.includes(`${tier.level}-free`) ? '‚úì' : 'Coletar'}
                                </button>
                            </div>
                        </div>
                        <div class="reward-track premium-track ${battlePassPremium ? 'unlocked' : 'locked'}">
                            <div class="reward-header">PREMIUM</div>
                            <div class="reward-item ${battlePassLevel >= tier.level ? 'available' : 'locked'}">
                                ${formatReward(tier.premiumReward)}
                                <button 
                                    class="claim-button premium ${battlePassClaimedRewards.includes(`${tier.level}-premium`) ? 'claimed' : ''}"
                                    onclick="claimBattlePassReward(${tier.level}, true)"
                                    ${battlePassLevel < tier.level || battlePassClaimedRewards.includes(`${tier.level}-premium`) || !battlePassPremium ? 'disabled' : ''}
                                >
                                    ${battlePassClaimedRewards.includes(`${tier.level}-premium`) ? '‚úì' : 'Coletar'}
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Highlight current level
                if (tier.level === battlePassLevel) {
                    tierElement.classList.add('current-tier');
                }
                
                tiersContainer.appendChild(tierElement);
            });
            
            // Add premium upgrade button if not premium
            if (!battlePassPremium) {
                const upgradeButton = document.createElement('div');
                upgradeButton.className = 'premium-upgrade';
                upgradeButton.innerHTML = `
                    <button class="upgrade-premium-button" onclick="buyBattlePassPremium()">
                        üåü UPGRADE PARA PREMIUM - 500 üíé
                    </button>
                `;
                tiersContainer.appendChild(upgradeButton);
            }
        }
        
        function formatReward(reward) {
            let rewardText = [];
            
            if (reward.coins) rewardText.push(`üí∞ ${reward.coins}`);
            if (reward.gems) rewardText.push(`üíé ${reward.gems}`);
            if (reward.darkMatter) rewardText.push(`üåå ${reward.darkMatter}`);
            if (reward.xp) rewardText.push(`‚≠ê ${reward.xp} XP`);
            if (reward.ship) rewardText.push(`üöÄ ${shipModels[reward.ship]?.name || reward.ship}`);
            if (reward.skin) rewardText.push(`üé® ${shipSkins[reward.skin]?.name || reward.skin}`);
            if (reward.effect) rewardText.push(`‚ú® ${visualEffects[reward.effect]?.name || reward.effect}`);
            if (reward.exclusiveShip) rewardText.push(`üåü ${battlePassExclusives[reward.exclusiveShip]?.name || reward.exclusiveShip}`);
            if (reward.exclusiveSkin) rewardText.push(`üåü ${battlePassExclusives[reward.exclusiveSkin]?.name || reward.exclusiveSkin}`);
            if (reward.specialTitle) rewardText.push(`üëë ${reward.specialTitle}`);
            if (reward.exclusiveTitle) rewardText.push(`üèÜ ${reward.exclusiveTitle}`);
            
            return rewardText.join('<br>');
        }
        
        function upgradeBattlepass() {
            buyBattlePassPremium();
        }
        
        // Ship Customization Menu Functions
        function openShipCustomizationMenu() {
            document.getElementById('shipCustomizationMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateShipCustomizationDisplay();
            renderShipModels();
            menuAnimationRunning = false;
        }
        
        function closeShipCustomizationMenu() {
            document.getElementById('shipCustomizationMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        function switchShipTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.ship-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.ship-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab and mark as active
            document.getElementById(tabName + 'Tab').style.display = 'block';
            event.target.classList.add('active');
            
            // Render content based on tab
            switch(tabName) {
                case 'models':
                    renderShipModels();
                    break;
                case 'upgrades':
                    renderShipUpgrades();
                    break;
                case 'skins':
                    renderShipSkins();
                    break;
                case 'effects':
                    renderVisualEffects();
                    break;
            }
        }
        
        function updateShipCustomizationDisplay() {
            const currentShip = shipModels[currentShipId];
            document.getElementById('currentShipName').textContent = currentShip.name;
            document.getElementById('shipsUnlocked').textContent = unlockedShips.length;
            document.getElementById('skinsUnlocked').textContent = unlockedSkins.length;
        }
        
        function renderShipModels() {
            const container = document.getElementById('shipsGrid');
            container.innerHTML = '';
            
            Object.values(shipModels).forEach(ship => {
                const shipCard = document.createElement('div');
                shipCard.className = `ship-card ${ship.rarity}`;
                if (ship.id === currentShipId) shipCard.classList.add('equipped');
                
                const isUnlocked = unlockedShips.includes(ship.id);
                const canAfford = coins >= ship.price;
                
                shipCard.innerHTML = `
                    <div class="ship-preview">
                        <div class="ship-model">${ship.sprite}</div>
                    </div>
                    <div class="ship-name">${ship.name}</div>
                    <div class="ship-description">${ship.description}</div>
                    <div class="ship-stats">
                        <div class="ship-stat">
                            <span>Velocidade:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.speed / 10) * 100}%"></div>
                            </div>
                        </div>
                        <div class="ship-stat">
                            <span>Vida:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.health / 500) * 100}%"></div>
                            </div>
                        </div>
                        <div class="ship-stat">
                            <span>Dano:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.damage / 100) * 100}%"></div>
                            </div>
                        </div>
                        <div class="ship-stat">
                            <span>Escudo:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.shield / 200) * 100}%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="ship-abilities">
                        ${ship.abilities.map(ability => `<div class="ship-ability">${ability}</div>`).join('')}
                    </div>
                    <div class="ship-actions">
                        ${ship.id === currentShipId ? 
                            '<button class="ship-action equipped">‚úì Equipada</button>' :
                            isUnlocked ? 
                                '<button class="ship-action equip" onclick="equipShip(\'' + ship.id + '\')">üöÄ Equipar</button>' :
                                '<button class="ship-action unlock" onclick="unlockShip(\'' + ship.id + '\')" ' + 
                                (!canAfford ? 'disabled' : '') + '>üí∞ ' + ship.price + ' Moedas</button>'
                        }
                    </div>
                `;
                
                container.appendChild(shipCard);
            });
        }
        
        function renderShipUpgrades() {
            const container = document.getElementById('upgradeCategories');
            container.innerHTML = '';
            
            Object.entries(upgradeCategories).forEach(([categoryId, category]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'upgrade-category';
                
                categoryDiv.innerHTML = `
                    <h4>${category.icon} ${category.name}</h4>
                    ${Object.entries(category.upgrades).map(([upgradeId, upgrade]) => `
                        <div class="upgrade-option ${getUpgradeEquipped(categoryId) === upgradeId ? 'equipped' : ''}" 
                             onclick="equipUpgrade('${categoryId}', '${upgradeId}')">
                            <span>${upgrade.name}</span>
                            <span class="upgrade-cost">${upgrade.cost > 0 ? upgrade.cost + ' üí∞' : 'Gr√°tis'}</span>
                        </div>
                    `).join('')}
                `;
                
                container.appendChild(categoryDiv);
            });
        }
        
        function renderShipSkins() {
            const container = document.getElementById('skinsGrid');
            container.innerHTML = '';
            
            Object.values(shipSkins).forEach(skin => {
                const skinCard = document.createElement('div');
                skinCard.className = `skin-card ${skin.rarity}`;
                if (skin.id === currentSkinId) skinCard.classList.add('equipped');
                if (skin.animated) skinCard.classList.add('animated');
                if (skin.holographic) skinCard.classList.add('holographic');
                
                const isUnlocked = unlockedSkins.includes(skin.id);
                const canAfford = coins >= skin.price;
                
                skinCard.innerHTML = `
                    <div class="skin-preview" style="background: linear-gradient(45deg, ${skin.colors.join(', ')});">
                        ${shipModels[currentShipId].sprite}
                    </div>
                    <div class="skin-name">${skin.name}</div>
                    <div class="skin-rarity">${skin.description}</div>
                    <div class="ship-actions">
                        ${skin.id === currentSkinId ? 
                            '<button class="ship-action equipped">‚úì Equipada</button>' :
                            isUnlocked ? 
                                '<button class="ship-action equip" onclick="equipSkin(\'' + skin.id + '\')">üé® Equipar</button>' :
                                '<button class="ship-action unlock" onclick="unlockSkin(\'' + skin.id + '\')" ' + 
                                (!canAfford ? 'disabled' : '') + '>üí∞ ' + skin.price + ' Moedas</button>'
                        }
                    </div>
                `;
                
                skinCard.onclick = () => {
                    if (isUnlocked && skin.id !== currentSkinId) {
                        equipSkin(skin.id);
                    } else if (!isUnlocked && canAfford) {
                        unlockSkin(skin.id);
                    }
                };
                
                container.appendChild(skinCard);
            });
        }
        
        function renderVisualEffects() {
            const container = document.getElementById('effectsGrid');
            container.innerHTML = '';
            
            Object.values(visualEffects).forEach(effect => {
                const effectCard = document.createElement('div');
                effectCard.className = `skin-card ${effect.rarity}`;
                if (effect.id === currentEffectId) effectCard.classList.add('equipped');
                
                const isUnlocked = unlockedEffects.includes(effect.id);
                const canAfford = coins >= effect.price;
                
                effectCard.innerHTML = `
                    <div class="skin-preview">
                        ‚ú®
                    </div>
                    <div class="skin-name">${effect.name}</div>
                    <div class="skin-rarity">${effect.description}</div>
                    <div class="ship-actions">
                        ${effect.id === currentEffectId ? 
                            '<button class="ship-action equipped">‚úì Equipado</button>' :
                            isUnlocked ? 
                                '<button class="ship-action equip" onclick="equipEffect(\'' + effect.id + '\')">‚ú® Equipar</button>' :
                                '<button class="ship-action unlock" onclick="unlockEffect(\'' + effect.id + '\')" ' + 
                                (!canAfford ? 'disabled' : '') + '>üí∞ ' + effect.price + ' Moedas</button>'
                        }
                    </div>
                `;
                
                container.appendChild(effectCard);
            });
        }
        
        // Ship Management Functions
        function equipShip(shipId) {
            if (!unlockedShips.includes(shipId)) return;
            
            currentShipId = shipId;
            localStorage.setItem('waveslayers_current_ship', currentShipId);
            
            // Update player stats
            if (player) {
                updatePlayerFromShip();
            }
            
            showNotification(`üõ∏ Nave ${shipModels[shipId].name} equipada!`, '#00ffff');
            updateShipCustomizationDisplay();
            renderShipModels();
        }
        
        function unlockShip(shipId) {
            const ship = shipModels[shipId];
            if (!ship || coins < ship.price || unlockedShips.includes(shipId)) return;
            
            coins -= ship.price;
            unlockedShips.push(shipId);
            
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_unlocked_ships', JSON.stringify(unlockedShips));
            
            showNotification(`üõ∏ Nave ${ship.name} desbloqueada!`, '#00ff00');
            updateShipCustomizationDisplay();
            renderShipModels();
            updateCoinsDisplay();
        }
        
        function equipSkin(skinId) {
            if (!unlockedSkins.includes(skinId)) return;
            
            currentSkinId = skinId;
            localStorage.setItem('waveslayers_current_skin', currentSkinId);
            
            showNotification(`üé® Skin ${shipSkins[skinId].name} equipada!`, '#ff6600');
            renderShipSkins();
        }
        
        function unlockSkin(skinId) {
            const skin = shipSkins[skinId];
            if (!skin || coins < skin.price || unlockedSkins.includes(skinId)) return;
            
            coins -= skin.price;
            unlockedSkins.push(skinId);
            
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_unlocked_skins', JSON.stringify(unlockedSkins));
            
            showNotification(`üé® Skin ${skin.name} desbloqueada!`, '#ff6600');
            renderShipSkins();
            updateCoinsDisplay();
        }
        
        function equipEffect(effectId) {
            if (!unlockedEffects.includes(effectId)) return;
            
            currentEffectId = effectId;
            localStorage.setItem('waveslayers_current_effect', currentEffectId);
            
            showNotification(`‚ú® Efeito ${visualEffects[effectId].name} equipado!`, '#9932cc');
            renderVisualEffects();
        }
        
        function unlockEffect(effectId) {
            const effect = visualEffects[effectId];
            if (!effect || coins < effect.price || unlockedEffects.includes(effectId)) return;
            
            coins -= effect.price;
            unlockedEffects.push(effectId);
            
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_unlocked_effects', JSON.stringify(unlockedEffects));
            
            showNotification(`‚ú® Efeito ${effect.name} desbloqueado!`, '#9932cc');
            renderVisualEffects();
            updateCoinsDisplay();
        }
        
        function getUpgradeEquipped(categoryId) {
            if (!shipUpgrades[currentShipId]) {
                shipUpgrades[currentShipId] = {};
            }
            
            const shipUpgrade = shipUpgrades[currentShipId][categoryId];
            return shipUpgrade || Object.keys(upgradeCategories[categoryId].upgrades)[0];
        }
        
        function equipUpgrade(categoryId, upgradeId) {
            const upgrade = upgradeCategories[categoryId].upgrades[upgradeId];
            if (!upgrade || coins < upgrade.cost) return;
            
            // Check if already equipped
            if (getUpgradeEquipped(categoryId) === upgradeId) return;
            
            // Deduct cost
            if (upgrade.cost > 0) {
                coins -= upgrade.cost;
                localStorage.setItem('waveslayers_coins', coins.toString());
                updateCoinsDisplay();
            }
            
            // Equip upgrade
            if (!shipUpgrades[currentShipId]) {
                shipUpgrades[currentShipId] = {};
            }
            shipUpgrades[currentShipId][categoryId] = upgradeId;
            
            localStorage.setItem('waveslayers_ship_upgrades', JSON.stringify(shipUpgrades));
            
            showNotification(`‚öôÔ∏è ${upgrade.name} equipado!`, '#ffaa00');
            renderShipUpgrades();
            
            // Update player stats
            if (player) {
                updatePlayerFromShip();
            }
        }
        
        function updatePlayerFromShip() {
            const ship = shipModels[currentShipId];
            if (!ship || !player) return;
            
            // Base stats from ship
            player.baseSpeed = ship.stats.speed;
            player.baseDamage = ship.stats.damage;
            player.baseFireRate = ship.stats.fireRate;
            playerMaxHealth = ship.stats.health;
            
            // Apply upgrades
            if (shipUpgrades[currentShipId]) {
                const upgrades = shipUpgrades[currentShipId];
                
                // Engine upgrade
                if (upgrades.engine) {
                    const engineUpgrade = upgradeCategories.engine.upgrades[upgrades.engine];
                    if (engineUpgrade) {
                        player.baseSpeed += engineUpgrade.speedBonus || 0;
                    }
                }
                
                // Weapon upgrade
                if (upgrades.weapons) {
                    const weaponUpgrade = upgradeCategories.weapons.upgrades[upgrades.weapons];
                    if (weaponUpgrade) {
                        player.baseDamage += weaponUpgrade.damageBonus || 0;
                    }
                }
                
                // Hull upgrade
                if (upgrades.hull) {
                    const hullUpgrade = upgradeCategories.hull.upgrades[upgrades.hull];
                    if (hullUpgrade) {
                        playerMaxHealth += hullUpgrade.healthBonus || 0;
                    }
                }
            }
            
            // Maintain health ratio
            const healthRatio = playerHealth / playerMaxHealth;
            playerHealth = Math.floor(playerMaxHealth * healthRatio);
            
            updateHealthBar();
        }
        
        // Fun√ß√µes de Progress√£o
        function updateProgressionDisplay() {
            document.getElementById('playerLevelDisplay').textContent = playerLevel;
            document.getElementById('skillPointsDisplay').textContent = skillPoints;
            document.getElementById('gemsDisplay').textContent = gems;
            document.getElementById('darkMatterDisplay').textContent = darkMatter;
            
            // Atualizar barra de XP
            const xpForCurrentLevel = getXPRequiredForLevel(playerLevel);
            const xpForNextLevel = getXPRequiredForLevel(playerLevel + 1);
            const xpProgress = playerXP - xpForCurrentLevel;
            const xpNeeded = xpForNextLevel - xpForCurrentLevel;
            const xpPercentage = (xpProgress / xpNeeded) * 100;
            
            document.getElementById('xpFill').style.width = xpPercentage + '%';
            document.getElementById('xpText').textContent = `${xpProgress} / ${xpNeeded}`;
        }
        
        function getXPRequiredForLevel(level) {
            return Math.floor(100 * Math.pow(1.5, level - 1));
        }
        
        function addXP(amount) {
            playerXP += amount;
            
            // Check for level up
            while (playerXP >= getXPRequiredForLevel(playerLevel + 1)) {
                levelUp();
            }
            
            // Add battle pass XP
            battlePassXP += Math.floor(amount * 0.8);
            
            saveProgressionData();
        }
        
        function levelUp() {
            playerLevel++;
            skillPoints += 2; // 2 skill points per level
            
            // Show level up notification
            showNotification(`üéâ LEVEL UP! N√≠vel ${playerLevel}`, '#ffff00');
            
            saveProgressionData();
        }
        
        function renderSkillTree() {
            const container = document.getElementById('skillTreeContainer');
            container.innerHTML = '';
            
            Object.entries(skillBranches).forEach(([branchId, branch]) => {
                const branchDiv = document.createElement('div');
                branchDiv.className = 'skill-branch';
                
                const hasUnlockedSkill = branch.skills.some(skill => skillTree[skill.id]);
                if (hasUnlockedSkill) {
                    branchDiv.classList.add('unlocked');
                }
                
                branchDiv.innerHTML = `
                    <h3>${branch.icon} ${branch.name}</h3>
                `;
                
                branch.skills.forEach(skill => {
                    const skillNode = document.createElement('div');
                    skillNode.className = 'skill-node';
                    
                    const isUnlocked = skillTree[skill.id] || false;
                    const canUnlock = canUnlockSkill(skill);
                    
                    if (isUnlocked) {
                        skillNode.classList.add('unlocked');
                        skillNode.innerHTML = '‚úì';
                    } else if (canUnlock && skillPoints >= skill.cost) {
                        skillNode.classList.add('available');
                        skillNode.innerHTML = skill.cost;
                        skillNode.onclick = () => unlockSkill(skill.id);
                    } else {
                        skillNode.innerHTML = skill.cost;
                    }
                    
                    skillNode.title = `${skill.name}\n${skill.description}\nCusto: ${skill.cost} pontos`;
                    
                    const costDiv = document.createElement('div');
                    costDiv.className = 'skill-cost';
                    costDiv.textContent = skill.cost;
                    skillNode.appendChild(costDiv);
                    
                    branchDiv.appendChild(skillNode);
                });
                
                container.appendChild(branchDiv);
            });
        }
        
        function canUnlockSkill(skill) {
            if (!skill.requires) return true;
            
            return skill.requires.every(requiredSkill => skillTree[requiredSkill]);
        }
        
        function unlockSkill(skillId) {
            const skill = findSkillById(skillId);
            if (!skill || skillPoints < skill.cost || !canUnlockSkill(skill)) return;
            
            skillPoints -= skill.cost;
            skillTree[skillId] = true;
            
            showNotification(`üåü Habilidade desbloqueada: ${skill.name}`, '#00ff00');
            
            saveProgressionData();
            updateProgressionDisplay();
            renderSkillTree();
        }
        
        function findSkillById(skillId) {
            for (const branch of Object.values(skillBranches)) {
                const skill = branch.skills.find(s => s.id === skillId);
                if (skill) return skill;
            }
            return null;
        }
        
        function renderDailyChallenges() {
            checkDailyReset();
            
            const container = document.getElementById('dailyChallengesContainer');
            container.innerHTML = '';
            
            if (Object.keys(dailyChallenges).length === 0) {
                resetDailyChallenges();
            }
            
            Object.values(dailyChallenges).forEach(challenge => {
                const challengeDiv = document.createElement('div');
                challengeDiv.className = 'challenge-card';
                
                if (challenge.completed) {
                    challengeDiv.classList.add('completed');
                }
                
                const progress = Math.min(challenge.progress, challenge.target);
                const progressPercent = (progress / challenge.target) * 100;
                
                challengeDiv.innerHTML = `
                    <div class="challenge-title">${challenge.description}</div>
                    <div class="challenge-description">Progresso: ${progress}/${challenge.target}</div>
                    <div class="challenge-progress">
                        <div class="challenge-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="challenge-reward">
                        Recompensa: ${formatReward(challenge.reward)}
                    </div>
                `;
                
                container.appendChild(challengeDiv);
            });
        }
        
        function checkDailyReset() {
            const today = new Date().toDateString();
            if (lastDailyReset !== today) {
                resetDailyChallenges();
                lastDailyReset = today;
                localStorage.setItem('waveslayers_last_daily_reset', lastDailyReset);
            }
        }
        
        function resetDailyChallenges() {
            const challengeTemplates = [
                { type: 'kills', targets: [10, 25, 50], rewards: [{ coins: 100, xp: 200 }, { coins: 250, xp: 500 }, { coins: 500, xp: 1000 }], descriptions: ['Destrua {target} inimigos', 'Destrua {target} inimigos', 'Destrua {target} inimigos'] },
                { type: 'score', targets: [2000, 5000, 15000], rewards: [{ coins: 150, xp: 300 }, { coins: 400, xp: 800 }, { coins: 800, xp: 1600 }], descriptions: ['Atinja {target} pontos', 'Atinja {target} pontos', 'Atinja {target} pontos'] },
                { type: 'survival', targets: [60, 180, 420], rewards: [{ coins: 200, xp: 400 }, { coins: 500, xp: 1000 }, { coins: 1000, xp: 2000 }], descriptions: ['Sobreviva {target} segundos', 'Sobreviva {target} segundos', 'Sobreviva {target} segundos'] },
                { type: 'coins', targets: [50, 150, 300], rewards: [{ coins: 75, xp: 150, gems: 5 }, { coins: 200, xp: 400, gems: 15 }, { coins: 400, xp: 800, gems: 30 }], descriptions: ['Colete {target} moedas', 'Colete {target} moedas', 'Colete {target} moedas'] },
                { type: 'powerups', targets: [5, 15, 30], rewards: [{ coins: 100, xp: 200, gems: 5 }, { coins: 300, xp: 600, gems: 20 }, { coins: 600, xp: 1200, gems: 40 }], descriptions: ['Colete {target} power-ups', 'Colete {target} power-ups', 'Colete {target} power-ups'] }
            ];
            
            dailyChallenges = {};
            const selectedTypes = [];
            let challengeCount = 0;
            
            // Gerar 3 desafios √∫nicos
            while (challengeCount < 3 && selectedTypes.length < challengeTemplates.length) {
                const template = challengeTemplates[Math.floor(Math.random() * challengeTemplates.length)];
                if (!selectedTypes.includes(template.type)) {
                    const difficulty = Math.floor(Math.random() * 3); // 0=f√°cil, 1=m√©dio, 2=dif√≠cil
                    const challengeId = `daily_${template.type}_${Date.now()}_${challengeCount}`;
                    
                    dailyChallenges[challengeId] = {
                        id: challengeId,
                        type: template.type,
                        target: template.targets[difficulty],
                        reward: template.rewards[difficulty],
                        description: template.descriptions[difficulty].replace('{target}', template.targets[difficulty]),
                        progress: 0,
                        completed: false,
                        difficulty: difficulty
                    };
                    
                    selectedTypes.push(template.type);
                    challengeCount++;
                }
            }
            
            saveProgressionData();
        }
        
        function updateAchievementsDisplay() {
            const unlockedCount = Object.keys(achievements).length;
            const totalCount = achievementsList.length;
            const achievementPoints = Object.values(achievements).reduce((total, ach) => total + (ach.points || 0), 0);
            
            document.getElementById('achievementsUnlocked').textContent = unlockedCount;
            document.getElementById('achievementsTotal').textContent = totalCount;
            document.getElementById('achievementPoints').textContent = achievementPoints;
        }
        
        function renderAchievements() {
            const container = document.getElementById('achievementsGrid');
            container.innerHTML = '';
            
            achievementsList.forEach(achievement => {
                const achievementDiv = document.createElement('div');
                achievementDiv.className = 'achievement-card';
                
                const isUnlocked = achievements[achievement.id];
                const progress = achievementProgress[achievement.id] || 0;
                const progressPercent = Math.min((progress / achievement.target) * 100, 100);
                
                if (isUnlocked) {
                    achievementDiv.classList.add('unlocked');
                } else if (progress === 0) {
                    achievementDiv.classList.add('hidden');
                }
                
                achievementDiv.innerHTML = `
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-name">${achievement.name}</div>
                    <div class="achievement-description">${achievement.description}</div>
                    <div class="achievement-progress">
                        <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div style="text-align: center; margin: 10px 0; color: #ccc; font-size: 0.9em;">
                        ${progress}/${achievement.target}
                    </div>
                    <div class="achievement-reward">
                        ${isUnlocked ? '‚úì DESBLOQUEADO' : `Recompensa: ${formatReward(achievement.reward)}`}
                    </div>
                `;
                
                container.appendChild(achievementDiv);
            });
        }
        
        function updateBattlepassDisplay() {
            document.getElementById('battlepassLevelDisplay').textContent = battlePassLevel;
            document.getElementById('battlepassStatus').textContent = battlePassPremium ? 'PREMIUM' : 'GR√ÅTIS';
            
            if (battlePassLevel < 50) {
                const currentTier = battlePassTiers[battlePassLevel];
                const xpProgress = battlePassXP - (battlePassLevel * 1000);
                const xpNeeded = currentTier.xpRequired;
                const xpPercentage = (xpProgress / xpNeeded) * 100;
                
                document.getElementById('battlepassXpFill').style.width = xpPercentage + '%';
                document.getElementById('battlepassXpText').textContent = `${xpProgress} / ${xpNeeded}`;
            } else {
                document.getElementById('battlepassXpFill').style.width = '100%';
                document.getElementById('battlepassXpText').textContent = 'MAX LEVEL';
            }
        }
        
        function renderBattlepassTiers() {
            const container = document.getElementById('battlepassTiers');
            container.innerHTML = '';
            
            battlePassTiers.forEach((tier, index) => {
                const tierDiv = document.createElement('div');
                tierDiv.className = 'battlepass-tier';
                
                if (battlePassLevel > index) {
                    tierDiv.classList.add('unlocked');
                } else if (battlePassLevel === index) {
                    tierDiv.classList.add('current');
                }
                
                tierDiv.innerHTML = `
                    <div class="tier-info">
                        <div class="tier-level">${tier.level}</div>
                        <div class="tier-rewards">
                            <div class="reward-item free">
                                <div>GR√ÅTIS</div>
                                <div>${formatReward(tier.freeReward)}</div>
                            </div>
                            <div class="reward-item premium">
                                <div>PREMIUM</div>
                                <div>${formatReward(tier.premiumReward)}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                container.appendChild(tierDiv);
            });
        }
        
        function upgradeBattlepass() {
            if (!battlePassPremium && gems >= 500) {
                gems -= 500;
                battlePassPremium = true;
                showNotification('üéØ Battle Pass Premium ativado!', '#ffaa00');
                saveProgressionData();
                updateBattlepassDisplay();
            } else if (!battlePassPremium) {
                showNotification('Voc√™ precisa de 500 gemas para o Battle Pass Premium', '#ff4444');
            }
        }
        
        function formatReward(reward) {
            const parts = [];
            if (reward.coins) parts.push(`${reward.coins}üí∞`);
            if (reward.xp) parts.push(`${reward.xp}‚ú®`);
            if (reward.gems) parts.push(`${reward.gems}üíé`);
            if (reward.darkMatter) parts.push(`${reward.darkMatter}üåå`);
            return parts.join(' ');
        }
        
        function saveProgressionData() {
            localStorage.setItem('waveslayers_player_level', playerLevel.toString());
            localStorage.setItem('waveslayers_player_xp', playerXP.toString());
            localStorage.setItem('waveslayers_skill_points', skillPoints.toString());
            localStorage.setItem('waveslayers_gems', gems.toString());
            localStorage.setItem('waveslayers_dark_matter', darkMatter.toString());
            localStorage.setItem('waveslayers_skills', JSON.stringify(skillTree));
            localStorage.setItem('waveslayers_achievements', JSON.stringify(achievements));
            localStorage.setItem('waveslayers_achievement_progress', JSON.stringify(achievementProgress));
            localStorage.setItem('waveslayers_daily_challenges', JSON.stringify(dailyChallenges));
            localStorage.setItem('waveslayers_battlepass_level', battlePassLevel.toString());
            localStorage.setItem('waveslayers_battlepass_xp', battlePassXP.toString());
            localStorage.setItem('waveslayers_battlepass_premium', battlePassPremium.toString());
        }
        
        function checkAchievements() {
            achievementsList.forEach(achievement => {
                if (achievements[achievement.id]) return; // Already unlocked
                
                let currentProgress = 0;
                
                switch (achievement.type) {
                    case 'kills':
                        currentProgress = achievementProgress.totalKills || 0;
                        break;
                    case 'score':
                        currentProgress = achievementProgress.highScore || 0;
                        break;
                    case 'survival':
                        currentProgress = achievementProgress.longestSurvival || 0;
                        break;
                    case 'coins_collected':
                        currentProgress = achievementProgress.totalCoinsCollected || 0;
                        break;
                    case 'worlds_unlocked':
                        currentProgress = achievementProgress.worldsUnlocked || 0;
                        break;
                    case 'powerups_collected':
                        currentProgress = achievementProgress.powerupsCollected || 0;
                        break;
                }
                
                achievementProgress[achievement.id] = currentProgress;
                
                if (currentProgress >= achievement.target) {
                    unlockAchievement(achievement);
                }
            });
        }
        
        function unlockAchievement(achievement) {
            achievements[achievement.id] = {
                unlockedAt: Date.now(),
                points: 10 + (achievement.target > 1000 ? 20 : 0)
            };
            
            // Give rewards
            if (achievement.reward.coins) {
                coins += achievement.reward.coins;
            }
            if (achievement.reward.xp) {
                addXP(achievement.reward.xp);
            }
            if (achievement.reward.gems) {
                gems += achievement.reward.gems;
            }
            if (achievement.reward.darkMatter) {
                darkMatter += achievement.reward.darkMatter;
            }
            
            showNotification(`üèÜ Conquista desbloqueada: ${achievement.name}`, '#ffaa00');
            
            saveProgressionData();
        }
        
        function updateChallenges(type, amount = 1) {
            Object.values(dailyChallenges).forEach(challenge => {
                if (challenge.type === type && !challenge.completed) {
                    challenge.progress += amount;
                    
                    if (challenge.progress >= challenge.target) {
                        challenge.completed = true;
                        
                        // Give rewards
                        if (challenge.reward.coins) {
                            coins += challenge.reward.coins;
                        }
                        if (challenge.reward.xp) {
                            addXP(challenge.reward.xp);
                        }
                        if (challenge.reward.gems) {
                            gems += challenge.reward.gems;
                        }
                        
                        showNotification(`‚úÖ Desafio Conclu√≠do: ${challenge.description}`, '#00ff00');
                    }
                }
            });
            
            saveProgressionData();
        }
        
        function showNotification(message, color = '#ffffff') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                color: ${color};
                padding: 15px 25px;
                border-radius: 10px;
                border: 2px solid ${color};
                font-family: 'Orbitron', monospace;
                font-weight: bold;
                z-index: 1000;
                transform: translateX(400px);
                transition: transform 0.5s ease;
                box-shadow: 0 0 20px ${color}50;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Animate out and remove
            setTimeout(() => {
                notification.style.transform = 'translateX(400px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }
        
        // Initialize game
        function init() {
            player = new Player();
            
            // Load saved game data
            loadGameData();
            
            // Create stars
            for (let i = 0; i < 120; i++) {
                stars.push(new Star());
            }
            
            // Initialize menu animation
            initMenuAnimation();
            
            // Event listeners
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if ((e.key === 'p' || e.key === 'P') && gameState === 'playing') {
                    isPaused = !isPaused;
                }
                e.preventDefault();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            updateCoinsDisplay();
            
            // Initialize progression system
            checkDailyReset();
            
            // Initialize ship customization system
            // Ensure current ship is unlocked
            if (!unlockedShips.includes(currentShipId)) {
                currentShipId = 'interceptor';
                localStorage.setItem('waveslayers_current_ship', currentShipId);
            }
            
            // Ensure current skin is unlocked
            if (!unlockedSkins.includes(currentSkinId)) {
                currentSkinId = 'default';
                localStorage.setItem('waveslayers_current_skin', currentSkinId);
            }
            
            // Ensure current effect is unlocked
            if (!unlockedEffects.includes(currentEffectId)) {
                currentEffectId = 'none';
                localStorage.setItem('waveslayers_current_effect', currentEffectId);
            }
            
            // Load achievement progress if not exists
            if (!achievementProgress.totalKills) {
                achievementProgress = {
                    totalKills: 0,
                    highScore: 0,
                    longestSurvival: 0,
                    totalCoinsCollected: 0,
                    worldsUnlocked: 1,
                    powerupsCollected: 0
                };
            }
        }
        
        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            // Update and draw stars
            stars.forEach(star => {
                star.update();
                star.draw();
            });
            
            if (gameState === 'playing' && gameRunning && !isPaused) {
                // Update player
                player.update(deltaTime);
                
                // Spawn enemies
                enemySpawnTimer += deltaTime;
                const world = worlds[currentWorldId];
                const spawnRate = Math.max(300, 1500 - level * 80) / world.difficulty;
                if (enemySpawnTimer > spawnRate) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }
                
                // Update bullets
                bullets = bullets.filter(bullet => {
                    bullet.update();
                    bullet.draw();
                    return !bullet.isOffScreen();
                });
                
                enemyBullets = enemyBullets.filter(bullet => {
                    bullet.update();
                    bullet.draw();
                    return !bullet.isOffScreen();
                });
                
                // Update enemies
                enemies = enemies.filter(enemy => {
                    enemy.update(deltaTime);
                    enemy.draw();
                    return !enemy.isOffScreen();
                });
                
                // Update particles
                particles = particles.filter(particle => {
                    particle.update(deltaTime);
                    particle.draw();
                    return !particle.isDead();
                });
                
                // Update powerups
                powerups = powerups.filter(powerup => {
                    powerup.update();
                    powerup.draw();
                    return !powerup.isOffScreen();
                });
                
                // Check collisions
                checkCollisions();
                
                // Draw player
                player.draw();
                
                // Update level
                const newLevel = Math.floor(score / 750) + 1;
                if (newLevel > level) {
                    level = newLevel;
                }
                
                // Update UI
                updateUI();
            } else if (gameState === 'playing' && isPaused) {
                // Draw game elements but don't update
                bullets.forEach(bullet => bullet.draw());
                enemyBullets.forEach(bullet => bullet.draw());
                enemies.forEach(enemy => enemy.draw());
                particles.forEach(particle => particle.draw());
                powerups.forEach(powerup => powerup.draw());
                player.draw();
                
                // Draw pause overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ffff';
                ctx.font = '48px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSADO', canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Orbitron';
                ctx.fillText('Pressione P para continuar', canvas.width / 2, canvas.height / 2 + 50);
                ctx.textAlign = 'start';
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start game
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>