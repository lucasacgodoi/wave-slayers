<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveSlayers - Space Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0033 50%, #000d1a 100%);
            color: #fff;
            font-family: 'Orbitron', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 15px;
            background: linear-gradient(180deg, #000428 0%, #004e92 100%);
            box-shadow: 0 0 30px #00ffff;
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border-radius: 12px;
        }
        
        /* Menu Principal */
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 12px;
        }
        
        #menuBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 30, 0.3);
            z-index: 1;
            border-radius: 12px;
        }
        
        .menu-content {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .menu-buttons-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px 20px;
            margin-top: 20px;
            max-width: 700px;
            width: 100%;
        }
        
        #mainMenu h1 {
            font-size: 3.5em;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 10px #00ffff); }
            to { filter: drop-shadow(0 0 30px #ff00ff); }
        }
        
        .menu-button {
            background: linear-gradient(45deg, #00ffff, #0099cc);
            border: none;
            padding: 12px 20px;
            margin: 0;
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 700;
            color: #000;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 4px 12px rgba(0,255,255,0.3);
            min-width: 180px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,255,255,0.5);
            background: linear-gradient(45deg, #ff00ff, #cc0099);
        }
        
        /* Menu de Mundos */
        #worldsMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,20,40,0.95) 0%, rgba(40,0,60,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Menu de Progress√£o */
        #progressionMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(20,0,40,0.95) 0%, rgba(60,0,40,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Menu de Conquistas */
        #achievementsMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(40,20,0,0.95) 0%, rgba(80,40,0,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Menu Battle Pass */
        #battlepassMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,40,20,0.95) 0%, rgba(0,80,40,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        /* Menu Arsenal */
        #arsenalMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(40,0,20,0.95) 0%, rgba(80,20,40,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }

        /* Menu de Naves */
        #shipCustomizationMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,30,60,0.95) 0%, rgba(30,0,60,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }

        .ship-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .ship-header h2 {
            font-size: 2.5em;
            color: #00ffff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ffff;
        }

        .ship-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .ship-tab {
            background: linear-gradient(45deg, #004466, #0066aa);
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #333;
        }

        .ship-tab.active {
            background: linear-gradient(45deg, #0088cc, #00aaff);
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
        }

        .ship-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,255,0.3);
        }

        .ships-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .ship-card {
            background: linear-gradient(135deg, rgba(0,50,100,0.3) 0%, rgba(0,30,60,0.3) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .ship-card.equipped {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.4);
        }

        .ship-card.legendary {
            border-color: #ff6600;
            box-shadow: 0 0 20px rgba(255,102,0,0.4);
            background: linear-gradient(135deg, rgba(255,102,0,0.1) 0%, rgba(200,50,0,0.1) 100%);
        }

        .ship-card.epic {
            border-color: #9932cc;
            box-shadow: 0 0 20px rgba(153,50,204,0.4);
            background: linear-gradient(135deg, rgba(153,50,204,0.1) 0%, rgba(100,20,150,0.1) 100%);
        }

        .ship-card.rare {
            border-color: #0080ff;
            box-shadow: 0 0 20px rgba(0,128,255,0.4);
            background: linear-gradient(135deg, rgba(0,128,255,0.1) 0%, rgba(0,80,200,0.1) 100%);
        }

        .ship-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,255,255,0.2);
        }

        .ship-preview {
            width: 100%;
            height: 120px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #444;
            position: relative;
            overflow: hidden;
        }

        .ship-model {
            font-size: 3em;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .ship-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 10px;
            text-align: center;
        }

        .ship-description {
            color: #ccc;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 15px;
        }

        .ship-stats {
            margin-bottom: 15px;
        }

        .ship-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .ship-stat-bar {
            width: 100px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .ship-stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff6600);
            transition: width 0.3s ease;
        }

        .ship-abilities {
            margin-bottom: 15px;
        }

        .ship-ability {
            background: rgba(0,255,255,0.1);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 5px 0;
            font-size: 0.85em;
            color: #00ffff;
        }

        .ship-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .ship-action {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .ship-action:hover {
            transform: translateY(-2px);
        }

        .ship-action.equipped {
            background: linear-gradient(45deg, #00aa00, #00ff00);
            color: #000;
        }

        .ship-action.equip {
            background: linear-gradient(45deg, #0066aa, #00aaff);
            color: #fff;
        }

        .ship-action.upgrade {
            background: linear-gradient(45deg, #aa6600, #ff9900);
            color: #fff;
        }

        .ship-action.unlock {
            background: linear-gradient(45deg, #666, #999);
            color: #fff;
        }

        .ship-action:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        .upgrade-section {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .upgrade-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .upgrade-header h3 {
            color: #ffaa00;
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .upgrade-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .upgrade-category {
            background: rgba(255,170,0,0.1);
            border: 2px solid #ffaa00;
            border-radius: 12px;
            padding: 15px;
        }

        .upgrade-category h4 {
            color: #ffaa00;
            margin-bottom: 15px;
            text-align: center;
        }

        .upgrade-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 8px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            border: 1px solid #444;
        }

        .upgrade-option.equipped {
            border-color: #00ff00;
            background: rgba(0,255,0,0.1);
        }

        .upgrade-option:hover {
            background: rgba(255,255,255,0.1);
        }

        .upgrade-cost {
            color: #ffaa00;
            font-weight: bold;
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .skin-card {
            background: linear-gradient(135deg, rgba(100,0,100,0.3) 0%, rgba(50,0,100,0.3) 100%);
            border: 2px solid #666;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .skin-card.equipped {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
        }

        .skin-card.animated {
            border-color: #ff6600;
            animation: pulse 2s ease-in-out infinite;
        }

        .skin-card.holographic {
            border-color: #9932cc;
            background: linear-gradient(45deg, rgba(153,50,204,0.2), rgba(255,0,255,0.2), rgba(0,255,255,0.2));
            background-size: 400% 400%;
            animation: hologram 3s ease-in-out infinite;
        }

        @keyframes hologram {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .skin-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255,255,255,0.2);
        }

        .skin-preview {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
        }

        .skin-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .skin-rarity {
            font-size: 0.8em;
            opacity: 0.7;
        }

        .ship-tab-content {
            display: block;
        }
        
        .arsenal-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .arsenal-header h2 {
            font-size: 2.5em;
            color: #ff6600;
            margin-bottom: 10px;
        }
        
        .arsenal-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }
        
        .arsenal-tab {
            background: linear-gradient(45deg, #666, #999);
            border: none;
            padding: 12px 20px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .arsenal-tab.active {
            background: linear-gradient(45deg, #ff6600, #ff9900);
            box-shadow: 0 0 15px rgba(255,102,0,0.5);
        }
        
        .arsenal-tab:hover {
            transform: translateY(-2px);
        }
        
        .weapons-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .weapon-card {
            background: linear-gradient(135deg, rgba(80,20,0,0.8) 0%, rgba(120,40,20,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .weapon-card.equipped {
            border-color: #00ff00;
            box-shadow: 0 0 20px rgba(0,255,0,0.3);
        }
        
        .weapon-card.legendary {
            border-color: #ffaa00;
            box-shadow: 0 0 25px rgba(255,170,0,0.5);
            background: linear-gradient(135deg, rgba(100,50,0,0.8) 0%, rgba(150,75,25,0.8) 100%);
        }
        
        .weapon-card.epic {
            border-color: #9900ff;
            box-shadow: 0 0 20px rgba(153,0,255,0.4);
        }
        
        .weapon-card.rare {
            border-color: #0099ff;
            box-shadow: 0 0 15px rgba(0,153,255,0.3);
        }
        
        .weapon-card:hover {
            transform: scale(1.05);
        }
        
        .weapon-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .weapon-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #ff6600;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .weapon-stats {
            margin: 15px 0;
        }
        
        .weapon-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        
        .weapon-stat-bar {
            width: 60%;
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .weapon-stat-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .weapon-modifiers {
            margin: 15px 0;
        }
        
        .weapon-modifier {
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            margin: 5px 0;
            border-radius: 10px;
            font-size: 0.8em;
            color: #ccc;
        }
        
        .weapon-modifier.positive {
            color: #00ff00;
            border-left: 3px solid #00ff00;
        }
        
        .weapon-modifier.negative {
            color: #ff6666;
            border-left: 3px solid #ff6666;
        }
        
        .weapon-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .weapon-action {
            flex: 1;
            background: linear-gradient(45deg, #00aa00, #00ff00);
            border: none;
            padding: 8px 12px;
            border-radius: 15px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
        }
        
        .weapon-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,0,0.3);
        }
        
        .weapon-action.equipped {
            background: linear-gradient(45deg, #666, #999);
            color: #fff;
            cursor: default;
        }
        
        .weapon-action.upgrade {
            background: linear-gradient(45deg, #0099ff, #00ccff);
        }
        
        .weapon-action.craft {
            background: linear-gradient(45deg, #ffaa00, #ffcc00);
        }
        
        .crafting-section {
            background: linear-gradient(135deg, rgba(0,20,40,0.8) 0%, rgba(20,40,60,0.8) 100%);
            border: 2px solid #0099ff;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .crafting-header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .crafting-header h3 {
            color: #0099ff;
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        
        .materials-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .material-card {
            background: rgba(0,0,0,0.5);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .material-card:hover {
            border-color: #0099ff;
            transform: scale(1.05);
        }
        
        .material-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .material-name {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0099ff;
        }
        
        .material-count {
            color: #ffff00;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .craft-recipe {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .recipe-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .recipe-requirements {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .recipe-requirement {
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .recipe-requirement.available {
            color: #00ff00;
            border: 1px solid #00ff00;
        }
        
        .recipe-requirement.missing {
            color: #ff6666;
            border: 1px solid #ff6666;
        }
        
        .craft-button {
            background: linear-gradient(45deg, #ffaa00, #ffcc00);
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .craft-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,170,0,0.3);
        }
        
        .craft-button:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }
        
        .progression-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .progression-header h2 {
            font-size: 2.5em;
            color: #ff00ff;
            margin-bottom: 10px;
        }
        
        .player-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .stat-card {
            background: linear-gradient(135deg, rgba(0,50,100,0.8) 0%, rgba(50,0,100,0.8) 100%);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            min-width: 150px;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: 900;
            color: #ffff00;
            display: block;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #ccc;
            margin-top: 5px;
        }
        
        .xp-bar-container {
            margin: 20px 0;
            text-align: center;
        }
        
        .xp-bar {
            width: 80%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            border: 2px solid #00ffff;
            overflow: hidden;
            margin: 10px auto;
            position: relative;
        }
        
        .xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff8800);
            transition: width 0.5s ease;
            border-radius: 8px;
        }
        
        .xp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #000;
            font-weight: bold;
            font-size: 12px;
        }
        
        .skill-tree {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        
        .skill-branch {
            background: linear-gradient(135deg, rgba(0,30,60,0.8) 0%, rgba(30,0,60,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        
        .skill-branch.unlocked {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        
        .skill-branch h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .skill-node {
            background: #222;
            border: 2px solid #555;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .skill-node.unlocked {
            border-color: #00ff00;
            background: linear-gradient(45deg, #00aa00, #00ff00);
            box-shadow: 0 0 10px rgba(0,255,0,0.5);
        }
        
        .skill-node.available {
            border-color: #ffff00;
            background: linear-gradient(45deg, #aa8800, #ffff00);
            animation: pulse 2s infinite;
        }
        
        .skill-node:hover.available {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255,255,0,0.7);
        }
        
        .skill-cost {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            color: #ffff00;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .achievement-card {
            background: linear-gradient(135deg, rgba(60,30,0,0.8) 0%, rgba(100,50,0,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .achievement-card.unlocked {
            border-color: #ffaa00;
            box-shadow: 0 0 15px rgba(255,170,0,0.3);
        }
        
        .achievement-card.hidden {
            opacity: 0.3;
        }
        
        .achievement-icon {
            font-size: 3em;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .achievement-name {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffaa00;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .achievement-description {
            color: #ccc;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 15px;
        }
        
        .achievement-progress {
            background: #333;
            border-radius: 10px;
            height: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffaa00, #ff6600);
            transition: width 0.3s ease;
        }
        
        .achievement-reward {
            text-align: center;
            font-size: 0.9em;
            color: #00ff00;
            font-weight: bold;
        }
        
        .battlepass-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .battlepass-level {
            font-size: 3em;
            color: #00ff00;
            font-weight: 900;
        }
        
        .battlepass-tier {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, rgba(0,50,30,0.8) 0%, rgba(0,80,50,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .battlepass-tier.unlocked {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
        }
        
        .battlepass-tier.current {
            border-color: #ffff00;
            box-shadow: 0 0 20px rgba(255,255,0,0.5);
            animation: glow-yellow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow-yellow {
            from { box-shadow: 0 0 20px rgba(255,255,0,0.5); }
            to { box-shadow: 0 0 30px rgba(255,255,0,0.8); }
        }
        
        .tier-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .tier-level {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff00;
            min-width: 50px;
        }
        
        .tier-rewards {
            display: flex;
            gap: 10px;
        }
        
        .reward-item {
            background: #333;
            border: 2px solid #555;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            min-width: 80px;
        }
        
        .reward-item.free {
            border-color: #00ff00;
        }
        
        .reward-item.premium {
            border-color: #ffaa00;
        }
        
        .daily-challenges {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .challenge-card {
            background: linear-gradient(135deg, rgba(0,30,60,0.8) 0%, rgba(30,0,60,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .challenge-card.completed {
            border-color: #00ff00;
            box-shadow: 0 0 15px rgba(0,255,0,0.3);
        }
        
        .challenge-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .challenge-description {
            color: #ccc;
            margin-bottom: 15px;
        }
        
        .challenge-progress {
            background: #333;
            border-radius: 10px;
            height: 15px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .challenge-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            transition: width 0.3s ease;
        }
        
        .challenge-reward {
            text-align: center;
            font-weight: bold;
            color: #ffff00;
        }
        
        .worlds-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .worlds-header h2 {
            font-size: 2.5em;
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .coins-display {
            font-size: 1.3em;
            color: #ffff00;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .worlds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .world-card {
            background: linear-gradient(135deg, rgba(0,50,100,0.8) 0%, rgba(50,0,100,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .world-card.unlocked {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        
        .world-card.locked {
            border-color: #666;
            opacity: 0.6;
        }
        
        .world-card:hover.unlocked {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0,255,255,0.5);
        }
        
        .world-preview {
            width: 100%;
            height: 120px;
            background: #222;
            border-radius: 10px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .world-name {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 10px;
            color: #00ffff;
        }
        
        .world-description {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .world-price {
            background: linear-gradient(45deg, #ffff00, #ff8800);
            color: #000;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 700;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .world-action {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .world-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,0,0.3);
        }
        
        .world-action:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }
        
        .back-button {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: center;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,0,0,0.3);
        }
        
        /* Interface do Jogo */
        #gameUI {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 16px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
            display: none;
        }
        
        .ui-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 20px;
        }
        
        .health-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .health-bar {
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s ease;
            border-radius: 8px;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid #00ffff;
        }
        
        .stat-icon {
            width: 16px;
            height: 16px;
            background: #ffff00;
            border-radius: 50%;
        }
        
        /* Wave and Boss UI */
        #waveInfo {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            color: #00ffff;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            text-align: center;
            z-index: 10;
            display: none;
        }
        
        .wave-number {
            font-size: 1.5em;
            color: #ffaa00;
            margin-bottom: 5px;
        }
        
        .enemies-remaining {
            font-size: 0.9em;
            color: #ff6666;
        }
        
        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.9);
            padding: 20px;
            border-radius: 15px;
            border: 3px solid #ffaa00;
            color: #ffffff;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            font-size: 1.8em;
            text-align: center;
            z-index: 100;
            animation: pulseWarning 1s ease-in-out infinite;
            display: none;
        }
        
        @keyframes pulseWarning {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* AI Learning Indicator */
        .ai-indicator {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(100,0,150,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #aa44ff;
            color: #aa44ff;
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            z-index: 10;
            display: none;
        }
        
        .ai-indicator.active {
            animation: aiPulse 2s ease-in-out infinite;
        }
        
        @keyframes aiPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        /* Enemy Type Indicator */
        .enemy-indicator {
            position: absolute;
            top: 80px;
            left: 15px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ff6666;
            color: #ff6666;
            font-family: 'Orbitron', monospace;
            font-size: 0.8em;
            z-index: 10;
            display: none;
            max-width: 200px;
        }
        
        .enemy-type {
            font-weight: bold;
            color: #ffaa00;
        }
        
        .enemy-description {
            font-size: 0.7em;
            opacity: 0.8;
            margin-top: 3px;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 3px solid #ff0000;
            border-radius: 20px;
            display: none;
            z-index: 20;
        }
        
        #gameOver h2 {
            color: #ff0000;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #888;
            text-align: center;
            display: none;
        }
        
        .world-select-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(45deg, #9400d3, #4b0082);
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 15;
            display: none;
        }
        
        .world-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(148,0,211,0.3);
        }

        /* Loading screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,0,50,0.95) 0%, rgba(20,0,50,0.95) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            border-radius: 12px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #333;
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.5em;
            color: #00ffff;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        
        <!-- Menu Principal -->
        <div id="mainMenu">
            <canvas id="menuBackground" width="900" height="600"></canvas>
            <div class="menu-overlay"></div>
            <div class="menu-content">
                <h1>WAVESLAYERS</h1>
                <p style="font-size: 1.2em; color: #ccc; margin-bottom: 30px;">Conquiste as Gal√°xias</p>
                <div class="menu-buttons-container">
                    <button class="menu-button" onclick="startGame()">üöÄ Iniciar Jogo</button>
                    <button class="menu-button" onclick="openWorldsMenu()">üåç Mundos</button>
                    <button class="menu-button" onclick="openShipCustomizationMenu()">üõ∏ Naves</button>
                    <button class="menu-button" onclick="openProgressionMenu()">‚≠ê Progress√£o</button>
                    <button class="menu-button" onclick="openAchievementsMenu()">üèÜ Conquistas</button>
                    <button class="menu-button" onclick="openBattlepassMenu()">üéØ Battle Pass</button>
                    <button class="menu-button" onclick="showInstructions()">üìã Controles</button>
                </div>
            </div>
        </div>
        
        <!-- Menu de Mundos -->
        <div id="worldsMenu">
            <div class="worlds-header">
                <h2>MUNDOS DISPON√çVEIS</h2>
                <div class="coins-display">
                    <div class="stat-icon"></div>
                    <span id="coinsAmount">0</span> Moedas
                </div>
            </div>
            <div class="worlds-grid" id="worldsGrid">
                <!-- Mundos ser√£o inseridos aqui dinamicamente -->
            </div>
            <button class="back-button" onclick="closeWorldsMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu de Progress√£o -->
        <div id="progressionMenu">
            <div class="progression-header">
                <h2>PROGRESS√ÉO DO PILOTO</h2>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value" id="playerLevelDisplay">1</span>
                        <div class="stat-label">N√≠vel</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="skillPointsDisplay">0</span>
                        <div class="stat-label">Pontos de Habilidade</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="gemsDisplay">0</span>
                        <div class="stat-label">Gemas</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="darkMatterDisplay">0</span>
                        <div class="stat-label">Mat√©ria Escura</div>
                    </div>
                </div>
                <div class="xp-bar-container">
                    <div>Experi√™ncia para o pr√≥ximo n√≠vel</div>
                    <div class="xp-bar">
                        <div class="xp-fill" id="xpFill"></div>
                        <div class="xp-text" id="xpText">0 / 100</div>
                    </div>
                </div>
            </div>
            
            <h3 style="text-align: center; color: #ff00ff; margin-bottom: 20px;">√ÅRVORE DE HABILIDADES</h3>
            <div class="skill-tree" id="skillTreeContainer">
                <!-- Skill tree ser√° gerada dinamicamente -->
            </div>
            
            <h3 style="text-align: center; color: #00ffff; margin-bottom: 20px;">DESAFIOS DI√ÅRIOS</h3>
            <div class="daily-challenges" id="dailyChallengesContainer">
                <!-- Desafios di√°rios ser√£o gerados dinamicamente -->
            </div>
            
            <button class="back-button" onclick="closeProgressionMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu de Conquistas -->
        <div id="achievementsMenu">
            <div class="progression-header">
                <h2>üèÜ CONQUISTAS</h2>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value" id="achievementsUnlocked">0</span>
                        <div class="stat-label">Desbloqueadas</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="achievementsTotal">50</span>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="achievementPoints">0</span>
                        <div class="stat-label">Pontos de Conquista</div>
                    </div>
                </div>
            </div>
            
            <div class="achievements-grid" id="achievementsGrid">
                <!-- Conquistas ser√£o geradas dinamicamente -->
            </div>
            
            <button class="back-button" onclick="closeAchievementsMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu Battle Pass -->
        <div id="battlepassMenu">
            <div class="battlepass-header">
                <h2>üéØ BATTLE PASS</h2>
                <div class="battlepass-level">
                    N√≠vel <span id="battlepassLevelDisplay">0</span>
                </div>
                <div class="xp-bar-container">
                    <div>Progresso do Battle Pass</div>
                    <div class="xp-bar">
                        <div class="xp-fill" id="battlepassXpFill"></div>
                        <div class="xp-text" id="battlepassXpText">0 / 1000</div>
                    </div>
                </div>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value">Temporada 1</span>
                        <div class="stat-label">Gal√°xia Perdida</div>
                    </div>
                    <div class="stat-card" style="cursor: pointer;" onclick="upgradeBattlepass()">
                        <span class="stat-value" id="battlepassStatus">GR√ÅTIS</span>
                        <div class="stat-label">Status Premium</div>
                    </div>
                </div>
            </div>
            
            <div id="battlepassTiers">
                <!-- Tiers do Battle Pass ser√£o gerados dinamicamente -->
            </div>
            
            <button class="back-button" onclick="closeBattlepassMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Menu de Customiza√ß√£o de Naves -->
        <div id="shipCustomizationMenu">
            <div class="ship-header">
                <h2>üõ∏ HANGAR DE NAVES</h2>
                <div class="player-stats">
                    <div class="stat-card">
                        <span class="stat-value" id="currentShipName">Interceptor</span>
                        <div class="stat-label">Nave Atual</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="shipsUnlocked">1</span>
                        <div class="stat-label">Naves Desbloqueadas</div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="skinsUnlocked">3</span>
                        <div class="stat-label">Skins Desbloqueadas</div>
                    </div>
                </div>
            </div>
            
            <div class="ship-tabs">
                <button class="ship-tab active" onclick="switchShipTab('models')">üöÅ Modelos</button>
                <button class="ship-tab" onclick="switchShipTab('upgrades')">‚öôÔ∏è Upgrades</button>
                <button class="ship-tab" onclick="switchShipTab('skins')">üé® Skins</button>
                <button class="ship-tab" onclick="switchShipTab('effects')">‚ú® Efeitos</button>
            </div>
            
            <!-- Aba de Modelos -->
            <div id="modelsTab" class="ship-tab-content">
                <div class="ships-grid" id="shipsGrid">
                    <!-- Naves ser√£o geradas dinamicamente -->
                </div>
            </div>
            
            <!-- Aba de Upgrades -->
            <div id="upgradesTab" class="ship-tab-content" style="display: none;">
                <div class="upgrade-section">
                    <div class="upgrade-header">
                        <h3>üîß SISTEMA DE UPGRADES</h3>
                        <p>Melhore sua nave com componentes avan√ßados</p>
                    </div>
                    <div class="upgrade-categories" id="upgradeCategories">
                        <!-- Categorias de upgrade ser√£o geradas dinamicamente -->
                    </div>
                </div>
            </div>
            
            <!-- Aba de Skins -->
            <div id="skinsTab" class="ship-tab-content" style="display: none;">
                <div class="upgrade-section">
                    <div class="upgrade-header">
                        <h3>üé® SKINS √âPICAS</h3>
                        <p>Personalize o visual da sua nave</p>
                    </div>
                    <div class="skins-grid" id="skinsGrid">
                        <!-- Skins ser√£o geradas dinamicamente -->
                    </div>
                </div>
            </div>
            
            <!-- Aba de Efeitos -->
            <div id="effectsTab" class="ship-tab-content" style="display: none;">
                <div class="upgrade-section">
                    <div class="upgrade-header">
                        <h3>‚ú® EFEITOS VISUAIS</h3>
                        <p>Rastros, auras e modifica√ß√µes visuais</p>
                    </div>
                    <div class="skins-grid" id="effectsGrid">
                        <!-- Efeitos ser√£o gerados dinamicamente -->
                    </div>
                </div>
            </div>
            
            <button class="back-button" onclick="closeShipCustomizationMenu()">‚Üê Voltar ao Menu</button>
        </div>

        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">
                <div id="loadingMessage">Carregando mundo...</div>
            </div>
        </div>
        
        <!-- Interface do Jogo -->
        <div id="gameUI">
            <div class="ui-row">
                <div class="health-bar-container">
                    <span>VIDA:</span>
                    <div class="health-bar">
                        <div class="health-fill" id="healthFill"></div>
                        <div class="health-text" id="healthText">100/100</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon"></div>
                    <span id="coinsUI">0</span>
                </div>
            </div>
            <div class="ui-row">
                <div class="stat-item">
                    <span>PONTOS: <span id="score">0</span></span>
                </div>
                <div class="stat-item">
                    <span>N√çVEL: <span id="level">1</span></span>
                </div>
                <div class="stat-item">
                    <span>MUNDO: <span id="currentWorldName">Terra</span></span>
                </div>
            </div>
        </div>
        
        <!-- Wave Information -->
        <div id="waveInfo">
            <div class="wave-number">ONDA <span id="waveNumber">1</span></div>
            <div class="enemies-remaining">Inimigos: <span id="enemiesRemaining">0</span></div>
        </div>
        
        <!-- Boss Warning -->
        <div id="bossWarning" class="boss-warning">
            ‚ö†Ô∏è CHEFE APROXIMANDO ‚ö†Ô∏è
        </div>
        
        <!-- AI Learning Indicator -->
        <div id="aiIndicator" class="ai-indicator">
            ü§ñ IA APRENDENDO...
        </div>
        
        <!-- Enemy Type Indicator -->
        <div id="enemyIndicator" class="enemy-indicator">
            <div class="enemy-type" id="enemyTypeName">Tipo de Inimigo</div>
            <div class="enemy-description" id="enemyTypeDescription">Descri√ß√£o do inimigo</div>
        </div>
        
        <button class="world-select-btn" id="worldSelectBtn" onclick="openWorldsMenu()">üåç Mundos</button>
        
        <div id="gameOver">
            <h2>MISS√ÉO FALHOU</h2>
            <p style="font-size: 1.2em; margin-bottom: 20px;">Pontua√ß√£o Final: <span id="finalScore">0</span></p>
            <p style="font-size: 1em; color: #ffff00; margin-bottom: 20px;">Moedas Coletadas: <span id="coinsEarned">0</span></p>
            <button class="menu-button" onclick="restartGame()">üîÑ Tentar Novamente</button>
            <button class="menu-button" onclick="goToMainMenu()">üè† Menu Principal</button>
        </div>
        
        <div id="instructions">
            Use WASD ou setas para mover ‚Ä¢ ESPA√áO para atirar ‚Ä¢ P para pausar
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameOver', 'progression', 'achievements', 'battlepass'
        let gameRunning = false;
        let isPaused = false;
        let score = 0;
        let level = 1;
        let lastTime = 0;
        let gameStartTime = 0;
        let survivalTime = 0;
        let coins = parseInt(localStorage.getItem('waveslayers_coins') || '100');
        let coinsThisRound = 0;
        let currentWorldId = localStorage.getItem('waveslayers_current_world') || 'earth';
        
        // Progression System
        let playerLevel = parseInt(localStorage.getItem('waveslayers_player_level') || '1');
        let playerXP = parseInt(localStorage.getItem('waveslayers_player_xp') || '0');
        let skillPoints = parseInt(localStorage.getItem('waveslayers_skill_points') || '0');
        let gems = parseInt(localStorage.getItem('waveslayers_gems') || '0');
        let darkMatter = parseInt(localStorage.getItem('waveslayers_dark_matter') || '0');
        
        // Skill Tree   
        let skillTree = JSON.parse(localStorage.getItem('waveslayers_skills') || '{}');
        
        // Achievements System
        let achievements = JSON.parse(localStorage.getItem('waveslayers_achievements') || '{}');
        let achievementProgress = JSON.parse(localStorage.getItem('waveslayers_achievement_progress') || '{}');
        
        // Daily Challenges
        let dailyChallenges = JSON.parse(localStorage.getItem('waveslayers_daily_challenges') || '{}');
        let lastDailyReset = localStorage.getItem('waveslayers_last_daily_reset') || '';
        
        // Battle Pass
        let battlePassLevel = parseInt(localStorage.getItem('waveslayers_battlepass_level') || '0');
        let battlePassXP = parseInt(localStorage.getItem('waveslayers_battlepass_xp') || '0');
        let battlePassPremium = localStorage.getItem('waveslayers_battlepass_premium') === 'true';
        let battlePassSeason = localStorage.getItem('waveslayers_battlepass_season') || '1';
        
        // Ship Customization System
        let currentShipId = localStorage.getItem('waveslayers_current_ship') || 'interceptor';
        let unlockedShips = JSON.parse(localStorage.getItem('waveslayers_unlocked_ships') || '["interceptor"]');
        let shipUpgrades = JSON.parse(localStorage.getItem('waveslayers_ship_upgrades') || '{}');
        let currentSkinId = localStorage.getItem('waveslayers_current_skin') || 'default';
        let unlockedSkins = JSON.parse(localStorage.getItem('waveslayers_unlocked_skins') || '["default", "blue", "red"]');
        let currentEffectId = localStorage.getItem('waveslayers_current_effect') || 'none';
        let unlockedEffects = JSON.parse(localStorage.getItem('waveslayers_unlocked_effects') || '["none"]');
        
        // Menu animation objects
        let menuStars = [];
        let menuShips = [];
        let menuBullets = [];
        let menuExplosions = [];
        let menuAnimationRunning = false;
        
        // Menu Ship class
        class MenuShip {
            constructor(x, y, type, team, target = null) {
                this.x = x;
                this.y = y;
                this.type = type; // 'player', 'enemy'
                this.team = team;
                this.target = target;
                this.width = type === 'player' ? 20 : 24;
                this.height = type === 'player' ? 20 : 24;
                this.speed = 2 + Math.random() * 2;
                this.angle = Math.random() * Math.PI * 2;
                this.health = 100;
                this.maxHealth = 100;
                this.shootTimer = Math.random() * 1000;
                this.behavior = Math.random() < 0.5 ? 'patrol' : 'chase';
                this.patrolTarget = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
                this.life = 8000 + Math.random() * 5000; // Life span
                this.maxLife = this.life;
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.shootTimer -= deltaTime;
                
                // Find nearest enemy
                if (this.behavior === 'chase' && !this.target) {
                    let nearestEnemy = null;
                    let nearestDistance = Infinity;
                    
                    menuShips.forEach(ship => {
                        if (ship.team !== this.team && ship.health > 0) {
                            const dist = Math.hypot(ship.x - this.x, ship.y - this.y);
                            if (dist < nearestDistance && dist < 200) {
                                nearestDistance = dist;
                                nearestEnemy = ship;
                            }
                        }
                    });
                    
                    this.target = nearestEnemy;
                }
                
                // Movement AI
                let targetX, targetY;
                
                if (this.behavior === 'chase' && this.target && this.target.health > 0) {
                    targetX = this.target.x;
                    targetY = this.target.y;
                } else {
                    // Patrol behavior
                    const distToPatrol = Math.hypot(this.patrolTarget.x - this.x, this.patrolTarget.y - this.y);
                    if (distToPatrol < 50) {
                        this.patrolTarget = {
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height
                        };
                    }
                    targetX = this.patrolTarget.x;
                    targetY = this.patrolTarget.y;
                }
                
                // Move towards target
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                    this.angle = Math.atan2(dy, dx);
                }
                
                // Keep in bounds with wrapping
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50;
                if (this.y > canvas.height + 50) this.y = -50;
                
                // Shooting
                if (this.shootTimer <= 0 && this.target && this.target.health > 0) {
                    const distToTarget = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                    if (distToTarget < 150) {
                        this.shoot();
                        this.shootTimer = 800 + Math.random() * 1200;
                    }
                }
            }
            
            shoot() {
                const bulletSpeed = 6;
                const bulletX = this.x + Math.cos(this.angle) * this.width;
                const bulletY = this.y + Math.sin(this.angle) * this.height;
                const vx = Math.cos(this.angle) * bulletSpeed;
                const vy = Math.sin(this.angle) * bulletSpeed;
                
                menuBullets.push(new MenuBullet(bulletX, bulletY, vx, vy, this.team, this.type));
            }
            
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.explode();
                    return true;
                }
                return false;
            }
            
            explode() {
                menuExplosions.push(new MenuExplosion(this.x, this.y));
            }
            
            draw(ctx) {
                if (this.health <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                if (this.type === 'player') {
                    this.drawPlayerShip(ctx);
                } else {
                    this.drawEnemyShip(ctx);
                }
                
                ctx.restore();
            }
            
            drawPlayerShip(ctx) {
                // Blue player ship
                ctx.fillStyle = '#00aaff';
                ctx.fillRect(-10, -6, 20, 4);
                ctx.fillRect(-8, -4, 16, 8);
                ctx.fillRect(-6, -8, 12, 4);
                ctx.fillRect(-6, 4, 12, 4);
                
                ctx.fillStyle = '#0088cc';
                ctx.fillRect(-4, -2, 8, 4);
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(6, -1, 4, 2);
            }
            
            drawEnemyShip(ctx) {
                // Red enemy ship
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(-12, -8, 24, 6);
                ctx.fillRect(-10, -6, 20, 12);
                ctx.fillRect(-8, -10, 16, 6);
                ctx.fillRect(-8, 4, 16, 6);
                
                ctx.fillStyle = '#cc0000';
                ctx.fillRect(-6, -4, 12, 8);
                
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(8, -2, 4, 4);
            }
            
            isDead() {
                return this.health <= 0 || this.life <= 0;
            }
        }
        
        // Menu Bullet class
        class MenuBullet {
            constructor(x, y, vx, vy, team, shipType) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.team = team;
                this.shipType = shipType;
                this.width = 4;
                this.height = 2;
                this.life = 2000;
                this.damage = 25;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
            }
            
            draw(ctx) {
                ctx.fillStyle = this.shipType === 'player' ? '#ffff00' : '#ff6666';
                ctx.fillRect(this.x - 2, this.y - 1, this.width, this.height);
                
                // Glow effect
                ctx.shadowColor = this.shipType === 'player' ? '#ffff00' : '#ff6666';
                ctx.shadowBlur = 3;
                ctx.fillRect(this.x - 2, this.y - 1, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.x < -10 || this.x > canvas.width + 10 || 
                       this.y < -10 || this.y > canvas.height + 10 || 
                       this.life <= 0;
            }
        }
        
        // Menu Explosion class
        class MenuExplosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI * 2 * i) / 12;
                    const speed = 2 + Math.random() * 4;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 800 + Math.random() * 400,
                        maxLife: 800 + Math.random() * 400,
                        size: 2 + Math.random() * 3,
                        color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00'
                    });
                }
            }
            
            update(deltaTime) {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= deltaTime;
                    particle.vy += 0.05; // gravity
                    return particle.life > 0;
                });
            }
            
            draw(ctx) {
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = particle.color;
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                });
                ctx.globalAlpha = 1;
            }
            
            isDead() {
                return this.particles.length === 0;
            }
        }
        
        // Menu Star class
        class MenuStar {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 1 + 0.3;
                this.size = Math.random() * 2 + 0.5;
                this.brightness = Math.random() * 0.8 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            
            update(deltaTime) {
                this.y += this.speed;
                this.twinkle += 0.02;
                
                if (this.y > canvas.height + 10) {
                    this.y = -10;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            draw(ctx) {
                const twinkleBrightness = this.brightness + Math.sin(this.twinkle) * 0.3;
                ctx.globalAlpha = Math.max(0.1, twinkleBrightness);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        function initMenuAnimation() {
            const menuCanvas = document.getElementById('menuBackground');
            if (!menuCanvas) return;
            
            // Create background stars
            menuStars = [];
            for (let i = 0; i < 80; i++) {
                menuStars.push(new MenuStar());
            }
            
            // Create initial ships
            menuShips = [];
            menuBullets = [];
            menuExplosions = [];
            
            spawnMenuShips();
            menuAnimationRunning = true;
        }
        
        function spawnMenuShips() {
            // Spawn player ships
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                menuShips.push(new MenuShip(x, y, 'player', 'player'));
            }
            
            // Spawn enemy ships
            for (let i = 0; i < 4; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                menuShips.push(new MenuShip(x, y, 'enemy', 'enemy'));
            }
        }
        
        function updateMenuAnimation(deltaTime) {
            if (!menuAnimationRunning) return;
            
            const menuCanvas = document.getElementById('menuBackground');
            if (!menuCanvas) return;
            
            const menuCtx = menuCanvas.getContext('2d');
            
            // Clear canvas with space gradient
            const gradient = menuCtx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000428');
            gradient.addColorStop(0.5, '#004e92');
            gradient.addColorStop(1, '#000000');
            menuCtx.fillStyle = gradient;
            menuCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw stars
            menuStars.forEach(star => {
                star.update(deltaTime);
                star.draw(menuCtx);
            });
            
            // Update ships
            menuShips = menuShips.filter(ship => {
                ship.update(deltaTime);
                ship.draw(menuCtx);
                return !ship.isDead();
            });
            
            // Update bullets
            menuBullets = menuBullets.filter(bullet => {
                bullet.update(deltaTime);
                bullet.draw(menuCtx);
                return !bullet.isOffScreen();
            });
            
            // Update explosions
            menuExplosions = menuExplosions.filter(explosion => {
                explosion.update(deltaTime);
                explosion.draw(menuCtx);
                return !explosion.isDead();
            });
            
            // Check bullet collisions
            for (let i = menuBullets.length - 1; i >= 0; i--) {
                const bullet = menuBullets[i];
                for (let j = menuShips.length - 1; j >= 0; j--) {
                    const ship = menuShips[j];
                    
                    if (ship.team !== bullet.team && ship.health > 0) {
                        const dx = bullet.x - ship.x;
                        const dy = bullet.y - ship.y;
                        const distance = Math.hypot(dx, dy);
                        
                        if (distance < ship.width / 2) {
                            menuBullets.splice(i, 1);
                            ship.takeDamage(bullet.damage);
                            break;
                        }
                    }
                }
            }
            
            // Spawn new ships periodically
            if (menuShips.length < 8 && Math.random() < 0.002) {
                const type = Math.random() < 0.4 ? 'player' : 'enemy';
                const edge = Math.floor(Math.random() * 4);
                let x, y;
                
                switch (edge) {
                    case 0: x = -30; y = Math.random() * canvas.height; break;
                    case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = -30; break;
                    case 3: x = Math.random() * canvas.width; y = canvas.height + 30; break;
                }
                
                menuShips.push(new MenuShip(x, y, type, type));
            }
        }
        
        // Player stats
        let playerHealth = 100;
        let playerMaxHealth = 100;
        
        function getEffectiveMaxHealth() {
            let maxHealth = 100;
            if (skillTree['health1']) maxHealth = 150;
            if (skillTree['health2']) maxHealth = 200;
            return maxHealth;
        }
        
        function updatePlayerStats() {
            const newMaxHealth = getEffectiveMaxHealth();
            if (newMaxHealth !== playerMaxHealth) {
                const healthRatio = playerHealth / playerMaxHealth;
                playerMaxHealth = newMaxHealth;
                playerHealth = Math.floor(playerMaxHealth * healthRatio);
            }
        }
        
        // Input handling
        const keys = {};
        
        // Game objects
        let player;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let particles = [];
        let powerups = [];
        let stars = [];
        
        // Timers
        let enemySpawnTimer = 0;
        let powerupSpawnTimer = 0;
        
        // Worlds system
        const worlds = {
            earth: {
                id: 'earth',
                name: 'Terra',
                description: 'O lar da humanidade. C√©us azuis e nuvens brancas.',
                price: 0,
                unlocked: true,
                colors: {
                    bg: ['#87CEEB', '#E0F6FF'],
                    stars: '#FFFFFF',
                    enemies: ['#FF6B6B', '#4ECDC4', '#45B7D1']
                },
                difficulty: 1
            },
            mars: {
                id: 'mars',
                name: 'Marte',
                description: 'O planeta vermelho. Tempestades de areia e paisagens √°ridas.',
                price: 250,
                unlocked: false,
                colors: {
                    bg: ['#CD5C5C', '#A0522D'],
                    stars: '#FFD700',
                    enemies: ['#FF4500', '#DC143C', '#B22222']
                },
                difficulty: 1.5
            },
            jupiter: {
                id: 'jupiter',
                name: 'J√∫piter',
                description: 'Gigante gasoso. Tempestades colossais e radia√ß√£o intensa.',
                price: 500,
                unlocked: false,
                colors: {
                    bg: ['#DEB887', '#F4A460'],
                    stars: '#FFA500',
                    enemies: ['#FF8C00', '#DAA520', '#B8860B']
                },
                difficulty: 2
            },
            saturn: {
                id: 'saturn',
                name: 'Saturno',
                description: 'Senhor dos an√©is. Beleza hipnotizante e gravidade trai√ßoeira.',
                price: 750,
                unlocked: false,
                colors: {
                    bg: ['#F0E68C', '#EEE8AA'],
                    stars: '#FFFFE0',
                    enemies: ['#FFD700', '#FFA500', '#FF8C00']
                },
                difficulty: 2.5
            },
            neptune: {
                id: 'neptune',
                name: 'Netuno',
                description: 'Mundo gelado. Ventos supers√¥nicos e mist√©rios profundos.',
                price: 1000,
                unlocked: false,
                colors: {
                    bg: ['#4169E1', '#000080'],
                    stars: '#ADD8E6',
                    enemies: ['#0000FF', '#4169E1', '#6495ED']
                },
                difficulty: 3
            },
            blackhole: {
                id: 'blackhole',
                name: 'Buraco Negro',
                description: 'O vazio absoluto. Onde apenas os mais corajosos se aventuram.',
                price: 2000,
                unlocked: false,
                colors: {
                    bg: ['#2F2F2F', '#000000'],
                    stars: '#800080',
                    enemies: ['#8B008B', '#4B0082', '#9400D3']
                },
                difficulty: 4
            }
        };
        
        // Load unlocked worlds
        const unlockedWorlds = JSON.parse(localStorage.getItem('waveslayers_unlocked_worlds') || '["earth"]');
        unlockedWorlds.forEach(worldId => {
            if (worlds[worldId]) {
                worlds[worldId].unlocked = true;
            }
        });
        
        // Ship Models System
        const shipModels = {
            // Naves B√°sicas
            interceptor: {
                id: 'interceptor',
                name: 'Interceptor',
                description: 'Nave b√°sica e confi√°vel. Boa para iniciantes.',
                rarity: 'common',
                price: 0,
                unlocked: true,
                stats: {
                    speed: 6,
                    health: 100,
                    damage: 25,
                    fireRate: 150,
                    shield: 0
                },
                abilities: ['Manobra B√°sica'],
                sprite: 'üõ∏'
            },
            fighter: {
                id: 'fighter',
                name: 'Ca√ßa Estelar',
                description: 'Nave de combate com maior poder de fogo.',
                rarity: 'common',
                price: 500,
                unlocked: false,
                stats: {
                    speed: 5,
                    health: 120,
                    damage: 35,
                    fireRate: 120,
                    shield: 20
                },
                abilities: ['Rajada Dupla', 'Escudo B√°sico'],
                sprite: 'üöÅ'
            },
            scout: {
                id: 'scout',
                name: 'Explorador',
                description: 'Nave r√°pida e √°gil, perfeita para evas√£o.',
                rarity: 'common',
                price: 400,
                unlocked: false,
                stats: {
                    speed: 8,
                    health: 80,
                    damage: 20,
                    fireRate: 100,
                    shield: 10
                },
                abilities: ['Velocidade M√°xima', 'Evas√£o'],
                sprite: '‚úàÔ∏è'
            },
            
            // Naves Raras
            destroyer: {
                id: 'destroyer',
                name: 'Destruidor',
                description: 'Nave pesada com poder de fogo devastador.',
                rarity: 'rare',
                price: 1200,
                unlocked: false,
                stats: {
                    speed: 4,
                    health: 180,
                    damage: 50,
                    fireRate: 200,
                    shield: 40
                },
                abilities: ['Tiro Perfurador', 'Casco Refor√ßado', 'Escudo Avan√ßado'],
                sprite: 'üöÄ'
            },
            stealth: {
                id: 'stealth',
                name: 'Furtiva',
                description: 'Tecnologia de camuflagem e ataques surpresa.',
                rarity: 'rare',
                price: 1000,
                unlocked: false,
                stats: {
                    speed: 7,
                    health: 90,
                    damage: 40,
                    fireRate: 80,
                    shield: 15
                },
                abilities: ['Camuflagem', 'Ataque Cr√≠tico', 'Furtividade'],
                sprite: 'üëª'
            },
            bomber: {
                id: 'bomber',
                name: 'Bombardeiro',
                description: 'Especialista em ataques de √°rea devastadores.',
                rarity: 'rare',
                price: 1500,
                unlocked: false,
                stats: {
                    speed: 3,
                    health: 200,
                    damage: 60,
                    fireRate: 300,
                    shield: 50
                },
                abilities: ['M√≠sseis Explosivos', 'Bombardeio', 'Casco Blindado'],
                sprite: 'üí£'
            },
            
            // Naves √âpicas
            vortex: {
                id: 'vortex',
                name: 'V√≥rtice',
                description: 'Manipula energia espacial para ataques √∫nicos.',
                rarity: 'epic',
                price: 2500,
                unlocked: false,
                stats: {
                    speed: 6,
                    health: 150,
                    damage: 45,
                    fireRate: 120,
                    shield: 60
                },
                abilities: ['V√≥rtice Energ√©tico', 'Distor√ß√£o Temporal', 'Campo de For√ßa'],
                sprite: 'üåÄ'
            },
            phoenix: {
                id: 'phoenix',
                name: 'F√™nix',
                description: 'Renascimento autom√°tico e poder crescente.',
                rarity: 'epic',
                price: 3000,
                unlocked: false,
                stats: {
                    speed: 5,
                    health: 160,
                    damage: 55,
                    fireRate: 100,
                    shield: 40
                },
                abilities: ['Renascimento', 'Chamas Eternas', 'Poder Crescente'],
                sprite: 'üî•'
            },
            quantum: {
                id: 'quantum',
                name: 'Quantum',
                description: 'Tecnologia qu√¢ntica avan√ßada e teletransporte.',
                rarity: 'epic',
                price: 3500,
                unlocked: false,
                stats: {
                    speed: 8,
                    health: 120,
                    damage: 50,
                    fireRate: 90,
                    shield: 80
                },
                abilities: ['Teletransporte', 'Duplica√ß√£o Qu√¢ntica', 'Fase Fantasma'],
                sprite: '‚öõÔ∏è'
            },
            
            // Naves Lend√°rias
            titan: {
                id: 'titan',
                name: 'Tit√£',
                description: 'A m√°quina de guerra definitiva.',
                rarity: 'legendary',
                price: 5000,
                unlocked: false,
                stats: {
                    speed: 4,
                    health: 300,
                    damage: 80,
                    fireRate: 150,
                    shield: 100
                },
                abilities: ['Modo Berserk', 'Canh√£o Tit√¢nico', 'Escudo Indestrut√≠vel', 'Regenera√ß√£o'],
                sprite: 'ü§ñ'
            },
            void: {
                id: 'void',
                name: 'Devorador do Vazio',
                description: 'Consome energia dos inimigos para se fortalecer.',
                rarity: 'legendary',
                price: 6000,
                unlocked: false,
                stats: {
                    speed: 6,
                    health: 200,
                    damage: 70,
                    fireRate: 80,
                    shield: 120
                },
                abilities: ['Drenar Vida', 'Buraco Negro', 'Absor√ß√£o Energ√©tica', 'Void Walk'],
                sprite: 'üï≥Ô∏è'
            },
            godmode: {
                id: 'godmode',
                name: 'Ascens√£o',
                description: 'Transcendeu os limites da tecnologia conhecida.',
                rarity: 'legendary',
                price: 10000,
                unlocked: false,
                stats: {
                    speed: 10,
                    health: 500,
                    damage: 100,
                    fireRate: 50,
                    shield: 200
                },
                abilities: ['Modo Deus', 'Onipresen√ßa', 'Destrui√ß√£o Total', 'Imortalidade', 'Cria√ß√£o'],
                sprite: 'üëë'
            }
        };
        
        // Ship Upgrades System
        const upgradeCategories = {
            engine: {
                name: 'Motor',
                icon: 'üöÄ',
                upgrades: {
                    basic: { name: 'Motor B√°sico', cost: 0, speedBonus: 0, equipped: true },
                    improved: { name: 'Motor Melhorado', cost: 200, speedBonus: 1, equipped: false },
                    advanced: { name: 'Motor Avan√ßado', cost: 500, speedBonus: 2, equipped: false },
                    quantum: { name: 'Motor Qu√¢ntico', cost: 1000, speedBonus: 4, equipped: false }
                }
            },
            shield: {
                name: 'Escudo',
                icon: 'üõ°Ô∏è',
                upgrades: {
                    none: { name: 'Sem Escudo', cost: 0, shieldBonus: 0, equipped: true },
                    basic: { name: 'Escudo B√°sico', cost: 300, shieldBonus: 50, equipped: false },
                    enhanced: { name: 'Escudo Refor√ßado', cost: 600, shieldBonus: 100, equipped: false },
                    quantum: { name: 'Escudo Qu√¢ntico', cost: 1200, shieldBonus: 200, equipped: false }
                }
            },
            weapons: {
                name: 'Armas',
                icon: '‚öîÔ∏è',
                upgrades: {
                    basic: { name: 'Laser B√°sico', cost: 0, damageBonus: 0, equipped: true },
                    plasma: { name: 'Canh√£o Plasma', cost: 400, damageBonus: 15, equipped: false },
                    photon: { name: 'Torpedos F√≥ton', cost: 800, damageBonus: 30, equipped: false },
                    antimatter: { name: 'Canh√£o Antimat√©ria', cost: 1500, damageBonus: 50, equipped: false }
                }
            },
            hull: {
                name: 'Casco',
                icon: 'üîß',
                upgrades: {
                    basic: { name: 'Casco B√°sico', cost: 0, healthBonus: 0, equipped: true },
                    reinforced: { name: 'Casco Refor√ßado', cost: 350, healthBonus: 50, equipped: false },
                    armored: { name: 'Casco Blindado', cost: 700, healthBonus: 100, equipped: false },
                    nanotube: { name: 'Nanotubos de Carbono', cost: 1400, healthBonus: 200, equipped: false }
                }
            }
        };
        
        // Ship Skins System
        const shipSkins = {
            default: {
                id: 'default',
                name: 'Padr√£o',
                description: 'Visual cl√°ssico da nave',
                rarity: 'common',
                price: 0,
                unlocked: true,
                colors: ['#00ccff', '#ffffff'],
                animated: false
            },
            blue: {
                id: 'blue',
                name: 'Azul Glacial',
                description: 'Tons de azul gelado',
                rarity: 'common',
                price: 0,
                unlocked: true,
                colors: ['#0080ff', '#40a0ff'],
                animated: false
            },
            red: {
                id: 'red',
                name: 'Vermelho Fogo',
                description: 'Chamas vermelhas intensas',
                rarity: 'common',
                price: 0,
                unlocked: true,
                colors: ['#ff4040', '#ff8080'],
                animated: false
            },
            gold: {
                id: 'gold',
                name: 'Dourado Real',
                description: 'Luxo e eleg√¢ncia',
                rarity: 'rare',
                price: 800,
                unlocked: false,
                colors: ['#ffd700', '#ffff80'],
                animated: false
            },
            stealth: {
                id: 'stealth',
                name: 'Modo Furtivo',
                description: 'Camuflagem ativa',
                rarity: 'rare',
                price: 1000,
                unlocked: false,
                colors: ['#404040', '#808080'],
                animated: false
            },
            neon: {
                id: 'neon',
                name: 'Neon Cyberpunk',
                description: 'Luzes neon pulsantes',
                rarity: 'epic',
                price: 1500,
                unlocked: false,
                colors: ['#ff00ff', '#00ffff'],
                animated: true
            },
            plasma: {
                id: 'plasma',
                name: 'Plasma Energ√©tico',
                description: 'Energia pura vis√≠vel',
                rarity: 'epic',
                price: 2000,
                unlocked: false,
                colors: ['#8040ff', '#ff40ff'],
                animated: true
            },
            hologram: {
                id: 'hologram',
                name: 'Holograma',
                description: 'Proje√ß√£o hologr√°fica',
                rarity: 'legendary',
                price: 3000,
                unlocked: false,
                colors: ['#40ffff', '#ff40ff', '#ffff40'],
                animated: true,
                holographic: true
            },
            void: {
                id: 'void',
                name: 'Ess√™ncia do Vazio',
                description: 'Absorve a luz ao redor',
                rarity: 'legendary',
                price: 4000,
                unlocked: false,
                colors: ['#200020', '#800080'],
                animated: true
            }
        };
        
        // Visual Effects System
        const visualEffects = {
            none: {
                id: 'none',
                name: 'Nenhum',
                description: 'Sem efeitos adicionais',
                rarity: 'common',
                price: 0,
                unlocked: true
            },
            trail_basic: {
                id: 'trail_basic',
                name: 'Rastro B√°sico',
                description: 'Rastro simples de part√≠culas',
                rarity: 'common',
                price: 300,
                unlocked: false
            },
            trail_fire: {
                id: 'trail_fire',
                name: 'Rastro de Fogo',
                description: 'Chamas ardentes atr√°s da nave',
                rarity: 'rare',
                price: 600,
                unlocked: false
            },
            aura_energy: {
                id: 'aura_energy',
                name: 'Aura Energ√©tica',
                description: 'Campo de energia ao redor da nave',
                rarity: 'rare',
                price: 800,
                unlocked: false
            },
            portal: {
                id: 'portal',
                name: 'Portal Dimensional',
                description: 'Portais se abrem durante o movimento',
                rarity: 'epic',
                price: 1200,
                unlocked: false
            },
            lightning: {
                id: 'lightning',
                name: 'Raios El√©tricos',
                description: 'Descargas el√©tricas constantes',
                rarity: 'epic',
                price: 1500,
                unlocked: false
            },
            galaxy: {
                id: 'galaxy',
                name: 'Ess√™ncia Gal√°ctica',
                description: 'Estrelas e nebulosas orbitam a nave',
                rarity: 'legendary',
                price: 2500,
                unlocked: false
            }
        };
        
        // Player class
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 70;
                this.width = 24;
                this.height = 24;
                
                // Initialize with current ship stats
                const ship = shipModels[currentShipId];
                this.baseSpeed = ship.stats.speed;
                this.baseDamage = ship.stats.damage;
                this.baseFireRate = ship.stats.fireRate;
                
                this.speed = this.getEffectiveSpeed();
                this.shootCooldown = 0;
                this.invulnerable = 0;
                this.powerLevel = 1;
                
                // Update player health based on ship
                this.updateFromShip();
            }
            
            updateFromShip() {
                const ship = shipModels[currentShipId];
                playerMaxHealth = ship.stats.health;
                
                // Apply upgrades if they exist
                updatePlayerFromShip();
            }
            
            getEffectiveSpeed() {
                let speedMultiplier = 1;
                if (skillTree['speed1']) speedMultiplier *= 1.3;
                if (skillTree['speed2']) speedMultiplier *= 1.6;
                return this.baseSpeed * speedMultiplier;
            }
            
            getFireRate() {
                let fireRate = this.baseFireRate || 150;
                if (skillTree['firerate1']) fireRate *= 0.8;
                if (skillTree['firerate2']) fireRate *= 0.6;
                return fireRate;
            }
            
            getDamageMultiplier() {
                let damageMultiplier = 1;
                if (skillTree['damage1']) damageMultiplier *= 1.2;
                if (skillTree['damage2']) damageMultiplier *= 1.5;
                return damageMultiplier;
            }
            
            update(deltaTime) {
                this.speed = this.getEffectiveSpeed();
                
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) this.x -= this.speed;
                if (keys['ArrowRight'] || keys['d'] || keys['D']) this.x += this.speed;
                if (keys['ArrowUp'] || keys['w'] || keys['W']) this.y -= this.speed;
                if (keys['ArrowDown'] || keys['s'] || keys['S']) this.y += this.speed;
                
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
                
                if ((keys[' '] || keys['Space']) && this.shootCooldown <= 0) {
                    this.shoot();
                    this.shootCooldown = this.getFireRate();
                }
                
                if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;
                if (this.invulnerable > 0) this.invulnerable -= deltaTime;
            }
            
            shoot() {
                const world = worlds[currentWorldId];
                const baseBullets = [];
                
                if (this.powerLevel === 1) {
                    baseBullets.push({ x: this.x + this.width/2 - 2, y: this.y, vx: 0, vy: -10 });
                } else if (this.powerLevel === 2) {
                    baseBullets.push({ x: this.x + this.width/2 - 6, y: this.y, vx: 0, vy: -10 });
                    baseBullets.push({ x: this.x + this.width/2 + 2, y: this.y, vx: 0, vy: -10 });
                } else {
                    baseBullets.push({ x: this.x + this.width/2 - 2, y: this.y, vx: 0, vy: -10 });
                    baseBullets.push({ x: this.x + this.width/2 - 12, y: this.y, vx: -2, vy: -10 });
                    baseBullets.push({ x: this.x + this.width/2 + 8, y: this.y, vx: 2, vy: -10 });
                }
                
                // Apply multishot skill
                if (skillTree['multishot']) {
                    const extraBullets = [];
                    baseBullets.forEach(bullet => {
                        extraBullets.push({ x: bullet.x - 8, y: bullet.y, vx: bullet.vx - 1, vy: bullet.vy });
                        extraBullets.push({ x: bullet.x + 8, y: bullet.y, vx: bullet.vx + 1, vy: bullet.vy });
                    });
                    baseBullets.push(...extraBullets);
                }
                
                // Create bullets with base damage from ship + multipliers
                const baseDamage = this.baseDamage || 25;
                const damageMultiplier = this.getDamageMultiplier();
                const finalDamage = baseDamage * damageMultiplier;
                
                baseBullets.forEach(bulletData => {
                    const bullet = new Bullet(bulletData.x, bulletData.y, bulletData.vx, bulletData.vy, true);
                    bullet.damage = finalDamage;
                    bullets.push(bullet);
                });
            }
            
            takeDamage(damage) {
                if (this.invulnerable <= 0) {
                    playerHealth = Math.max(0, playerHealth - damage);
                    this.invulnerable = 1500;
                    createExplosion(this.x + this.width/2, this.y + this.height/2, '#ff0000', 8);
                    
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
            }
            
            draw() {
                const flash = this.invulnerable > 0 && Math.floor(this.invulnerable / 100) % 2;
                if (!flash) {
                    this.drawPixelSprite();
                }
            }
            
            drawPixelSprite() {
                const pixels = [
                    '      ****      ',
                    '     ******     ',
                    '    ********    ',
                    '   **********   ',
                    '  ************  ',
                    ' ************** ',
                    '****************',
                    '****************',
                    '***  ******  ***',
                    '**   ****   ***',
                    '*     **     **',
                    '      **      '
                ];
                
                // Get current skin colors
                const currentSkin = shipSkins[currentSkinId];
                const primaryColor = currentSkin.colors[0] || '#00ccff';
                const secondaryColor = currentSkin.colors[1] || primaryColor;
                
                const pixelSize = 2;
                for (let y = 0; y < pixels.length; y++) {
                    for (let x = 0; x < pixels[y].length; x++) {
                        if (pixels[y][x] === '*') {
                            // Alternate between primary and secondary colors for effect
                            const useSecondary = (x + y) % 3 === 0;
                            ctx.fillStyle = useSecondary ? secondaryColor : primaryColor;
                            
                            // Add glow effect for special skins
                            if (currentSkin.animated) {
                                ctx.shadowColor = primaryColor;
                                ctx.shadowBlur = 5;
                            }
                            
                            ctx.fillRect(
                                this.x + x * pixelSize,
                                this.y + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                            
                            ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // Draw visual effects
                this.drawVisualEffects();
            }
            
            drawVisualEffects() {
                const effect = visualEffects[currentEffectId];
                if (!effect || effect.id === 'none') return;
                
                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                
                switch(effect.id) {
                    case 'trail_basic':
                        // Basic particle trail
                        if (Math.random() < 0.3) {
                            particles.push(new Particle(
                                centerX + (Math.random() - 0.5) * this.width,
                                this.y + this.height,
                                0, 2,
                                '#ffffff',
                                500
                            ));
                        }
                        break;
                        
                    case 'trail_fire':
                        // Fire trail
                        if (Math.random() < 0.5) {
                            const colors = ['#ff4400', '#ff8800', '#ffaa00'];
                            particles.push(new Particle(
                                centerX + (Math.random() - 0.5) * this.width,
                                this.y + this.height,
                                (Math.random() - 0.5) * 2, 
                                2 + Math.random() * 2,
                                colors[Math.floor(Math.random() * colors.length)],
                                300 + Math.random() * 200
                            ));
                        }
                        break;
                        
                    case 'aura_energy':
                        // Energy aura
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.width/2 + 5 + Math.sin(Date.now() * 0.01) * 3, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                        
                    case 'lightning':
                        // Lightning effects
                        if (Math.random() < 0.1) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(centerX, centerY);
                            ctx.lineTo(
                                centerX + (Math.random() - 0.5) * 40,
                                centerY + (Math.random() - 0.5) * 40
                            );
                            ctx.stroke();
                        }
                        break;
                }
            }
        }
        
        // Bullet class
        class Bullet {
            constructor(x, y, vx, vy, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = 4;
                this.height = 8;
                this.isPlayer = isPlayer;
                this.damage = isPlayer ? 25 : 20;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
            }
            
            draw() {
                const world = worlds[currentWorldId];
                ctx.fillStyle = this.isPlayer ? '#ffff00' : world.colors.enemies[0];
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.shadowColor = this.isPlayer ? '#ffff00' : world.colors.enemies[0];
                ctx.shadowBlur = 5;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.y < -10 || this.y > canvas.height + 10 || 
                       this.x < -10 || this.x > canvas.width + 10;
            }
        }
        
        // ===== SISTEMA DE IA ADAPTATIVA =====
        
        // Padr√µes de comportamento do jogador que a IA aprende
        let playerBehaviorData = JSON.parse(localStorage.getItem('waveslayers_player_behavior') || '{}');
        
        // Dados padr√£o de comportamento
        if (!playerBehaviorData.movementPatterns) {
            playerBehaviorData = {
                movementPatterns: { left: 0, right: 0, up: 0, down: 0, staying: 0 },
                shootingFrequency: 0,
                preferredPositions: { top: 0, middle: 0, bottom: 0 },
                evasionPatterns: { zigzag: 0, circular: 0, linear: 0 },
                powerupPreference: { health: 0, weapon: 0 },
                averageReactionTime: 500,
                sessionCount: 0
            };
        }
        
        // Sistema de forma√ß√µes t√°ticas
        const formationTypes = {
            arrow: { name: 'Seta', pattern: [[0,0], [-1,1], [1,1], [-2,2], [2,2]] },
            diamond: { name: 'Diamante', pattern: [[0,0], [-1,0], [1,0], [0,-1], [0,1]] },
            line: { name: 'Linha', pattern: [[-2,0], [-1,0], [0,0], [1,0], [2,0]] },
            circle: { name: 'C√≠rculo', pattern: [[0,0], [1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,1], [1,-1], [-1,-1]] },
            swarm: { name: 'Enxame', pattern: [[0,0], [-1,-1], [1,-1], [-2,0], [2,0], [-1,1], [1,1], [0,2]] }
        };
        
        // Sistema de ondas de inimigos
        let currentWave = 1;
        let waveEnemiesRemaining = 0;
        let bossActive = false;
        let waveStartTime = 0;
        
        // Enemy AI and Types System
        const enemyTypes = {
            // ===== B√ÅSICOS =====
            scout: {
                name: 'Batedor',
                health: 30, speed: 4, value: 15,
                color: '#ff6666', size: 16, fireRate: 2000,
                behavior: 'scout', description: 'R√°pido e √°gil, coleta informa√ß√µes'
            },
            grunt: {
                name: 'Soldado',
                health: 50, speed: 2, value: 20,
                color: '#ff4444', size: 20, fireRate: 1500,
                behavior: 'basic', description: 'Inimigo b√°sico padr√£o'
            },
            heavy: {
                name: 'Pesado',
                health: 120, speed: 1, value: 40,
                color: '#cc2222', size: 28, fireRate: 1000,
                behavior: 'tank', description: 'Lento mas resistente'
            },
            
            // ===== ESPECIALISTAS =====
            sniper: {
                name: 'Atirador',
                health: 40, speed: 1.5, value: 35,
                color: '#ff8844', size: 18, fireRate: 3000,
                behavior: 'sniper', description: 'Atira com precis√£o √† dist√¢ncia'
            },
            bomber: {
                name: 'Bombardeiro',
                health: 80, speed: 1.8, value: 50,
                color: '#ffaa44', size: 24, fireRate: 800,
                behavior: 'bomber', description: 'Dispara m√∫ltiplos proj√©teis'
            },
            interceptor: {
                name: 'Interceptador',
                health: 35, speed: 5, value: 30,
                color: '#ff66aa', size: 16, fireRate: 1200,
                behavior: 'interceptor', description: 'Persegue diretamente o jogador'
            },
            
            // ===== AVAN√áADOS =====
            stealth: {
                name: 'Furtivo',
                health: 25, speed: 3.5, value: 45,
                color: '#8844ff', size: 18, fireRate: 1800,
                behavior: 'stealth', description: 'Se torna invis√≠vel periodicamente'
            },
            shield: {
                name: 'Escudeiro',
                health: 90, speed: 2.2, value: 60,
                color: '#4488ff', size: 22, fireRate: 1400,
                behavior: 'shield', description: 'Protege outros inimigos'
            },
            healer: {
                name: 'Curandeiro',
                health: 45, speed: 2, value: 70,
                color: '#44ff88', size: 20, fireRate: 2500,
                behavior: 'healer', description: 'Cura inimigos pr√≥ximos'
            },
            teleporter: {
                name: 'Teletransportador',
                health: 40, speed: 2.5, value: 55,
                color: '#aa44ff', size: 18, fireRate: 1600,
                behavior: 'teleporter', description: 'Teletransporta-se aleatoriamente'
            },
            
            // ===== T√ÅTICOS =====
            commander: {
                name: 'Comandante',
                health: 150, speed: 1.5, value: 100,
                color: '#ffaa00', size: 26, fireRate: 1100,
                behavior: 'commander', description: 'Coordena ataques de outros inimigos'
            },
            berserker: {
                name: 'Berserker',
                health: 100, speed: 2.8, value: 80,
                color: '#ff0044', size: 24, fireRate: 800,
                behavior: 'berserker', description: 'Fica mais forte conforme perde vida'
            },
            mimic: {
                name: 'Mim√©tico',
                health: 60, speed: 3, value: 90,
                color: '#ff6600', size: 20, fireRate: 1300,
                behavior: 'mimic', description: 'Copia padr√µes de movimento do jogador'
            },
            
            // ===== ESPECIAIS =====
            spawner: {
                name: 'Gerador',
                health: 80, speed: 1, value: 120,
                color: '#8800ff', size: 30, fireRate: 4000,
                behavior: 'spawner', description: 'Gera inimigos menores'
            },
            vortex: {
                name: 'V√≥rtice',
                health: 70, speed: 2, value: 110,
                color: '#0088ff', size: 22, fireRate: 1500,
                behavior: 'vortex', description: 'Puxa o jogador para si'
            },
            phaser: {
                name: 'Faseador',
                health: 50, speed: 2.5, value: 95,
                color: '#ff00aa', size: 20, fireRate: 1700,
                behavior: 'phaser', description: 'Atravessa obst√°culos'
            },
            
            // ===== ELITES =====
            assassin: {
                name: 'Assassino',
                health: 30, speed: 6, value: 150,
                color: '#000088', size: 16, fireRate: 1000,
                behavior: 'assassin', description: 'Extremamente r√°pido e letal'
            },
            juggernaut: {
                name: 'Juggernaut',
                health: 300, speed: 0.8, value: 200,
                color: '#880000', size: 36, fireRate: 500,
                behavior: 'juggernaut', description: 'Tanque supremo'
            },
            phantom: {
                name: 'Fantasma',
                health: 40, speed: 4, value: 180,
                color: '#aa00aa', size: 18, fireRate: 1200,
                behavior: 'phantom', description: 'Alterna entre dimens√µes'
            },
            
            // ===== CHEFES =====
            mothership: {
                name: 'Nave-M√£e',
                health: 2000, speed: 0.5, value: 1000,
                color: '#ff0000', size: 80, fireRate: 300,
                behavior: 'boss_mothership', description: 'Chefe colossal com m√∫ltiplas fases',
                isBoss: true, phases: 3
            },
            hive_queen: {
                name: 'Rainha Colmeia',
                health: 1500, speed: 1, value: 800,
                color: '#88ff00', size: 60, fireRate: 400,
                behavior: 'boss_hive', description: 'Gera enxames infinitos',
                isBoss: true, phases: 2
            },
            void_lord: {
                name: 'Senhor do Vazio',
                health: 2500, speed: 2, value: 1200,
                color: '#4400ff', size: 70, fireRate: 200,
                behavior: 'boss_void', description: 'Manipula o espa√ßo-tempo',
                isBoss: true, phases: 4
            }
        };
        
        // Enemy class
        class Enemy {
            constructor(x, y, type = 'grunt', formationData = null) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.typeData = enemyTypes[type];
                
                // Base stats from type
                this.width = this.typeData.size;
                this.height = this.typeData.size;
                this.speed = this.typeData.speed;
                this.maxHealth = this.typeData.health;
                this.health = this.maxHealth;
                this.value = this.typeData.value;
                this.baseFireRate = this.typeData.fireRate;
                this.color = this.typeData.color;
                this.behavior = this.typeData.behavior;
                
                // Formation data
                this.formation = formationData;
                this.formationOffsetX = formationData?.offsetX || 0;
                this.formationOffsetY = formationData?.offsetY || 0;
                this.formationLeader = formationData?.leader || null;
                
                // AI state
                this.shootTimer = Math.random() * this.baseFireRate;
                this.behaviorTimer = 0;
                this.lastPlayerPos = { x: 0, y: 0 };
                this.patrolTarget = { x: Math.random() * canvas.width, y: Math.random() * 200 };
                this.aiState = 'patrol';
                this.stateTimer = 0;
                this.angle = Math.PI / 2;
                
                // Special behavior properties
                this.invisible = false;
                this.invisibilityTimer = 0;
                this.teleportCooldown = 0;
                this.lastTeleport = 0;
                this.shieldPower = 0;
                this.rage = 0;
                this.spawnCooldown = 0;
                this.phase = 1;
                this.phaseCooldown = 0;
                
                // Learning system
                this.adaptiveTimer = 0;
                this.playerPrediction = { x: 0, y: 0 };
                this.observationTime = 0;
                
                // Boss specific
                if (this.typeData.isBoss) {
                    bossActive = true;
                    this.maxPhases = this.typeData.phases || 1;
                    this.phaseHealthThresholds = [];
                    for (let i = 1; i < this.maxPhases; i++) {
                        this.phaseHealthThresholds.push(this.maxHealth * (1 - i / this.maxPhases));
                    }
                }
                
                // Initialize AI behavior
                this.initializeBehavior();
            }
            
            initializeBehavior() {
                switch(this.behavior) {
                    case 'scout':
                        this.speed *= 1.2;
                        this.detectionRange = 250;
                        break;
                    case 'sniper':
                        this.detectionRange = 300;
                        this.aimPrecision = 0.9;
                        break;
                    case 'stealth':
                        this.invisibilityDuration = 2000;
                        this.visibilityDuration = 1500;
                        break;
                    case 'berserker':
                        this.rageThreshold = 0.5; // Fica furioso com 50% de vida
                        break;
                    case 'commander':
                        this.commandRadius = 150;
                        this.buffPower = 1.3;
                        break;
                    case 'mimic':
                        this.learningRate = 0.1;
                        break;
                }
            }
            
            update(deltaTime) {
                this.observationTime += deltaTime;
                this.behaviorTimer += deltaTime;
                this.stateTimer += deltaTime;
                this.adaptiveTimer += deltaTime;
                
                // Update AI behavior based on type
                switch(this.behavior) {
                    case 'scout': this.updateScout(deltaTime); break;
                    case 'basic': this.updateBasic(deltaTime); break;
                    case 'tank': this.updateTank(deltaTime); break;
                    case 'sniper': this.updateSniper(deltaTime); break;
                    case 'bomber': this.updateBomber(deltaTime); break;
                    case 'interceptor': this.updateInterceptor(deltaTime); break;
                    case 'stealth': this.updateStealth(deltaTime); break;
                    case 'shield': this.updateShield(deltaTime); break;
                    case 'healer': this.updateHealer(deltaTime); break;
                    case 'teleporter': this.updateTeleporter(deltaTime); break;
                    case 'commander': this.updateCommander(deltaTime); break;
                    case 'berserker': this.updateBerserker(deltaTime); break;
                    case 'mimic': this.updateMimic(deltaTime); break;
                    case 'spawner': this.updateSpawner(deltaTime); break;
                    case 'vortex': this.updateVortex(deltaTime); break;
                    case 'phaser': this.updatePhaser(deltaTime); break;
                    case 'assassin': this.updateAssassin(deltaTime); break;
                    case 'juggernaut': this.updateJuggernaut(deltaTime); break;
                    case 'phantom': this.updatePhantom(deltaTime); break;
                    case 'boss_mothership': this.updateBossMothership(deltaTime); break;
                    case 'boss_hive': this.updateBossHive(deltaTime); break;
                    case 'boss_void': this.updateBossVoid(deltaTime); break;
                }
                
                // Formation behavior
                if (this.formation && this.formationLeader) {
                    this.updateFormationMovement(deltaTime);
                }
                
                // Adaptive AI learning
                if (this.adaptiveTimer > 1000) {
                    this.updateAdaptiveAI();
                    this.adaptiveTimer = 0;
                }
                
                // Update timers
                if (this.shootTimer > 0) this.shootTimer -= deltaTime;
                if (this.invisibilityTimer > 0) this.invisibilityTimer -= deltaTime;
                if (this.teleportCooldown > 0) this.teleportCooldown -= deltaTime;
                if (this.spawnCooldown > 0) this.spawnCooldown -= deltaTime;
                if (this.phaseCooldown > 0) this.phaseCooldown -= deltaTime;
                
                // Bounds checking
                this.checkBounds();
                
                // Boss phase transitions
                if (this.typeData.isBoss) {
                    this.checkPhaseTransition();
                }
            }
            
            updateAdaptiveAI() {
                if (!player) return;
                
                // Learn player movement patterns
                const playerMovement = this.analyzePlayerMovement();
                this.updatePlayerBehaviorData(playerMovement);
                
                // Predict player next position
                this.predictPlayerPosition();
                
                // Adapt behavior based on learned patterns
                this.adaptBehaviorToPlayer();
            }
            
            analyzePlayerMovement() {
                if (!player) return null;
                
                const deltaX = player.x - this.lastPlayerPos.x;
                const deltaY = player.y - this.lastPlayerPos.y;
                
                this.lastPlayerPos = { x: player.x, y: player.y };
                
                return {
                    direction: {
                        x: deltaX > 0 ? 'right' : deltaX < 0 ? 'left' : 'none',
                        y: deltaY > 0 ? 'down' : deltaY < 0 ? 'up' : 'none'
                    },
                    speed: Math.hypot(deltaX, deltaY),
                    position: this.getPlayerZone(player)
                };
            }
            
            getPlayerZone(player) {
                const third = canvas.height / 3;
                if (player.y < third) return 'top';
                if (player.y < third * 2) return 'middle';
                return 'bottom';
            }
            
            updatePlayerBehaviorData(movement) {
                if (!movement) return;
                
                // Update movement patterns
                if (movement.direction.x !== 'none') {
                    playerBehaviorData.movementPatterns[movement.direction.x]++;
                }
                if (movement.direction.y !== 'none') {
                    playerBehaviorData.movementPatterns[movement.direction.y]++;
                }
                if (movement.speed < 1) {
                    playerBehaviorData.movementPatterns.staying++;
                }
                
                // Update position preferences
                playerBehaviorData.preferredPositions[movement.position]++;
                
                // Save periodically
                if (Math.random() < 0.1) {
                    localStorage.setItem('waveslayers_player_behavior', JSON.stringify(playerBehaviorData));
                }
            }
            
            predictPlayerPosition() {
                if (!player) return;
                
                // Use learned patterns to predict where player will be
                const patterns = playerBehaviorData.movementPatterns;
                const total = Object.values(patterns).reduce((a, b) => a + b, 1);
                
                const leftProbability = patterns.left / total;
                const rightProbability = patterns.right / total;
                const upProbability = patterns.up / total;
                const downProbability = patterns.down / total;
                
                // Predict based on probabilities and current velocity
                let predictedX = player.x;
                let predictedY = player.y;
                
                if (rightProbability > leftProbability) {
                    predictedX += player.speed * 2;
                } else if (leftProbability > rightProbability) {
                    predictedX -= player.speed * 2;
                }
                
                if (upProbability > downProbability) {
                    predictedY -= player.speed * 2;
                } else if (downProbability > upProbability) {
                    predictedY += player.speed * 2;
                }
                
                this.playerPrediction = { x: predictedX, y: predictedY };
            }
            
            adaptBehaviorToPlayer() {
                // Adjust AI behavior based on learned player patterns
                const patterns = playerBehaviorData.movementPatterns;
                const total = Object.values(patterns).reduce((a, b) => a + b, 1);
                
                // If player moves a lot, increase tracking
                const movementTotal = patterns.left + patterns.right + patterns.up + patterns.down;
                const movementRatio = movementTotal / total;
                
                if (movementRatio > 0.7) {
                    this.speed *= 1.05; // Increase speed for mobile players
                    this.baseFireRate *= 0.95; // Shoot faster
                } else {
                    this.baseFireRate *= 1.05; // Shoot more accurately for stationary players
                }
            }
            
            // ===== BEHAVIOR UPDATES =====
            
            updateScout(deltaTime) {
                // Fast, erratic movement, reports player position
                if (this.stateTimer > 1500) {
                    this.patrolTarget = {
                        x: Math.random() * canvas.width,
                        y: Math.random() * 300
                    };
                    this.stateTimer = 0;
                }
                
                this.moveTowards(this.patrolTarget.x, this.patrolTarget.y, deltaTime);
                
                if (player && Math.hypot(player.x - this.x, player.y - this.y) < this.detectionRange) {
                    // "Report" player position to other enemies
                    this.broadcastPlayerPosition();
                    this.tryShoot();
                }
            }
            
            updateBasic(deltaTime) {
                // Standard behavior - move down and shoot
                this.y += this.speed;
                
                if (this.y > 50 && this.y < canvas.height - 200) {
                    this.tryShoot();
                }
                
                // Slight horizontal movement
                this.x += Math.sin(this.y * 0.01) * 0.5;
            }
            
            updateTank(deltaTime) {
                // Slow, steady advance with heavy firepower
                this.y += this.speed * 0.8;
                
                if (this.shootTimer <= 0) {
                    this.shoot();
                    this.shootTimer = this.baseFireRate * 0.7; // Faster shooting
                }
            }
            
            updateSniper(deltaTime) {
                // Long range precision shooting
                if (this.stateTimer > 3000) {
                    this.patrolTarget = {
                        x: Math.random() * canvas.width,
                        y: Math.random() * 150
                    };
                    this.stateTimer = 0;
                }
                
                this.moveTowards(this.patrolTarget.x, this.patrolTarget.y, deltaTime);
                
                if (player && this.shootTimer <= 0) {
                    const distance = Math.hypot(player.x - this.x, player.y - this.y);
                    if (distance < 400) {
                        this.aimAndShoot(this.aimPrecision);
                        this.shootTimer = this.baseFireRate;
                    }
                }
            }
            
            updateBomber(deltaTime) {
                // Multiple projectile attacks
                this.y += this.speed;
                
                if (this.shootTimer <= 0 && this.y > 100 && this.y < canvas.height - 200) {
                    // Fire spread shot
                    for (let i = -2; i <= 2; i++) {
                        const bullet = new Bullet(
                            this.x + this.width/2,
                            this.y + this.height,
                            i * 2, 4, false
                        );
                        enemyBullets.push(bullet);
                    }
                    this.shootTimer = this.baseFireRate;
                }
            }
            
            updateInterceptor(deltaTime) {
                // Direct pursuit of player
                if (player) {
                    const targetX = this.playerPrediction.x || player.x;
                    const targetY = this.playerPrediction.y || player.y;
                    this.moveTowards(targetX, targetY, deltaTime);
                    
                    if (Math.hypot(player.x - this.x, player.y - this.y) < 100) {
                        this.tryShoot();
                    }
                }
            }
            
            updateStealth(deltaTime) {
                // Invisibility cycling
                if (this.invisibilityTimer <= 0) {
                    this.invisible = !this.invisible;
                    this.invisibilityTimer = this.invisible ? this.invisibilityDuration : this.visibilityDuration;
                }
                
                if (player && !this.invisible) {
                    this.moveTowards(player.x, player.y, deltaTime);
                    this.tryShoot();
                }
            }
            
            updateShield(deltaTime) {
                // Protects nearby enemies
                this.y += this.speed;
                this.shieldPower = Math.min(100, this.shieldPower + deltaTime * 0.02);
                
                // Find nearby enemies to protect
                enemies.forEach(enemy => {
                    if (enemy !== this && Math.hypot(enemy.x - this.x, enemy.y - this.y) < 80) {
                        enemy.shieldProtection = this.shieldPower;
                    }
                });
                
                this.tryShoot();
            }
            
            updateHealer(deltaTime) {
                // Heals nearby enemies
                this.y += this.speed;
                
                if (this.behaviorTimer > 2000) {
                    enemies.forEach(enemy => {
                        if (enemy !== this && Math.hypot(enemy.x - this.x, enemy.y - this.y) < 100) {
                            enemy.health = Math.min(enemy.maxHealth, enemy.health + 10);
                            // Healing effect
                            particles.push(new Particle(enemy.x + enemy.width/2, enemy.y, 0, -1, '#44ff88', 1000));
                        }
                    });
                    this.behaviorTimer = 0;
                }
                
                this.tryShoot();
            }
            
            updateTeleporter(deltaTime) {
                // Random teleportation
                if (this.teleportCooldown <= 0 && Math.random() < 0.01) {
                    // Teleport effect
                    createExplosion(this.x + this.width/2, this.y + this.height/2, '#aa44ff', 8);
                    
                    this.x = Math.random() * (canvas.width - this.width);
                    this.y = Math.random() * 300;
                    
                    createExplosion(this.x + this.width/2, this.y + this.height/2, '#aa44ff', 8);
                    this.teleportCooldown = 3000;
                }
                
                this.y += this.speed;
                this.tryShoot();
            }
            
            updateCommander(deltaTime) {
                // Coordinates other enemies
                this.y += this.speed * 0.6;
                
                // Buff nearby enemies
                enemies.forEach(enemy => {
                    if (enemy !== this && Math.hypot(enemy.x - this.x, enemy.y - this.y) < this.commandRadius) {
                        enemy.commandBoost = this.buffPower;
                    }
                });
                
                // Tactical shooting
                if (this.shootTimer <= 0) {
                    // Command shot - multiple coordinated bullets
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            if (this.health > 0) {
                                this.aimAndShoot(0.8);
                            }
                        }, i * 200);
                    }
                    this.shootTimer = this.baseFireRate;
                }
            }
            
            updateBerserker(deltaTime) {
                // Gets stronger as health decreases
                const healthRatio = this.health / this.maxHealth;
                
                if (healthRatio < this.rageThreshold) {
                    this.rage = Math.min(2, 2 - healthRatio);
                    this.speed = this.typeData.speed * (1 + this.rage);
                    this.color = `rgb(${255}, ${Math.floor(68 * (1-this.rage))}, ${Math.floor(68 * (1-this.rage))})`;
                }
                
                if (player) {
                    this.moveTowards(player.x, player.y, deltaTime);
                }
                
                this.tryShoot();
            }
            
            updateMimic(deltaTime) {
                // Copies player movement patterns
                if (player && this.observationTime > 1000) {
                    const patterns = playerBehaviorData.movementPatterns;
                    const total = Object.values(patterns).reduce((a, b) => a + b, 1);
                    
                    // Mimic most common player movement
                    if (patterns.left / total > 0.3) this.x -= this.speed;
                    if (patterns.right / total > 0.3) this.x += this.speed;
                    if (patterns.up / total > 0.3) this.y -= this.speed;
                    if (patterns.down / total > 0.3) this.y += this.speed;
                }
                
                this.tryShoot();
            }
            
            updateSpawner(deltaTime) {
                // Generates smaller enemies
                this.y += this.speed * 0.5;
                
                if (this.spawnCooldown <= 0 && enemies.length < 15) {
                    // Spawn a scout
                    const spawnX = this.x + (Math.random() - 0.5) * 50;
                    const spawnY = this.y + this.height;
                    enemies.push(new Enemy(spawnX, spawnY, 'scout'));
                    
                    createExplosion(spawnX, spawnY, '#8800ff', 5);
                    this.spawnCooldown = 4000;
                }
                
                this.tryShoot();
            }
            
            updateVortex(deltaTime) {
                // Pulls player towards itself
                if (player) {
                    const distance = Math.hypot(player.x - this.x, player.y - this.y);
                    if (distance < 200) {
                        const pullStrength = (200 - distance) / 200;
                        const dx = this.x - player.x;
                        const dy = this.y - player.y;
                        const normalizedDx = dx / distance;
                        const normalizedDy = dy / distance;
                        
                        // Apply pull force (this would need to be applied to player movement)
                        this.vortexPull = {
                            x: normalizedDx * pullStrength * 2,
                            y: normalizedDy * pullStrength * 2
                        };
                    }
                }
                
                this.y += this.speed;
                this.tryShoot();
            }
            
            updatePhaser(deltaTime) {
                // Phases through obstacles
                this.y += this.speed;
                this.x += Math.sin(this.y * 0.02) * 2; // Wavy movement
                
                // Phase effect
                this.alpha = 0.3 + 0.7 * Math.abs(Math.sin(Date.now() * 0.005));
                
                this.tryShoot();
            }
            
            updateAssassin(deltaTime) {
                // Ultra-fast, precise attacks
                if (player) {
                    // Sudden acceleration towards player
                    if (Math.random() < 0.02) {
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const distance = Math.hypot(dx, dy);
                        
                        this.velocityX = (dx / distance) * this.speed * 3;
                        this.velocityY = (dy / distance) * this.speed * 3;
                    }
                    
                    this.x += this.velocityX || 0;
                    this.y += this.velocityY || 0;
                    
                    // Friction
                    this.velocityX = (this.velocityX || 0) * 0.95;
                    this.velocityY = (this.velocityY || 0) * 0.95;
                }
                
                this.tryShoot();
            }
            
            updateJuggernaut(deltaTime) {
                // Slow but unstoppable
                this.y += this.speed;
                
                // Continuous heavy firing
                if (this.shootTimer <= 0) {
                    // Heavy barrage
                    for (let i = -1; i <= 1; i++) {
                        const bullet = new Bullet(
                            this.x + this.width/2 + i * 20,
                            this.y + this.height,
                            i, 3, false
                        );
                        bullet.damage = 40; // Heavy damage
                        enemyBullets.push(bullet);
                    }
                    this.shootTimer = this.baseFireRate * 0.5;
                }
            }
            
            updatePhantom(deltaTime) {
                // Dimensional shifting
                if (this.phaseCooldown <= 0) {
                    this.phaseShift = !this.phaseShift;
                    this.phaseCooldown = 2000 + Math.random() * 1000;
                }
                
                if (this.phaseShift) {
                    this.alpha = 0.3;
                    this.speed = this.typeData.speed * 2;
                } else {
                    this.alpha = 1;
                    this.speed = this.typeData.speed;
                }
                
                if (player) {
                    this.moveTowards(player.x, player.y, deltaTime);
                }
                
                this.tryShoot();
            }
            
            // ===== BOSS BEHAVIORS =====
            
            updateBossMothership(deltaTime) {
                // Multi-phase boss behavior
                this.y = Math.min(100, this.y + this.speed);
                
                switch(this.phase) {
                    case 1:
                        // Phase 1: Basic attacks
                        if (this.shootTimer <= 0) {
                            for (let i = -2; i <= 2; i++) {
                                const bullet = new Bullet(
                                    this.x + this.width/2 + i * 15,
                                    this.y + this.height,
                                    i * 0.5, 4, false
                                );
                                enemyBullets.push(bullet);
                            }
                            this.shootTimer = 800;
                        }
                        break;
                        
                    case 2:
                        // Phase 2: Spawn escorts
                        if (this.spawnCooldown <= 0) {
                            for (let i = 0; i < 2; i++) {
                                enemies.push(new Enemy(
                                    this.x + (i - 0.5) * 100,
                                    this.y + 50,
                                    'interceptor'
                                ));
                            }
                            this.spawnCooldown = 5000;
                        }
                        // Faster shooting
                        if (this.shootTimer <= 0) {
                            this.spiralAttack();
                            this.shootTimer = 400;
                        }
                        break;
                        
                    case 3:
                        // Phase 3: Desperate barrage
                        if (this.shootTimer <= 0) {
                            this.barrageAttack();
                            this.shootTimer = 200;
                        }
                        break;
                }
                
                // Horizontal movement
                this.x += Math.sin(Date.now() * 0.001) * 2;
            }
            
            updateBossHive(deltaTime) {
                // Constant spawning boss
                this.y = Math.min(80, this.y + this.speed);
                
                if (this.spawnCooldown <= 0) {
                    // Spawn different types based on phase
                    const spawnTypes = this.phase === 1 ? ['scout', 'grunt'] : ['scout', 'grunt', 'bomber'];
                    const spawnType = spawnTypes[Math.floor(Math.random() * spawnTypes.length)];
                    
                    for (let i = 0; i < (this.phase === 2 ? 3 : 2); i++) {
                        enemies.push(new Enemy(
                            this.x + (Math.random() - 0.5) * this.width,
                            this.y + this.height,
                            spawnType
                        ));
                    }
                    
                    this.spawnCooldown = this.phase === 2 ? 2000 : 3000;
                }
            }
            
            updateBossVoid(deltaTime) {
                // Space-time manipulation boss
                this.y = Math.min(60, this.y + this.speed);
                
                // Teleportation every few seconds
                if (this.teleportCooldown <= 0) {
                    createExplosion(this.x + this.width/2, this.y + this.height/2, '#4400ff', 12);
                    this.x = Math.random() * (canvas.width - this.width);
                    createExplosion(this.x + this.width/2, this.y + this.height/2, '#4400ff', 12);
                    this.teleportCooldown = 4000;
                }
                
                // Phase-based attacks
                switch(this.phase) {
                    case 1:
                        if (this.shootTimer <= 0) {
                            this.voidBlast();
                            this.shootTimer = 1000;
                        }
                        break;
                    case 2:
                        if (this.shootTimer <= 0) {
                            this.timeDilation();
                            this.shootTimer = 1500;
                        }
                        break;
                    case 3:
                        if (this.shootTimer <= 0) {
                            this.realityRift();
                            this.shootTimer = 800;
                        }
                        break;
                    case 4:
                        // Final phase - all attacks
                        if (this.shootTimer <= 0) {
                            if (Math.random() < 0.33) this.voidBlast();
                            else if (Math.random() < 0.66) this.timeDilation();
                            else this.realityRift();
                            this.shootTimer = 600;
                        }
                        break;
                }
            }
            
            // ===== SPECIAL ATTACKS =====
            
            spiralAttack() {
                const bullets = 8;
                for (let i = 0; i < bullets; i++) {
                    const angle = (i / bullets) * Math.PI * 2 + Date.now() * 0.01;
                    const bullet = new Bullet(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        Math.cos(angle) * 3,
                        Math.sin(angle) * 3,
                        false
                    );
                    enemyBullets.push(bullet);
                }
            }
            
            barrageAttack() {
                for (let i = 0; i < 5; i++) {
                    const bullet = new Bullet(
                        this.x + Math.random() * this.width,
                        this.y + this.height,
                        (Math.random() - 0.5) * 4,
                        4 + Math.random() * 2,
                        false
                    );
                    enemyBullets.push(bullet);
                }
            }
            
            voidBlast() {
                // Dark energy blast
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const bullet = new Bullet(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        Math.cos(angle) * 2,
                        Math.sin(angle) * 2,
                        false
                    );
                    bullet.color = '#4400ff';
                    bullet.damage = 30;
                    enemyBullets.push(bullet);
                }
            }
            
            timeDilation() {
                // Slow-moving but homing bullets
                if (player) {
                    const dx = player.x - this.x;
                    const dy = player.y - this.y;
                    const distance = Math.hypot(dx, dy);
                    const bullet = new Bullet(
                        this.x + this.width/2,
                        this.y + this.height,
                        (dx/distance) * 1.5,
                        (dy/distance) * 1.5,
                        false
                    );
                    bullet.color = '#aa00aa';
                    bullet.homing = true;
                    enemyBullets.push(bullet);
                }
            }
            
            realityRift() {
                // Creates temporary black holes
                if (player) {
                    const riftX = player.x + (Math.random() - 0.5) * 200;
                    const riftY = player.y + (Math.random() - 0.5) * 200;
                    
                    // Create visual effect
                    for (let i = 0; i < 10; i++) {
                        particles.push(new Particle(
                            riftX, riftY,
                            (Math.random() - 0.5) * 4,
                            (Math.random() - 0.5) * 4,
                            '#000088',
                            2000
                        ));
                    }
                }
            }
            
            // ===== UTILITY METHODS =====
            
            moveTowards(targetX, targetY, deltaTime) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance > 5) {
                    const moveSpeed = this.speed * (this.commandBoost || 1);
                    this.x += (dx / distance) * moveSpeed;
                    this.y += (dy / distance) * moveSpeed;
                    this.angle = Math.atan2(dy, dx);
                }
            }
            
            tryShoot() {
                if (this.shootTimer <= 0) {
                    this.shoot();
                    this.shootTimer = this.baseFireRate / (this.commandBoost || 1);
                }
            }
            
            aimAndShoot(precision = 0.7) {
                if (!player) return;
                
                const targetX = this.playerPrediction.x || player.x;
                const targetY = this.playerPrediction.y || player.y;
                
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.hypot(dx, dy);
                
                // Add inaccuracy based on precision
                const inaccuracy = (1 - precision) * 50;
                const finalTargetX = targetX + (Math.random() - 0.5) * inaccuracy;
                const finalTargetY = targetY + (Math.random() - 0.5) * inaccuracy;
                
                const finalDx = finalTargetX - this.x;
                const finalDy = finalTargetY - this.y;
                const finalDistance = Math.hypot(finalDx, finalDy);
                
                const bullet = new Bullet(
                    this.x + this.width/2,
                    this.y + this.height,
                    (finalDx / finalDistance) * 5,
                    (finalDy / finalDistance) * 5,
                    false
                );
                enemyBullets.push(bullet);
            }
            
            shoot() {
                const bullet = new Bullet(this.x + this.width/2, this.y + this.height, 0, 5, false);
                enemyBullets.push(bullet);
            }
            
            broadcastPlayerPosition() {
                // Share player location with other enemies
                enemies.forEach(enemy => {
                    if (enemy !== this && Math.hypot(enemy.x - this.x, enemy.y - this.y) < 200) {
                        enemy.lastKnownPlayerPos = { x: player.x, y: player.y };
                    }
                });
            }
            
            checkBounds() {
                if (this.x < -this.width || this.x > canvas.width || this.y > canvas.height + this.height) {
                    return true; // Should be removed
                }
                
                // Keep bosses in bounds
                if (this.typeData.isBoss) {
                    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                    this.y = Math.max(0, this.y);
                }
                
                return false;
            }
            
            checkPhaseTransition() {
                if (!this.typeData.isBoss) return;
                
                for (let i = 0; i < this.phaseHealthThresholds.length; i++) {
                    if (this.health <= this.phaseHealthThresholds[i] && this.phase === i + 1) {
                        this.phase = i + 2;
                        this.onPhaseTransition();
                        break;
                    }
                }
            }
            
            onPhaseTransition() {
                // Visual effect for phase transition
                createExplosion(this.x + this.width/2, this.y + this.height/2, this.color, 20);
                
                // Heal slightly on phase transition
                this.health = Math.min(this.maxHealth, this.health + this.maxHealth * 0.1);
                
                // Show phase notification
                showNotification(`FASE ${this.phase} - ${this.typeData.name.toUpperCase()}!`, '#ff0000');
            }
            
            updateFormationMovement(deltaTime) {
                if (!this.formationLeader || this.formationLeader.health <= 0) {
                    this.formation = null;
                    this.formationLeader = null;
                    return;
                }
                
                const targetX = this.formationLeader.x + this.formationOffsetX;
                const targetY = this.formationLeader.y + this.formationOffsetY;
                
                this.moveTowards(targetX, targetY, deltaTime);
            }
            
            takeDamage(damage) {
                // Apply shield protection
                const finalDamage = damage * (1 - (this.shieldProtection || 0) * 0.01);
                this.health -= finalDamage;
                
                createExplosion(this.x + this.width/2, this.y + this.height/2, '#ff8800', 6);
                
                // Reset shield protection
                this.shieldProtection = 0;
                
                return this.health <= 0;
            }
            
            draw() {
                // Skip invisible enemies
                if (this.invisible && this.behavior === 'stealth') return;
                
                const alpha = this.alpha !== undefined ? this.alpha : 1;
                if (alpha < 1) {
                    ctx.globalAlpha = alpha;
                }
                
                // Phaser effect
                if (this.phaseShift) {
                    ctx.globalAlpha = 0.3;
                }
                
                this.drawPixelSprite();
                
                // Draw health bar for bosses
                if (this.typeData.isBoss) {
                    this.drawBossHealthBar();
                }
                
                // Draw shield effect
                if (this.shieldProtection > 0) {
                    ctx.strokeStyle = '#4488ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2 + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Reset alpha
                ctx.globalAlpha = 1;
            }
            
            drawPixelSprite() {
                const size = Math.max(8, this.width / 8);
                const pixels = this.getPixelPattern();
                
                const pixelSize = Math.floor(size);
                for (let y = 0; y < pixels.length; y++) {
                    for (let x = 0; x < pixels[y].length; x++) {
                        if (pixels[y][x] === '*') {
                            ctx.fillStyle = this.color;
                            ctx.fillRect(
                                this.x + x * pixelSize,
                                this.y + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                        } else if (pixels[y][x] === 'o') {
                            ctx.fillStyle = this.getSecondaryColor();
                            ctx.fillRect(
                                this.x + x * pixelSize,
                                this.y + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                        }
                    }
                }
            }
            
            getPixelPattern() {
                if (this.typeData.isBoss) {
                    return [
                        '    ********    ',
                        '  ************  ',
                        ' ************** ',
                        '****************',
                        '***oooooooooo***',
                        '***oooooooooo***',
                        '****************',
                        '****************',
                        '***  ******  ***',
                        '**   ******   **',
                        '*    ******    *',
                        '     ******     '
                    ];
                }
                
                // Standard enemy patterns based on size
                if (this.width >= 30) {
                    return [
                        '  ******  ',
                        ' ******** ',
                        '**********',
                        '****oo****',
                        '****oo****',
                        '**********',
                        '***    ***',
                        '**      **'
                    ];
                } else {
                    return [
                        '  ****  ',
                        ' ****** ',
                        '********',
                        '***oo***',
                        '********',
                        '**    **'
                    ];
                }
            }
            
            getSecondaryColor() {
                // Generate a lighter/darker version of the main color
                const hex = this.color.replace('#', '');
                const r = Math.min(255, parseInt(hex.substr(0,2), 16) + 50);
                const g = Math.min(255, parseInt(hex.substr(2,2), 16) + 50);
                const b = Math.min(255, parseInt(hex.substr(4,2), 16) + 50);
                return `rgb(${r},${g},${b})`;
            }
            
            drawBossHealthBar() {
                const barWidth = canvas.width * 0.8;
                const barHeight = 20;
                const barX = (canvas.width - barWidth) / 2;
                const barY = 20;
                
                // Background
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
                
                // Border
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Health fill
                const healthPercentage = this.health / this.maxHealth;
                ctx.fillStyle = healthPercentage > 0.5 ? '#ff4444' : healthPercentage > 0.25 ? '#ff8844' : '#ffaa44';
                ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
                
                // Boss name and phase
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.typeData.name} - FASE ${this.phase}`, canvas.width / 2, barY - 10);
                
                // Health text
                ctx.font = '12px Orbitron';
                ctx.fillText(`${Math.floor(this.health)}/${this.maxHealth}`, canvas.width / 2, barY + 15);
                
                ctx.textAlign = 'left';
            }
            
            isOffScreen() {
                return this.y > canvas.height + 50 || this.checkBounds();
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 4 + 2;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
                this.vy += 0.1;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        // Star background
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 3 + 0.5;
                this.size = Math.random() * 2 + 1;
                this.brightness = Math.random();
            }
            
            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = -10;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            draw() {
                const world = worlds[currentWorldId];
                ctx.globalAlpha = this.brightness;
                ctx.fillStyle = world.colors.stars;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        // Powerup class
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 16;
                this.height = 16;
                this.speed = 2;
                this.bob = 0;
            }
            
            update() {
                this.y += this.speed;
                this.bob += 0.1;
            }
            
            draw() {
                const offsetY = Math.sin(this.bob) * 3;
                let color = this.type === 'weapon' ? '#00ff00' : 
                           this.type === 'health' ? '#ff00ff' : '#00ffff';
                
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y + offsetY, this.width, this.height);
                
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y + offsetY, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.y > canvas.height + 20;
            }
        }
        
        // Game functions
        function createExplosion(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = Math.random() * 5 + 2;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    color,
                    500 + Math.random() * 500
                ));
            }
        }
        
        // ===== SISTEMA DE APRENDIZADO E INICIALIZA√á√ÉO =====
        
        function initializeAISystem() {
            // Initialize behavior tracking
            if (!playerBehaviorData.sessionCount) {
                playerBehaviorData.sessionCount = 0;
            }
            playerBehaviorData.sessionCount++;
            
            // Reset temporary data
            currentWave = 0;
            waveEnemiesRemaining = 0;
            bossActive = false;
            
            // Save updated session count
            localStorage.setItem('waveslayers_player_behavior', JSON.stringify(playerBehaviorData));
        }
        
        function trackPlayerBehavior() {
            if (!player) return;
            
            // Track movement in real-time
            const currentTime = Date.now();
            if (!this.lastBehaviorTrack) this.lastBehaviorTrack = currentTime;
            
            if (currentTime - this.lastBehaviorTrack > 100) { // Track every 100ms
                const wasMoving = keys['ArrowLeft'] || keys['a'] || keys['A'] || 
                                keys['ArrowRight'] || keys['d'] || keys['D'] ||
                                keys['ArrowUp'] || keys['w'] || keys['W'] ||
                                keys['ArrowDown'] || keys['s'] || keys['S'];
                
                if (!wasMoving) {
                    playerBehaviorData.movementPatterns.staying++;
                }
                
                // Track shooting frequency
                if (keys[' '] || keys['Space']) {
                    playerBehaviorData.shootingFrequency++;
                }
                
                // Track position preference
                const zone = getPlayerZoneForTracking(player);
                playerBehaviorData.preferredPositions[zone]++;
                
                this.lastBehaviorTrack = currentTime;
            }
        }
        
        function getPlayerZoneForTracking(player) {
            const third = canvas.height / 3;
            if (player.y < third) return 'top';
            if (player.y < third * 2) return 'middle';
            return 'bottom';
        }
        
        function saveAILearningData() {
            // Save learning data periodically
            if (Math.random() < 0.01) { // 1% chance each frame
                localStorage.setItem('waveslayers_player_behavior', JSON.stringify(playerBehaviorData));
            }
        }
        
        // ===== SISTEMA INTELIGENTE DE SPAWN =====
        
        function spawnEnemy() {
            // Sistema de ondas progressivas
            if (waveEnemiesRemaining <= 0 && enemies.length === 0 && !bossActive) {
                startNewWave();
                return;
            }
            
            // Evita spawn excessivo
            if (enemies.length >= 15) return;
            
            // Determina tipo de spawn baseado na onda atual
            const spawnType = determineSpawnType();
            
            if (spawnType === 'formation') {
                spawnFormation();
            } else if (spawnType === 'boss') {
                spawnBoss();
            } else {
                spawnIndividualEnemy();
            }
        }
        
        function startNewWave() {
            currentWave++;
            waveStartTime = Date.now();
            
            // Calcula inimigos para esta onda
            const baseEnemies = 3 + Math.floor(currentWave / 2);
            waveEnemiesRemaining = Math.min(baseEnemies, 20);
            
            // Boss a cada 5 ondas
            if (currentWave % 5 === 0) {
                waveEnemiesRemaining += 1; // O boss conta como inimigo da onda
            }
            
            // Notifica nova onda
            showNotification(`üåä ONDA ${currentWave} INICIANDO!`, '#00ffff');
            
            // Aplica buffs de dificuldade baseados na sess√£o do jogador
            applyWaveDifficultyScaling();
        }
        
        function applyWaveDifficultyScaling() {
            // Aumenta dificuldade baseado no comportamento aprendido do jogador
            const sessionCount = playerBehaviorData.sessionCount || 0;
            const difficultyMultiplier = 1 + (sessionCount * 0.1);
            
            // Aplica escalamento aos tipos de inimigos
            Object.values(enemyTypes).forEach(type => {
                if (!type.isBoss) {
                    type.health = Math.floor(type.health * difficultyMultiplier);
                    type.speed = Math.min(type.speed * 1.1, type.speed * 2); // Cap na velocidade
                }
            });
        }
        
        function determineSpawnType() {
            if (currentWave % 5 === 0 && !bossActive) {
                return 'boss';
            }
            
            if (Math.random() < 0.3 && currentWave >= 3) {
                return 'formation';
            }
            
            return 'individual';
        }
        
        function spawnIndividualEnemy() {
            const enemyType = selectEnemyType();
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = -50;
            
            const enemy = new Enemy(x, y, enemyType);
            enemies.push(enemy);
            waveEnemiesRemaining--;
        }
        
        function selectEnemyType() {
            const wave = currentWave;
            const adaptiveFactors = analyzePlayerBehaviorForSpawn();
            
            // Tipos b√°sicos est√£o sempre dispon√≠veis
            let availableTypes = ['scout', 'grunt', 'heavy'];
            
            // Desbloqueio progressivo baseado na onda
            if (wave >= 2) availableTypes.push('sniper', 'bomber');
            if (wave >= 3) availableTypes.push('interceptor', 'stealth');
            if (wave >= 4) availableTypes.push('shield', 'healer');
            if (wave >= 5) availableTypes.push('teleporter', 'commander');
            if (wave >= 7) availableTypes.push('berserker', 'mimic');
            if (wave >= 8) availableTypes.push('spawner', 'vortex', 'phaser');
            if (wave >= 10) availableTypes.push('assassin', 'juggernaut', 'phantom');
            
            // Sele√ß√£o adaptativa baseada no comportamento do jogador
            if (adaptiveFactors.isVeryMobile) {
                // Player se move muito - mais interceptors e assassins
                const mobileCounters = availableTypes.filter(type => 
                    ['interceptor', 'assassin', 'berserker'].includes(type)
                );
                if (mobileCounters.length > 0 && Math.random() < 0.4) {
                    return mobileCounters[Math.floor(Math.random() * mobileCounters.length)];
                }
            }
            
            if (adaptiveFactors.isStationary) {
                // Player fica parado - mais snipers e bombers
                const stationaryCounters = availableTypes.filter(type => 
                    ['sniper', 'bomber', 'vortex'].includes(type)
                );
                if (stationaryCounters.length > 0 && Math.random() < 0.4) {
                    return stationaryCounters[Math.floor(Math.random() * stationaryCounters.length)];
                }
            }
            
            if (adaptiveFactors.prefersTopPosition) {
                // Player gosta da parte superior - spawn inimigos que descem
                const topCounters = availableTypes.filter(type => 
                    ['grunt', 'heavy', 'juggernaut'].includes(type)
                );
                if (topCounters.length > 0 && Math.random() < 0.3) {
                    return topCounters[Math.floor(Math.random() * topCounters.length)];
                }
            }
            
            // Sele√ß√£o aleat√≥ria ponderada
            const weights = {
                scout: 0.15, grunt: 0.25, heavy: 0.1,
                sniper: 0.08, bomber: 0.08, interceptor: 0.1,
                stealth: 0.05, shield: 0.05, healer: 0.04,
                teleporter: 0.03, commander: 0.02, berserker: 0.02,
                mimic: 0.01, spawner: 0.01, vortex: 0.005,
                phaser: 0.005, assassin: 0.002, juggernaut: 0.001,
                phantom: 0.001
            };
            
            return weightedRandomSelect(availableTypes, weights);
        }
        
        function analyzePlayerBehaviorForSpawn() {
            const patterns = playerBehaviorData.movementPatterns;
            const positions = playerBehaviorData.preferredPositions;
            const total = Object.values(patterns).reduce((a, b) => a + b, 1);
            const posTotal = Object.values(positions).reduce((a, b) => a + b, 1);
            
            return {
                isVeryMobile: (patterns.left + patterns.right + patterns.up + patterns.down) / total > 0.7,
                isStationary: patterns.staying / total > 0.4,
                prefersTopPosition: positions.top / posTotal > 0.4,
                prefersMiddlePosition: positions.middle / posTotal > 0.4,
                prefersBottomPosition: positions.bottom / posTotal > 0.4
            };
        }
        
        function weightedRandomSelect(items, weights) {
            const totalWeight = items.reduce((sum, item) => sum + (weights[item] || 0.01), 0);
            let random = Math.random() * totalWeight;
            
            for (const item of items) {
                random -= weights[item] || 0.01;
                if (random <= 0) return item;
            }
            
            return items[0]; // Fallback
        }
        
        function spawnFormation() {
            const formationNames = Object.keys(formationTypes);
            const formationName = formationNames[Math.floor(Math.random() * formationNames.length)];
            const formation = formationTypes[formationName];
            
            const centerX = Math.random() * (canvas.width - 200) + 100;
            const centerY = -100;
            const spacing = 40;
            
            // Seleciona tipo de inimigo para a forma√ß√£o
            const enemyType = selectFormationEnemyType();
            
            // Cria l√≠der da forma√ß√£o
            const leader = new Enemy(centerX, centerY, enemyType);
            enemies.push(leader);
            waveEnemiesRemaining--;
            
            // Cria membros da forma√ß√£o
            formation.pattern.slice(1).forEach(([offsetX, offsetY]) => {
                if (waveEnemiesRemaining > 0) {
                    const member = new Enemy(
                        centerX + offsetX * spacing,
                        centerY + offsetY * spacing,
                        enemyType,
                        {
                            leader: leader,
                            offsetX: offsetX * spacing,
                            offsetY: offsetY * spacing
                        }
                    );
                    enemies.push(member);
                    waveEnemiesRemaining--;
                }
            });
            
            showNotification(`‚öîÔ∏è FORMA√á√ÉO ${formation.name.toUpperCase()} DETECTADA!`, '#ffaa00');
        }
        
        function selectFormationEnemyType() {
            // Forma√ß√µes usam tipos mais b√°sicos para coordena√ß√£o
            const formationTypes = ['grunt', 'heavy', 'bomber', 'shield'];
            const availableTypes = formationTypes.filter(type => {
                if (type === 'heavy' || type === 'bomber') return currentWave >= 2;
                if (type === 'shield') return currentWave >= 4;
                return true;
            });
            
            return availableTypes[Math.floor(Math.random() * availableTypes.length)];
        }
        
        function spawnBoss() {
            if (bossActive) return;
            
            // Show boss warning first
            showBossWarning();
            
            setTimeout(() => {
                // Seleciona boss baseado na onda
                let bossType;
                if (currentWave < 10) {
                    bossType = 'mothership';
                } else if (currentWave < 15) {
                    bossType = Math.random() < 0.5 ? 'mothership' : 'hive_queen';
                } else {
                    const bossTypes = ['mothership', 'hive_queen', 'void_lord'];
                    bossType = bossTypes[Math.floor(Math.random() * bossTypes.length)];
                }
                
                const boss = new Enemy(
                    canvas.width / 2 - 40,
                    -100,
                    bossType
                );
                
                enemies.push(boss);
                waveEnemiesRemaining--;
                
                // Efeitos especiais para apari√ß√£o do boss
                for (let i = 0; i < 20; i++) {
                    particles.push(new Particle(
                        boss.x + Math.random() * boss.width,
                        boss.y + Math.random() * boss.height,
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 8,
                        '#ff0000',
                        2000
                    ));
                }
                
                showNotification(`üíÄ CHEFE ${enemyTypes[bossType].name.toUpperCase()} APARECEU!`, '#ff0000');
            }, 3000); // Delay to show warning first
        }
        
        function spawnPowerup(x, y) {
            if (Math.random() < 0.25) {
                const types = ['weapon', 'health'];
                const type = types[Math.floor(Math.random() * types.length)];
                powerups.push(new Powerup(x - 8, y - 8, type));
            }
        }
        
        function checkCollisions() {
            // Player bullets vs enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    // Skip invisible stealthed enemies
                    if (enemy.invisible && enemy.behavior === 'stealth') continue;
                    
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        bullets.splice(i, 1);
                        
                        if (enemy.takeDamage(bullet.damage)) {
                            // Enemy defeated
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 10);
                            
                            const scoreGained = enemy.value;
                            score += scoreGained;
                            coins += enemy.value;
                            coinsThisRound += enemy.value;
                            
                            // Check if boss defeated
                            if (enemy.typeData.isBoss) {
                                bossActive = false;
                                showNotification(`üèÜ CHEFE ${enemy.typeData.name.toUpperCase()} DERROTADO!`, '#00ff00');
                                
                                // Boss bonus rewards
                                const bonusCoins = enemy.value * 2;
                                coins += bonusCoins;
                                coinsThisRound += bonusCoins;
                                addXP(scoreGained * 3); // Triple XP for bosses
                            } else {
                                addXP(scoreGained);
                            }
                            
                            // Progression system updates
                            achievementProgress.totalKills = (achievementProgress.totalKills || 0) + 1;
                            achievementProgress.totalCoinsCollected = (achievementProgress.totalCoinsCollected || 0) + enemy.value;
                            achievementProgress.highScore = Math.max(achievementProgress.highScore || 0, score);
                            
                            // Update challenges
                            updateChallenges('kills', 1);
                            updateChallenges('coins', enemy.value);
                            updateChallenges('score', score);
                            
                            checkAchievements();
                            
                            spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
            
            // Enemy bullets vs player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                
                // Homing bullets
                if (bullet.homing && player) {
                    const dx = player.x - bullet.x;
                    const dy = player.y - bullet.y;
                    const distance = Math.hypot(dx, dy);
                    const homingStrength = 0.1;
                    
                    bullet.vx += (dx / distance) * homingStrength;
                    bullet.vy += (dy / distance) * homingStrength;
                    
                    // Limit speed
                    const speed = Math.hypot(bullet.vx, bullet.vy);
                    if (speed > 8) {
                        bullet.vx = (bullet.vx / speed) * 8;
                        bullet.vy = (bullet.vy / speed) * 8;
                    }
                }
                
                if (bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {
                    
                    enemyBullets.splice(i, 1);
                    player.takeDamage(bullet.damage || 25);
                }
            }
            
            // Enemies vs player (collision damage)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Skip invisible stealthed enemies
                if (enemy.invisible && enemy.behavior === 'stealth') continue;
                
                if (enemy.x < player.x + player.width &&
                    enemy.x + enemy.width > player.x &&
                    enemy.y < player.y + player.height &&
                    enemy.y + enemy.height > player.y) {
                    
                    // Collision damage
                    player.takeDamage(enemy.typeData.isBoss ? 50 : 30);
                    
                    // Enemy takes collision damage too
                    if (enemy.takeDamage(50)) {
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 8);
                        
                        if (enemy.typeData.isBoss) {
                            bossActive = false;
                        }
                        
                        enemies.splice(i, 1);
                    }
                }
            }
            
            // Player vs powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                if (powerup.x < player.x + player.width &&
                    powerup.x + powerup.width > player.x &&
                    powerup.y < player.y + player.height &&
                    powerup.y + powerup.height > player.y) {
                    
                    collectPowerup(powerup.type);
                    powerups.splice(i, 1);
                    
                    // Update achievements
                    achievementProgress.powerupsCollected = (achievementProgress.powerupsCollected || 0) + 1;
                    updateChallenges('powerups', 1);
                    checkAchievements();
                }
            }
            
            // Apply vortex pulls
            enemies.forEach(enemy => {
                if (enemy.vortexPull && player) {
                    // This would need to be applied to player movement
                    // For now, just create visual effect
                    if (Math.random() < 0.1) {
                        particles.push(new Particle(
                            player.x + Math.random() * player.width,
                            player.y + Math.random() * player.height,
                            enemy.vortexPull.x,
                            enemy.vortexPull.y,
                            '#0088ff',
                            500
                        ));
                    }
                }
            });
        }
        
        function collectPowerup(type) {
            if (type === 'weapon') {
                player.powerLevel = Math.min(3, player.powerLevel + 1);
            } else if (type === 'health') {
                playerHealth = Math.min(playerMaxHealth, playerHealth + 30);
            }
            
            // Progression system updates
            achievementProgress.powerupsCollected = (achievementProgress.powerupsCollected || 0) + 1;
            updateChallenges('powerups', 1);
            checkAchievements();
        }
        
        function updateHealthBar() {
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercentage + '%';
            document.getElementById('healthText').textContent = `${playerHealth}/${playerMaxHealth}`;
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('coinsUI').textContent = coins;
            document.getElementById('currentWorldName').textContent = worlds[currentWorldId].name;
            updateHealthBar();
            
            // Update wave information
            document.getElementById('waveNumber').textContent = currentWave;
            document.getElementById('enemiesRemaining').textContent = waveEnemiesRemaining;
            
            // Show/hide wave info
            const waveInfoElement = document.getElementById('waveInfo');
            if (gameState === 'playing') {
                waveInfoElement.style.display = 'block';
            } else {
                waveInfoElement.style.display = 'none';
            }
            
            // AI learning indicator
            const aiIndicator = document.getElementById('aiIndicator');
            if (gameState === 'playing' && Math.random() < 0.02) {
                aiIndicator.style.display = 'block';
                aiIndicator.classList.add('active');
                setTimeout(() => {
                    aiIndicator.style.display = 'none';
                    aiIndicator.classList.remove('active');
                }, 2000);
            }
            
            // Show enemy type information for new enemy types
            if (enemies.length > 0) {
                const uniqueEnemyType = enemies.find(enemy => 
                    enemy.typeData && !['grunt', 'scout', 'heavy'].includes(enemy.type)
                );
                
                if (uniqueEnemyType && Math.random() < 0.005) {
                    showEnemyTypeInfo(uniqueEnemyType.typeData);
                }
            }
        }
        
        function showEnemyTypeInfo(enemyType) {
            const indicator = document.getElementById('enemyIndicator');
            document.getElementById('enemyTypeName').textContent = enemyType.name;
            document.getElementById('enemyTypeDescription').textContent = enemyType.description;
            
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 4000);
        }
        
        function showBossWarning() {
            const warning = document.getElementById('bossWarning');
            warning.style.display = 'block';
            
            setTimeout(() => {
                warning.style.display = 'none';
            }, 3000);
        }
        
        function drawBackground() {
            const world = worlds[currentWorldId];
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, world.colors.bg[0]);
            gradient.addColorStop(1, world.colors.bg[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function gameOver() {
            gameRunning = false;
            gameState = 'gameOver';
            
            // Calculate survival time
            survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
            
            // Update progression
            achievementProgress.longestSurvival = Math.max(achievementProgress.longestSurvival || 0, survivalTime);
            achievementProgress.highScore = Math.max(achievementProgress.highScore || 0, score);
            
            // Update challenges
            updateChallenges('survival', survivalTime);
            updateChallenges('score', score);
            
            checkAchievements();
            saveProgressionData();
            
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('coinsEarned').textContent = coinsThisRound;
            saveGameData();
        }
        
        function saveGameData() {
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_current_world', currentWorldId);
            const unlockedWorldIds = Object.keys(worlds).filter(id => worlds[id].unlocked);
            localStorage.setItem('waveslayers_unlocked_worlds', JSON.stringify(unlockedWorldIds));
        }
        
        function startGame() {
            gameState = 'playing';
            gameRunning = true;
            isPaused = false;
            score = 0;
            level = 1;
            
            // Initialize AI system
            initializeAISystem();
            
            // Apply skill bonuses
            updatePlayerStats();
            playerHealth = playerMaxHealth;
            coinsThisRound = 0;
            gameStartTime = Date.now();
            survivalTime = 0;
            
            player = new Player();
            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            powerups = [];
            
            enemySpawnTimer = 0;
            powerupSpawnTimer = 0;
            
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('worldSelectBtn').style.display = 'block';
            document.getElementById('gameOver').style.display = 'none';
            
            // Stop menu animation
            menuAnimationRunning = false;
            
            // Start first wave
            setTimeout(() => {
                startNewWave();
            }, 2000);
        }
        
        function restartGame() {
            startGame();
        }
        
        function goToMainMenu() {
            gameState = 'menu';
            gameRunning = false;
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('worldSelectBtn').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('worldsMenu').style.display = 'none';
            
            // Start menu animation
            initMenuAnimation();
        }
        
        function openWorldsMenu() {
            document.getElementById('worldsMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('worldSelectBtn').style.display = 'none';
            updateCoinsDisplay();
            renderWorldsGrid();
            
            // Stop menu animation
            menuAnimationRunning = false;
        }
        
        function closeWorldsMenu() {
            document.getElementById('worldsMenu').style.display = 'none';
            if (gameState === 'playing') {
                document.getElementById('gameUI').style.display = 'block';
                document.getElementById('worldSelectBtn').style.display = 'block';
            } else {
                document.getElementById('mainMenu').style.display = 'flex';
                // Restart menu animation
                initMenuAnimation();
            }
        }
        
        function updateCoinsDisplay() {
            document.getElementById('coinsAmount').textContent = coins;
        }
        
        function renderWorldsGrid() {
            const grid = document.getElementById('worldsGrid');
            grid.innerHTML = '';
            
            Object.values(worlds).forEach(world => {
                const card = document.createElement('div');
                card.className = `world-card ${world.unlocked ? 'unlocked' : 'locked'}`;
                
                const preview = document.createElement('div');
                preview.className = 'world-preview';
                preview.style.background = `linear-gradient(135deg, ${world.colors.bg[0]}, ${world.colors.bg[1]})`;
                
                // Add some stars to preview
                for (let i = 0; i < 8; i++) {
                    const star = document.createElement('div');
                    star.style.position = 'absolute';
                    star.style.width = '2px';
                    star.style.height = '2px';
                    star.style.background = world.colors.stars;
                    star.style.left = Math.random() * 100 + '%';
                    star.style.top = Math.random() * 100 + '%';
                    preview.appendChild(star);
                }
                
                card.innerHTML = `
                    <div class="world-name">${world.name}</div>
                    <div class="world-description">${world.description}</div>
                    ${!world.unlocked ? `<div class="world-price">üí∞ ${world.price} Moedas</div>` : ''}
                    <button class="world-action" 
                            ${!world.unlocked && coins < world.price ? 'disabled' : ''} 
                            onclick="${world.unlocked ? `selectWorld('${world.id}')` : `buyWorld('${world.id}')`}">
                        ${world.unlocked ? (world.id === currentWorldId ? 'üåü Atual' : 'üöÄ Selecionar') : 
                          (coins >= world.price ? 'üí≥ Comprar' : 'üîí Bloqueado')}
                    </button>
                `;
                
                card.insertBefore(preview, card.firstChild);
                grid.appendChild(card);
            });
        }
        
        function buyWorld(worldId) {
            const world = worlds[worldId];
            if (coins >= world.price && !world.unlocked) {
                coins -= world.price;
                world.unlocked = true;
                
                // Update progression
                achievementProgress.worldsUnlocked = (achievementProgress.worldsUnlocked || 1) + 1;
                checkAchievements();
                saveProgressionData();
                
                saveGameData();
                updateCoinsDisplay();
                renderWorldsGrid();
                
                // Show success message
                alert(`üéâ Mundo ${world.name} desbloqueado com sucesso!`);
            }
        }
        
        function selectWorld(worldId) {
            if (worlds[worldId].unlocked) {
                showLoadingScreen(`Viajando para ${worlds[worldId].name}...`);
                
                setTimeout(() => {
                    currentWorldId = worldId;
                    saveGameData();
                    
                    // Reset stars for new world
                    stars = [];
                    for (let i = 0; i < 120; i++) {
                        stars.push(new Star());
                    }
                    
                    hideLoadingScreen();
                    closeWorldsMenu();
                    
                    if (gameState === 'playing') {
                        // Reset some game elements for new world
                        enemies = [];
                        enemyBullets = [];
                        particles = [];
                    }
                }, 1500);
            }
        }
        
        function showLoadingScreen(message) {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'flex';
        }
        
        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }
        
        function showInstructions() {
            alert(`üéÆ CONTROLES DO WAVESLAYERS:

üöÄ MOVIMENTO:
‚Ä¢ WASD ou Setas: Mover nave
‚Ä¢ Espa√ßo: Atirar
‚Ä¢ P: Pausar/Despausar

üí∞ SISTEMA DE MOEDAS:
‚Ä¢ Destrua inimigos para ganhar moedas
‚Ä¢ Use moedas para desbloquear novos mundos
‚Ä¢ Cada mundo tem desafios √∫nicos

‚ö° POWER-UPS:
‚Ä¢ Verde: Melhora armas
‚Ä¢ Rosa: Restaura vida

üåç MUNDOS:
‚Ä¢ Cada mundo tem inimigos √∫nicos
‚Ä¢ Dificuldade aumenta por mundo
‚Ä¢ Explore gal√°xias distantes!

Boa sorte, comandante! üöÄ‚ú®`);
        }
        
        // ===== SISTEMA DE PROGRESS√ÉO =====
        
        // Dados dos Skills
        const skillBranches = {
            attack: {
                name: 'Ataque',
                icon: '‚öîÔ∏è',
                color: '#ff4444',
                skills: [
                    { id: 'damage1', name: 'For√ßa B√°sica', cost: 1, effect: 'damage', value: 1.2, description: '+20% Dano' },
                    { id: 'damage2', name: 'For√ßa Avan√ßada', cost: 2, effect: 'damage', value: 1.5, description: '+50% Dano', requires: ['damage1'] },
                    { id: 'firerate1', name: 'Tiro R√°pido', cost: 1, effect: 'firerate', value: 0.8, description: '+25% Vel. Tiro' },
                    { id: 'firerate2', name: 'Rajada', cost: 3, effect: 'firerate', value: 0.6, description: '+67% Vel. Tiro', requires: ['firerate1'] },
                    { id: 'multishot', name: 'Tiro M√∫ltiplo', cost: 5, effect: 'multishot', value: 2, description: 'Atira 2 proj√©teis', requires: ['damage2', 'firerate2'] }
                ]
            },
            defense: {
                name: 'Defesa',
                icon: 'üõ°Ô∏è',
                color: '#4444ff',
                skills: [
                    { id: 'health1', name: 'Vida Extra', cost: 1, effect: 'health', value: 150, description: '+50% Vida M√°xima' },
                    { id: 'health2', name: 'Tanque', cost: 2, effect: 'health', value: 200, description: '+100% Vida M√°xima', requires: ['health1'] },
                    { id: 'shield1', name: 'Escudo B√°sico', cost: 2, effect: 'shield', value: 50, description: '+50% Escudo' },
                    { id: 'shield2', name: 'Escudo Avan√ßado', cost: 3, effect: 'shield', value: 100, description: '+100% Escudo', requires: ['shield1'] },
                    { id: 'regen', name: 'Regenera√ß√£o', cost: 4, effect: 'regen', value: 1, description: 'Regenera vida', requires: ['health2', 'shield2'] }
                ]
            },
            speed: {
                name: 'Velocidade',
                icon: '‚ö°',
                color: '#ffff44',
                skills: [
                    { id: 'speed1', name: 'Propuls√£o', cost: 1, effect: 'speed', value: 1.3, description: '+30% Velocidade' },
                    { id: 'speed2', name: 'Turbina', cost: 2, effect: 'speed', value: 1.6, description: '+60% Velocidade', requires: ['speed1'] },
                    { id: 'dash1', name: 'Dash B√°sico', cost: 2, effect: 'dash', value: 1, description: 'Habilidade Dash' },
                    { id: 'dash2', name: 'Dash Avan√ßado', cost: 3, effect: 'dash', value: 2, description: 'Dash mais r√°pido', requires: ['dash1'] },
                    { id: 'teleport', name: 'Teletransporte', cost: 5, effect: 'teleport', value: 1, description: 'Teleporte instant√¢neo', requires: ['speed2', 'dash2'] }
                ]
            },
            special: {
                name: 'Especiais',
                icon: '‚ú®',
                color: '#ff44ff',
                skills: [
                    { id: 'magnet1', name: 'Magnetismo', cost: 2, effect: 'magnet', value: 1.5, description: 'Atrai power-ups' },
                    { id: 'magnet2', name: 'Super √çm√£', cost: 3, effect: 'magnet', value: 3, description: 'Maior alcance', requires: ['magnet1'] },
                    { id: 'luck1', name: 'Sorte', cost: 2, effect: 'luck', value: 1.5, description: '+50% drop rate' },
                    { id: 'luck2', name: 'Super Sorte', cost: 4, effect: 'luck', value: 2.5, description: '+150% drop rate', requires: ['luck1'] },
                    { id: 'ultimate', name: 'Ultimate', cost: 10, effect: 'ultimate', value: 1, description: 'Poder devastador', requires: ['magnet2', 'luck2'] }
                ]
            }
        };
        
        // Dados das Conquistas
        const achievementsList = [
            { id: 'first_kill', name: 'Primeiro Sangue', icon: 'üéØ', description: 'Destrua seu primeiro inimigo', reward: { coins: 50, xp: 100 }, target: 1, type: 'kills' },
            { id: 'kill_100', name: 'Ca√ßador', icon: 'üèπ', description: 'Destrua 100 inimigos', reward: { coins: 200, xp: 500, gems: 10 }, target: 100, type: 'kills' },
            { id: 'kill_1000', name: 'Exterminador', icon: 'üíÄ', description: 'Destrua 1000 inimigos', reward: { coins: 1000, xp: 2000, gems: 50 }, target: 1000, type: 'kills' },
            { id: 'kill_10000', name: 'Lenda', icon: 'üëë', description: 'Destrua 10000 inimigos', reward: { coins: 5000, xp: 10000, gems: 200, darkMatter: 10 }, target: 10000, type: 'kills' },
            
            { id: 'score_1k', name: 'Novato', icon: '‚≠ê', description: 'Atinja 1.000 pontos', reward: { coins: 100, xp: 200 }, target: 1000, type: 'score' },
            { id: 'score_10k', name: 'Veterano', icon: 'üåü', description: 'Atinja 10.000 pontos', reward: { coins: 500, xp: 1000, gems: 25 }, target: 10000, type: 'score' },
            { id: 'score_100k', name: 'Mestre', icon: 'üí´', description: 'Atinja 100.000 pontos', reward: { coins: 2500, xp: 5000, gems: 100 }, target: 100000, type: 'score' },
            { id: 'score_1m', name: 'Deus', icon: 'üåå', description: 'Atinja 1.000.000 pontos', reward: { coins: 10000, xp: 20000, gems: 500, darkMatter: 50 }, target: 1000000, type: 'score' },
            
            { id: 'survival_30s', name: 'Sobrevivente', icon: '‚è±Ô∏è', description: 'Sobreviva 30 segundos', reward: { coins: 75, xp: 150 }, target: 30, type: 'survival' },
            { id: 'survival_5m', name: 'Resistente', icon: 'üïê', description: 'Sobreviva 5 minutos', reward: { coins: 300, xp: 600, gems: 15 }, target: 300, type: 'survival' },
            { id: 'survival_15m', name: 'Imortal', icon: '‚ôæÔ∏è', description: 'Sobreviva 15 minutos', reward: { coins: 1500, xp: 3000, gems: 75, darkMatter: 5 }, target: 900, type: 'survival' },
            
            { id: 'collect_100_coins', name: 'Colecionador', icon: 'üí∞', description: 'Colete 100 moedas', reward: { xp: 200, gems: 5 }, target: 100, type: 'coins_collected' },
            { id: 'collect_1000_coins', name: 'Magnata', icon: 'üíé', description: 'Colete 1000 moedas', reward: { xp: 1000, gems: 50 }, target: 1000, type: 'coins_collected' },
            
            { id: 'unlock_world_2', name: 'Explorador', icon: 'üåç', description: 'Desbloqueie o segundo mundo', reward: { coins: 200, xp: 400, gems: 20 }, target: 1, type: 'worlds_unlocked' },
            { id: 'unlock_all_worlds', name: 'Conquistador', icon: 'üèÜ', description: 'Desbloqueie todos os mundos', reward: { coins: 5000, xp: 10000, gems: 500, darkMatter: 100 }, target: 6, type: 'worlds_unlocked' },
            
            { id: 'powerup_collector', name: 'Energizado', icon: '‚ö°', description: 'Colete 50 power-ups', reward: { coins: 150, xp: 300, gems: 10 }, target: 50, type: 'powerups_collected' },
            { id: 'speed_demon', name: 'Dem√¥nio da Velocidade', icon: 'üèÉ', description: 'Invista todos os pontos em velocidade', reward: { coins: 1000, xp: 2000, gems: 100 }, target: 1, type: 'special' },
            { id: 'tank_build', name: 'Tanque', icon: 'üõ°Ô∏è', description: 'Invista todos os pontos em defesa', reward: { coins: 1000, xp: 2000, gems: 100 }, target: 1, type: 'special' },
            { id: 'glass_cannon', name: 'Canh√£o de Vidro', icon: 'üí•', description: 'Invista todos os pontos em ataque', reward: { coins: 1000, xp: 2000, gems: 100 }, target: 1, type: 'special' }
        ];
        
        // Fun√ß√µes de Menu
        function openProgressionMenu() {
            document.getElementById('progressionMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateProgressionDisplay();
            renderSkillTree();
            renderDailyChallenges();
            menuAnimationRunning = false;
        }
        
        function closeProgressionMenu() {
            document.getElementById('progressionMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        function openAchievementsMenu() {
            document.getElementById('achievementsMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateAchievementsDisplay();
            renderAchievements();
            menuAnimationRunning = false;
        }
        
        function closeAchievementsMenu() {
            document.getElementById('achievementsMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        function openBattlepassMenu() {
            document.getElementById('battlepassMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateBattlepassDisplay();
            renderBattlepassTiers();
            menuAnimationRunning = false;
        }
        
        function closeBattlepassMenu() {
            document.getElementById('battlepassMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        // Ship Customization Menu Functions
        function openShipCustomizationMenu() {
            document.getElementById('shipCustomizationMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            updateShipCustomizationDisplay();
            renderShipModels();
            menuAnimationRunning = false;
        }
        
        function closeShipCustomizationMenu() {
            document.getElementById('shipCustomizationMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            initMenuAnimation();
        }
        
        function switchShipTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.ship-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.ship-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab and mark as active
            document.getElementById(tabName + 'Tab').style.display = 'block';
            event.target.classList.add('active');
            
            // Render content based on tab
            switch(tabName) {
                case 'models':
                    renderShipModels();
                    break;
                case 'upgrades':
                    renderShipUpgrades();
                    break;
                case 'skins':
                    renderShipSkins();
                    break;
                case 'effects':
                    renderVisualEffects();
                    break;
            }
        }
        
        function updateShipCustomizationDisplay() {
            const currentShip = shipModels[currentShipId];
            document.getElementById('currentShipName').textContent = currentShip.name;
            document.getElementById('shipsUnlocked').textContent = unlockedShips.length;
            document.getElementById('skinsUnlocked').textContent = unlockedSkins.length;
        }
        
        function renderShipModels() {
            const container = document.getElementById('shipsGrid');
            container.innerHTML = '';
            
            Object.values(shipModels).forEach(ship => {
                const shipCard = document.createElement('div');
                shipCard.className = `ship-card ${ship.rarity}`;
                if (ship.id === currentShipId) shipCard.classList.add('equipped');
                
                const isUnlocked = unlockedShips.includes(ship.id);
                const canAfford = coins >= ship.price;
                
                shipCard.innerHTML = `
                    <div class="ship-preview">
                        <div class="ship-model">${ship.sprite}</div>
                    </div>
                    <div class="ship-name">${ship.name}</div>
                    <div class="ship-description">${ship.description}</div>
                    <div class="ship-stats">
                        <div class="ship-stat">
                            <span>Velocidade:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.speed / 10) * 100}%"></div>
                            </div>
                        </div>
                        <div class="ship-stat">
                            <span>Vida:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.health / 500) * 100}%"></div>
                            </div>
                        </div>
                        <div class="ship-stat">
                            <span>Dano:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.damage / 100) * 100}%"></div>
                            </div>
                        </div>
                        <div class="ship-stat">
                            <span>Escudo:</span>
                            <div class="ship-stat-bar">
                                <div class="ship-stat-fill" style="width: ${(ship.stats.shield / 200) * 100}%"></div>
                            </div>
                        </div>
                    </div>
                    <div class="ship-abilities">
                        ${ship.abilities.map(ability => `<div class="ship-ability">${ability}</div>`).join('')}
                    </div>
                    <div class="ship-actions">
                        ${ship.id === currentShipId ? 
                            '<button class="ship-action equipped">‚úì Equipada</button>' :
                            isUnlocked ? 
                                '<button class="ship-action equip" onclick="equipShip(\'' + ship.id + '\')">üöÄ Equipar</button>' :
                                '<button class="ship-action unlock" onclick="unlockShip(\'' + ship.id + '\')" ' + 
                                (!canAfford ? 'disabled' : '') + '>üí∞ ' + ship.price + ' Moedas</button>'
                        }
                    </div>
                `;
                
                container.appendChild(shipCard);
            });
        }
        
        function renderShipUpgrades() {
            const container = document.getElementById('upgradeCategories');
            container.innerHTML = '';
            
            Object.entries(upgradeCategories).forEach(([categoryId, category]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'upgrade-category';
                
                categoryDiv.innerHTML = `
                    <h4>${category.icon} ${category.name}</h4>
                    ${Object.entries(category.upgrades).map(([upgradeId, upgrade]) => `
                        <div class="upgrade-option ${getUpgradeEquipped(categoryId) === upgradeId ? 'equipped' : ''}" 
                             onclick="equipUpgrade('${categoryId}', '${upgradeId}')">
                            <span>${upgrade.name}</span>
                            <span class="upgrade-cost">${upgrade.cost > 0 ? upgrade.cost + ' üí∞' : 'Gr√°tis'}</span>
                        </div>
                    `).join('')}
                `;
                
                container.appendChild(categoryDiv);
            });
        }
        
        function renderShipSkins() {
            const container = document.getElementById('skinsGrid');
            container.innerHTML = '';
            
            Object.values(shipSkins).forEach(skin => {
                const skinCard = document.createElement('div');
                skinCard.className = `skin-card ${skin.rarity}`;
                if (skin.id === currentSkinId) skinCard.classList.add('equipped');
                if (skin.animated) skinCard.classList.add('animated');
                if (skin.holographic) skinCard.classList.add('holographic');
                
                const isUnlocked = unlockedSkins.includes(skin.id);
                const canAfford = coins >= skin.price;
                
                skinCard.innerHTML = `
                    <div class="skin-preview" style="background: linear-gradient(45deg, ${skin.colors.join(', ')});">
                        ${shipModels[currentShipId].sprite}
                    </div>
                    <div class="skin-name">${skin.name}</div>
                    <div class="skin-rarity">${skin.description}</div>
                    <div class="ship-actions">
                        ${skin.id === currentSkinId ? 
                            '<button class="ship-action equipped">‚úì Equipada</button>' :
                            isUnlocked ? 
                                '<button class="ship-action equip" onclick="equipSkin(\'' + skin.id + '\')">üé® Equipar</button>' :
                                '<button class="ship-action unlock" onclick="unlockSkin(\'' + skin.id + '\')" ' + 
                                (!canAfford ? 'disabled' : '') + '>üí∞ ' + skin.price + ' Moedas</button>'
                        }
                    </div>
                `;
                
                skinCard.onclick = () => {
                    if (isUnlocked && skin.id !== currentSkinId) {
                        equipSkin(skin.id);
                    } else if (!isUnlocked && canAfford) {
                        unlockSkin(skin.id);
                    }
                };
                
                container.appendChild(skinCard);
            });
        }
        
        function renderVisualEffects() {
            const container = document.getElementById('effectsGrid');
            container.innerHTML = '';
            
            Object.values(visualEffects).forEach(effect => {
                const effectCard = document.createElement('div');
                effectCard.className = `skin-card ${effect.rarity}`;
                if (effect.id === currentEffectId) effectCard.classList.add('equipped');
                
                const isUnlocked = unlockedEffects.includes(effect.id);
                const canAfford = coins >= effect.price;
                
                effectCard.innerHTML = `
                    <div class="skin-preview">
                        ‚ú®
                    </div>
                    <div class="skin-name">${effect.name}</div>
                    <div class="skin-rarity">${effect.description}</div>
                    <div class="ship-actions">
                        ${effect.id === currentEffectId ? 
                            '<button class="ship-action equipped">‚úì Equipado</button>' :
                            isUnlocked ? 
                                '<button class="ship-action equip" onclick="equipEffect(\'' + effect.id + '\')">‚ú® Equipar</button>' :
                                '<button class="ship-action unlock" onclick="unlockEffect(\'' + effect.id + '\')" ' + 
                                (!canAfford ? 'disabled' : '') + '>üí∞ ' + effect.price + ' Moedas</button>'
                        }
                    </div>
                `;
                
                container.appendChild(effectCard);
            });
        }
        
        // Ship Management Functions
        function equipShip(shipId) {
            if (!unlockedShips.includes(shipId)) return;
            
            currentShipId = shipId;
            localStorage.setItem('waveslayers_current_ship', currentShipId);
            
            // Update player stats
            if (player) {
                updatePlayerFromShip();
            }
            
            showNotification(`üõ∏ Nave ${shipModels[shipId].name} equipada!`, '#00ffff');
            updateShipCustomizationDisplay();
            renderShipModels();
        }
        
        function unlockShip(shipId) {
            const ship = shipModels[shipId];
            if (!ship || coins < ship.price || unlockedShips.includes(shipId)) return;
            
            coins -= ship.price;
            unlockedShips.push(shipId);
            
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_unlocked_ships', JSON.stringify(unlockedShips));
            
            showNotification(`üõ∏ Nave ${ship.name} desbloqueada!`, '#00ff00');
            updateShipCustomizationDisplay();
            renderShipModels();
            updateCoinsDisplay();
        }
        
        function equipSkin(skinId) {
            if (!unlockedSkins.includes(skinId)) return;
            
            currentSkinId = skinId;
            localStorage.setItem('waveslayers_current_skin', currentSkinId);
            
            showNotification(`üé® Skin ${shipSkins[skinId].name} equipada!`, '#ff6600');
            renderShipSkins();
        }
        
        function unlockSkin(skinId) {
            const skin = shipSkins[skinId];
            if (!skin || coins < skin.price || unlockedSkins.includes(skinId)) return;
            
            coins -= skin.price;
            unlockedSkins.push(skinId);
            
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_unlocked_skins', JSON.stringify(unlockedSkins));
            
            showNotification(`üé® Skin ${skin.name} desbloqueada!`, '#ff6600');
            renderShipSkins();
            updateCoinsDisplay();
        }
        
        function equipEffect(effectId) {
            if (!unlockedEffects.includes(effectId)) return;
            
            currentEffectId = effectId;
            localStorage.setItem('waveslayers_current_effect', currentEffectId);
            
            showNotification(`‚ú® Efeito ${visualEffects[effectId].name} equipado!`, '#9932cc');
            renderVisualEffects();
        }
        
        function unlockEffect(effectId) {
            const effect = visualEffects[effectId];
            if (!effect || coins < effect.price || unlockedEffects.includes(effectId)) return;
            
            coins -= effect.price;
            unlockedEffects.push(effectId);
            
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_unlocked_effects', JSON.stringify(unlockedEffects));
            
            showNotification(`‚ú® Efeito ${effect.name} desbloqueado!`, '#9932cc');
            renderVisualEffects();
            updateCoinsDisplay();
        }
        
        function getUpgradeEquipped(categoryId) {
            if (!shipUpgrades[currentShipId]) {
                shipUpgrades[currentShipId] = {};
            }
            
            const shipUpgrade = shipUpgrades[currentShipId][categoryId];
            return shipUpgrade || Object.keys(upgradeCategories[categoryId].upgrades)[0];
        }
        
        function equipUpgrade(categoryId, upgradeId) {
            const upgrade = upgradeCategories[categoryId].upgrades[upgradeId];
            if (!upgrade || coins < upgrade.cost) return;
            
            // Check if already equipped
            if (getUpgradeEquipped(categoryId) === upgradeId) return;
            
            // Deduct cost
            if (upgrade.cost > 0) {
                coins -= upgrade.cost;
                localStorage.setItem('waveslayers_coins', coins.toString());
                updateCoinsDisplay();
            }
            
            // Equip upgrade
            if (!shipUpgrades[currentShipId]) {
                shipUpgrades[currentShipId] = {};
            }
            shipUpgrades[currentShipId][categoryId] = upgradeId;
            
            localStorage.setItem('waveslayers_ship_upgrades', JSON.stringify(shipUpgrades));
            
            showNotification(`‚öôÔ∏è ${upgrade.name} equipado!`, '#ffaa00');
            renderShipUpgrades();
            
            // Update player stats
            if (player) {
                updatePlayerFromShip();
            }
        }
        
        function updatePlayerFromShip() {
            const ship = shipModels[currentShipId];
            if (!ship || !player) return;
            
            // Base stats from ship
            player.baseSpeed = ship.stats.speed;
            player.baseDamage = ship.stats.damage;
            player.baseFireRate = ship.stats.fireRate;
            playerMaxHealth = ship.stats.health;
            
            // Apply upgrades
            if (shipUpgrades[currentShipId]) {
                const upgrades = shipUpgrades[currentShipId];
                
                // Engine upgrade
                if (upgrades.engine) {
                    const engineUpgrade = upgradeCategories.engine.upgrades[upgrades.engine];
                    if (engineUpgrade) {
                        player.baseSpeed += engineUpgrade.speedBonus || 0;
                    }
                }
                
                // Weapon upgrade
                if (upgrades.weapons) {
                    const weaponUpgrade = upgradeCategories.weapons.upgrades[upgrades.weapons];
                    if (weaponUpgrade) {
                        player.baseDamage += weaponUpgrade.damageBonus || 0;
                    }
                }
                
                // Hull upgrade
                if (upgrades.hull) {
                    const hullUpgrade = upgradeCategories.hull.upgrades[upgrades.hull];
                    if (hullUpgrade) {
                        playerMaxHealth += hullUpgrade.healthBonus || 0;
                    }
                }
            }
            
            // Maintain health ratio
            const healthRatio = playerHealth / playerMaxHealth;
            playerHealth = Math.floor(playerMaxHealth * healthRatio);
            
            updateHealthBar();
        }
        
        // Fun√ß√µes de Progress√£o
        function updateProgressionDisplay() {
            document.getElementById('playerLevelDisplay').textContent = playerLevel;
            document.getElementById('skillPointsDisplay').textContent = skillPoints;
            document.getElementById('gemsDisplay').textContent = gems;
            document.getElementById('darkMatterDisplay').textContent = darkMatter;
            
            // Atualizar barra de XP
            const xpForCurrentLevel = getXPRequiredForLevel(playerLevel);
            const xpForNextLevel = getXPRequiredForLevel(playerLevel + 1);
            const xpProgress = playerXP - xpForCurrentLevel;
            const xpNeeded = xpForNextLevel - xpForCurrentLevel;
            const xpPercentage = (xpProgress / xpNeeded) * 100;
            
            document.getElementById('xpFill').style.width = xpPercentage + '%';
            document.getElementById('xpText').textContent = `${xpProgress} / ${xpNeeded}`;
        }
        
        function getXPRequiredForLevel(level) {
            return Math.floor(100 * Math.pow(1.5, level - 1));
        }
        
        function addXP(amount) {
            playerXP += amount;
            
            // Check for level up
            while (playerXP >= getXPRequiredForLevel(playerLevel + 1)) {
                levelUp();
            }
            
            // Add battle pass XP
            battlePassXP += Math.floor(amount * 0.8);
            
            saveProgressionData();
        }
        
        function levelUp() {
            playerLevel++;
            skillPoints += 2; // 2 skill points per level
            
            // Show level up notification
            showNotification(`üéâ LEVEL UP! N√≠vel ${playerLevel}`, '#ffff00');
            
            saveProgressionData();
        }
        
        function renderSkillTree() {
            const container = document.getElementById('skillTreeContainer');
            container.innerHTML = '';
            
            Object.entries(skillBranches).forEach(([branchId, branch]) => {
                const branchDiv = document.createElement('div');
                branchDiv.className = 'skill-branch';
                
                const hasUnlockedSkill = branch.skills.some(skill => skillTree[skill.id]);
                if (hasUnlockedSkill) {
                    branchDiv.classList.add('unlocked');
                }
                
                branchDiv.innerHTML = `
                    <h3>${branch.icon} ${branch.name}</h3>
                `;
                
                branch.skills.forEach(skill => {
                    const skillNode = document.createElement('div');
                    skillNode.className = 'skill-node';
                    
                    const isUnlocked = skillTree[skill.id] || false;
                    const canUnlock = canUnlockSkill(skill);
                    
                    if (isUnlocked) {
                        skillNode.classList.add('unlocked');
                        skillNode.innerHTML = '‚úì';
                    } else if (canUnlock && skillPoints >= skill.cost) {
                        skillNode.classList.add('available');
                        skillNode.innerHTML = skill.cost;
                        skillNode.onclick = () => unlockSkill(skill.id);
                    } else {
                        skillNode.innerHTML = skill.cost;
                    }
                    
                    skillNode.title = `${skill.name}\n${skill.description}\nCusto: ${skill.cost} pontos`;
                    
                    const costDiv = document.createElement('div');
                    costDiv.className = 'skill-cost';
                    costDiv.textContent = skill.cost;
                    skillNode.appendChild(costDiv);
                    
                    branchDiv.appendChild(skillNode);
                });
                
                container.appendChild(branchDiv);
            });
        }
        
        function canUnlockSkill(skill) {
            if (!skill.requires) return true;
            
            return skill.requires.every(requiredSkill => skillTree[requiredSkill]);
        }
        
        function unlockSkill(skillId) {
            const skill = findSkillById(skillId);
            if (!skill || skillPoints < skill.cost || !canUnlockSkill(skill)) return;
            
            skillPoints -= skill.cost;
            skillTree[skillId] = true;
            
            showNotification(`üåü Habilidade desbloqueada: ${skill.name}`, '#00ff00');
            
            saveProgressionData();
            updateProgressionDisplay();
            renderSkillTree();
        }
        
        function findSkillById(skillId) {
            for (const branch of Object.values(skillBranches)) {
                const skill = branch.skills.find(s => s.id === skillId);
                if (skill) return skill;
            }
            return null;
        }
        
        function renderDailyChallenges() {
            checkDailyReset();
            
            const container = document.getElementById('dailyChallengesContainer');
            container.innerHTML = '';
            
            if (Object.keys(dailyChallenges).length === 0) {
                resetDailyChallenges();
            }
            
            Object.values(dailyChallenges).forEach(challenge => {
                const challengeDiv = document.createElement('div');
                challengeDiv.className = 'challenge-card';
                
                if (challenge.completed) {
                    challengeDiv.classList.add('completed');
                }
                
                const progress = Math.min(challenge.progress, challenge.target);
                const progressPercent = (progress / challenge.target) * 100;
                
                challengeDiv.innerHTML = `
                    <div class="challenge-title">${challenge.description}</div>
                    <div class="challenge-description">Progresso: ${progress}/${challenge.target}</div>
                    <div class="challenge-progress">
                        <div class="challenge-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="challenge-reward">
                        Recompensa: ${formatReward(challenge.reward)}
                    </div>
                `;
                
                container.appendChild(challengeDiv);
            });
        }
        
        function checkDailyReset() {
            const today = new Date().toDateString();
            if (lastDailyReset !== today) {
                resetDailyChallenges();
                lastDailyReset = today;
                localStorage.setItem('waveslayers_last_daily_reset', lastDailyReset);
            }
        }
        
        function resetDailyChallenges() {
            const challengeTemplates = [
                { type: 'kills', targets: [10, 25, 50], rewards: [{ coins: 100, xp: 200 }, { coins: 250, xp: 500 }, { coins: 500, xp: 1000 }], descriptions: ['Destrua {target} inimigos', 'Destrua {target} inimigos', 'Destrua {target} inimigos'] },
                { type: 'score', targets: [2000, 5000, 15000], rewards: [{ coins: 150, xp: 300 }, { coins: 400, xp: 800 }, { coins: 800, xp: 1600 }], descriptions: ['Atinja {target} pontos', 'Atinja {target} pontos', 'Atinja {target} pontos'] },
                { type: 'survival', targets: [60, 180, 420], rewards: [{ coins: 200, xp: 400 }, { coins: 500, xp: 1000 }, { coins: 1000, xp: 2000 }], descriptions: ['Sobreviva {target} segundos', 'Sobreviva {target} segundos', 'Sobreviva {target} segundos'] },
                { type: 'coins', targets: [50, 150, 300], rewards: [{ coins: 75, xp: 150, gems: 5 }, { coins: 200, xp: 400, gems: 15 }, { coins: 400, xp: 800, gems: 30 }], descriptions: ['Colete {target} moedas', 'Colete {target} moedas', 'Colete {target} moedas'] },
                { type: 'powerups', targets: [5, 15, 30], rewards: [{ coins: 100, xp: 200, gems: 5 }, { coins: 300, xp: 600, gems: 20 }, { coins: 600, xp: 1200, gems: 40 }], descriptions: ['Colete {target} power-ups', 'Colete {target} power-ups', 'Colete {target} power-ups'] }
            ];
            
            dailyChallenges = {};
            const selectedTypes = [];
            let challengeCount = 0;
            
            // Gerar 3 desafios √∫nicos
            while (challengeCount < 3 && selectedTypes.length < challengeTemplates.length) {
                const template = challengeTemplates[Math.floor(Math.random() * challengeTemplates.length)];
                if (!selectedTypes.includes(template.type)) {
                    const difficulty = Math.floor(Math.random() * 3); // 0=f√°cil, 1=m√©dio, 2=dif√≠cil
                    const challengeId = `daily_${template.type}_${Date.now()}_${challengeCount}`;
                    
                    dailyChallenges[challengeId] = {
                        id: challengeId,
                        type: template.type,
                        target: template.targets[difficulty],
                        reward: template.rewards[difficulty],
                        description: template.descriptions[difficulty].replace('{target}', template.targets[difficulty]),
                        progress: 0,
                        completed: false,
                        difficulty: difficulty
                    };
                    
                    selectedTypes.push(template.type);
                    challengeCount++;
                }
            }
            
            saveProgressionData();
        }
        
        function updateAchievementsDisplay() {
            const unlockedCount = Object.keys(achievements).length;
            const totalCount = achievementsList.length;
            const achievementPoints = Object.values(achievements).reduce((total, ach) => total + (ach.points || 0), 0);
            
            document.getElementById('achievementsUnlocked').textContent = unlockedCount;
            document.getElementById('achievementsTotal').textContent = totalCount;
            document.getElementById('achievementPoints').textContent = achievementPoints;
        }
        
        function renderAchievements() {
            const container = document.getElementById('achievementsGrid');
            container.innerHTML = '';
            
            achievementsList.forEach(achievement => {
                const achievementDiv = document.createElement('div');
                achievementDiv.className = 'achievement-card';
                
                const isUnlocked = achievements[achievement.id];
                const progress = achievementProgress[achievement.id] || 0;
                const progressPercent = Math.min((progress / achievement.target) * 100, 100);
                
                if (isUnlocked) {
                    achievementDiv.classList.add('unlocked');
                } else if (progress === 0) {
                    achievementDiv.classList.add('hidden');
                }
                
                achievementDiv.innerHTML = `
                    <div class="achievement-icon">${achievement.icon}</div>
                    <div class="achievement-name">${achievement.name}</div>
                    <div class="achievement-description">${achievement.description}</div>
                    <div class="achievement-progress">
                        <div class="achievement-progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                    <div style="text-align: center; margin: 10px 0; color: #ccc; font-size: 0.9em;">
                        ${progress}/${achievement.target}
                    </div>
                    <div class="achievement-reward">
                        ${isUnlocked ? '‚úì DESBLOQUEADO' : `Recompensa: ${formatReward(achievement.reward)}`}
                    </div>
                `;
                
                container.appendChild(achievementDiv);
            });
        }
        
        function updateBattlepassDisplay() {
            document.getElementById('battlepassLevelDisplay').textContent = battlePassLevel;
            document.getElementById('battlepassStatus').textContent = battlePassPremium ? 'PREMIUM' : 'GR√ÅTIS';
            
            if (battlePassLevel < 50) {
                const currentTier = battlePassTiers[battlePassLevel];
                const xpProgress = battlePassXP - (battlePassLevel * 1000);
                const xpNeeded = currentTier.xpRequired;
                const xpPercentage = (xpProgress / xpNeeded) * 100;
                
                document.getElementById('battlepassXpFill').style.width = xpPercentage + '%';
                document.getElementById('battlepassXpText').textContent = `${xpProgress} / ${xpNeeded}`;
            } else {
                document.getElementById('battlepassXpFill').style.width = '100%';
                document.getElementById('battlepassXpText').textContent = 'MAX LEVEL';
            }
        }
        
        function renderBattlepassTiers() {
            const container = document.getElementById('battlepassTiers');
            container.innerHTML = '';
            
            battlePassTiers.forEach((tier, index) => {
                const tierDiv = document.createElement('div');
                tierDiv.className = 'battlepass-tier';
                
                if (battlePassLevel > index) {
                    tierDiv.classList.add('unlocked');
                } else if (battlePassLevel === index) {
                    tierDiv.classList.add('current');
                }
                
                tierDiv.innerHTML = `
                    <div class="tier-info">
                        <div class="tier-level">${tier.level}</div>
                        <div class="tier-rewards">
                            <div class="reward-item free">
                                <div>GR√ÅTIS</div>
                                <div>${formatReward(tier.freeReward)}</div>
                            </div>
                            <div class="reward-item premium">
                                <div>PREMIUM</div>
                                <div>${formatReward(tier.premiumReward)}</div>
                            </div>
                        </div>
                    </div>
                `;
                
                container.appendChild(tierDiv);
            });
        }
        
        function upgradeBattlepass() {
            if (!battlePassPremium && gems >= 500) {
                gems -= 500;
                battlePassPremium = true;
                showNotification('üéØ Battle Pass Premium ativado!', '#ffaa00');
                saveProgressionData();
                updateBattlepassDisplay();
            } else if (!battlePassPremium) {
                showNotification('Voc√™ precisa de 500 gemas para o Battle Pass Premium', '#ff4444');
            }
        }
        
        function formatReward(reward) {
            const parts = [];
            if (reward.coins) parts.push(`${reward.coins}üí∞`);
            if (reward.xp) parts.push(`${reward.xp}‚ú®`);
            if (reward.gems) parts.push(`${reward.gems}üíé`);
            if (reward.darkMatter) parts.push(`${reward.darkMatter}üåå`);
            return parts.join(' ');
        }
        
        function saveProgressionData() {
            localStorage.setItem('waveslayers_player_level', playerLevel.toString());
            localStorage.setItem('waveslayers_player_xp', playerXP.toString());
            localStorage.setItem('waveslayers_skill_points', skillPoints.toString());
            localStorage.setItem('waveslayers_gems', gems.toString());
            localStorage.setItem('waveslayers_dark_matter', darkMatter.toString());
            localStorage.setItem('waveslayers_skills', JSON.stringify(skillTree));
            localStorage.setItem('waveslayers_achievements', JSON.stringify(achievements));
            localStorage.setItem('waveslayers_achievement_progress', JSON.stringify(achievementProgress));
            localStorage.setItem('waveslayers_daily_challenges', JSON.stringify(dailyChallenges));
            localStorage.setItem('waveslayers_battlepass_level', battlePassLevel.toString());
            localStorage.setItem('waveslayers_battlepass_xp', battlePassXP.toString());
            localStorage.setItem('waveslayers_battlepass_premium', battlePassPremium.toString());
        }
        
        function checkAchievements() {
            achievementsList.forEach(achievement => {
                if (achievements[achievement.id]) return; // Already unlocked
                
                let currentProgress = 0;
                
                switch (achievement.type) {
                    case 'kills':
                        currentProgress = achievementProgress.totalKills || 0;
                        break;
                    case 'score':
                        currentProgress = achievementProgress.highScore || 0;
                        break;
                    case 'survival':
                        currentProgress = achievementProgress.longestSurvival || 0;
                        break;
                    case 'coins_collected':
                        currentProgress = achievementProgress.totalCoinsCollected || 0;
                        break;
                    case 'worlds_unlocked':
                        currentProgress = achievementProgress.worldsUnlocked || 0;
                        break;
                    case 'powerups_collected':
                        currentProgress = achievementProgress.powerupsCollected || 0;
                        break;
                }
                
                achievementProgress[achievement.id] = currentProgress;
                
                if (currentProgress >= achievement.target) {
                    unlockAchievement(achievement);
                }
            });
        }
        
        function unlockAchievement(achievement) {
            achievements[achievement.id] = {
                unlockedAt: Date.now(),
                points: 10 + (achievement.target > 1000 ? 20 : 0)
            };
            
            // Give rewards
            if (achievement.reward.coins) {
                coins += achievement.reward.coins;
            }
            if (achievement.reward.xp) {
                addXP(achievement.reward.xp);
            }
            if (achievement.reward.gems) {
                gems += achievement.reward.gems;
            }
            if (achievement.reward.darkMatter) {
                darkMatter += achievement.reward.darkMatter;
            }
            
            showNotification(`üèÜ Conquista desbloqueada: ${achievement.name}`, '#ffaa00');
            
            saveProgressionData();
        }
        
        function updateChallenges(type, amount = 1) {
            Object.values(dailyChallenges).forEach(challenge => {
                if (challenge.type === type && !challenge.completed) {
                    challenge.progress += amount;
                    
                    if (challenge.progress >= challenge.target) {
                        challenge.completed = true;
                        
                        // Give rewards
                        if (challenge.reward.coins) {
                            coins += challenge.reward.coins;
                        }
                        if (challenge.reward.xp) {
                            addXP(challenge.reward.xp);
                        }
                        if (challenge.reward.gems) {
                            gems += challenge.reward.gems;
                        }
                        
                        showNotification(`‚úÖ Desafio Conclu√≠do: ${challenge.description}`, '#00ff00');
                    }
                }
            });
            
            saveProgressionData();
        }
        
        function showNotification(message, color = '#ffffff') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                color: ${color};
                padding: 15px 25px;
                border-radius: 10px;
                border: 2px solid ${color};
                font-family: 'Orbitron', monospace;
                font-weight: bold;
                z-index: 1000;
                transform: translateX(400px);
                transition: transform 0.5s ease;
                box-shadow: 0 0 20px ${color}50;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Animate out and remove
            setTimeout(() => {
                notification.style.transform = 'translateX(400px)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 500);
            }, 3000);
        }
        
        // Initialize game
        function init() {
            player = new Player();
            
            // Create stars
            for (let i = 0; i < 120; i++) {
                stars.push(new Star());
            }
            
            // Initialize menu animation
            initMenuAnimation();
            
            // Event listeners
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if ((e.key === 'p' || e.key === 'P') && gameState === 'playing') {
                    isPaused = !isPaused;
                }
                e.preventDefault();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            updateCoinsDisplay();
            
            // Initialize progression system
            checkDailyReset();
            
            // Initialize ship customization system
            // Ensure current ship is unlocked
            if (!unlockedShips.includes(currentShipId)) {
                currentShipId = 'interceptor';
                localStorage.setItem('waveslayers_current_ship', currentShipId);
            }
            
            // Ensure current skin is unlocked
            if (!unlockedSkins.includes(currentSkinId)) {
                currentSkinId = 'default';
                localStorage.setItem('waveslayers_current_skin', currentSkinId);
            }
            
            // Ensure current effect is unlocked
            if (!unlockedEffects.includes(currentEffectId)) {
                currentEffectId = 'none';
                localStorage.setItem('waveslayers_current_effect', currentEffectId);
            }
            
            // Load achievement progress if not exists
            if (!achievementProgress.totalKills) {
                achievementProgress = {
                    totalKills: 0,
                    highScore: 0,
                    longestSurvival: 0,
                    totalCoinsCollected: 0,
                    worldsUnlocked: 1,
                    powerupsCollected: 0
                };
            }
        }
        
        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            // Update and draw stars
            stars.forEach(star => {
                star.update();
                star.draw();
            });
            
            if (gameState === 'playing' && gameRunning && !isPaused) {
                // Track player behavior for AI learning
                trackPlayerBehavior();
                saveAILearningData();
                
                // Update player
                player.update(deltaTime);
                
                // Spawn enemies using intelligent system
                enemySpawnTimer += deltaTime;
                const world = worlds[currentWorldId];
                const spawnRate = Math.max(300, 1500 - level * 80) / world.difficulty;
                if (enemySpawnTimer > spawnRate) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }
                
                // Update bullets
                bullets = bullets.filter(bullet => {
                    bullet.update();
                    bullet.draw();
                    return !bullet.isOffScreen();
                });
                
                enemyBullets = enemyBullets.filter(bullet => {
                    bullet.update();
                    bullet.draw();
                    return !bullet.isOffScreen();
                });
                
                // Update enemies with AI behaviors
                enemies = enemies.filter(enemy => {
                    enemy.update(deltaTime);
                    enemy.draw();
                    return !enemy.isOffScreen();
                });
                
                // Update particles
                particles = particles.filter(particle => {
                    particle.update(deltaTime);
                    particle.draw();
                    return !particle.isDead();
                });
                
                // Update powerups
                powerups = powerups.filter(powerup => {
                    powerup.update();
                    powerup.draw();
                    return !powerup.isOffScreen();
                });
                
                // Check collisions
                checkCollisions();
                
                // Draw player
                player.draw();
                
                // Update level
                const newLevel = Math.floor(score / 750) + 1;
                if (newLevel > level) {
                    level = newLevel;
                }
                
                // Update survival time for achievements
                survivalTime = (Date.now() - gameStartTime) / 1000;
                achievementProgress.bestSurvivalTime = Math.max(achievementProgress.bestSurvivalTime || 0, survivalTime);
                
                // Update UI
                updateUI();
            } else if (gameState === 'playing' && isPaused) {
                // Draw game elements but don't update
                bullets.forEach(bullet => bullet.draw());
                enemyBullets.forEach(bullet => bullet.draw());
                enemies.forEach(enemy => enemy.draw());
                particles.forEach(particle => particle.draw());
                powerups.forEach(powerup => powerup.draw());
                player.draw();
                
                // Draw pause overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ffff';
                ctx.font = '48px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSADO', canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Orbitron';
                ctx.fillText('Pressione P para continuar', canvas.width / 2, canvas.height / 2 + 50);
                ctx.textAlign = 'start';
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start game
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>