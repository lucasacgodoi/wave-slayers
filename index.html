<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WaveSlayers - Space Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a0033 50%, #000d1a 100%);
            color: #fff;
            font-family: 'Orbitron', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 15px;
            background: linear-gradient(180deg, #000428 0%, #004e92 100%);
            box-shadow: 0 0 30px #00ffff;
        }
        
        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border-radius: 12px;
        }
        
        /* Menu Principal */
        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 12px;
        }
        
        #menuBackground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 30, 0.3);
            z-index: 1;
            border-radius: 12px;
        }
        
        .menu-content {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #mainMenu h1 {
            font-size: 4em;
            font-weight: 900;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0,255,255,0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 10px #00ffff); }
            to { filter: drop-shadow(0 0 30px #ff00ff); }
        }
        
        .menu-button {
            background: linear-gradient(45deg, #00ffff, #0099cc);
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-family: 'Orbitron', monospace;
            font-size: 18px;
            font-weight: 700;
            color: #000;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 5px 15px rgba(0,255,255,0.3);
            min-width: 200px;
        }
        
        .menu-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,255,255,0.5);
            background: linear-gradient(45deg, #ff00ff, #cc0099);
        }
        
        /* Menu de Mundos */
        #worldsMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,20,40,0.95) 0%, rgba(40,0,60,0.95) 100%);
            display: none;
            flex-direction: column;
            z-index: 99;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
        }
        
        .worlds-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .worlds-header h2 {
            font-size: 2.5em;
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .coins-display {
            font-size: 1.3em;
            color: #ffff00;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .worlds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .world-card {
            background: linear-gradient(135deg, rgba(0,50,100,0.8) 0%, rgba(50,0,100,0.8) 100%);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .world-card.unlocked {
            border-color: #00ffff;
            box-shadow: 0 0 15px rgba(0,255,255,0.3);
        }
        
        .world-card.locked {
            border-color: #666;
            opacity: 0.6;
        }
        
        .world-card:hover.unlocked {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(0,255,255,0.5);
        }
        
        .world-preview {
            width: 100%;
            height: 120px;
            background: #222;
            border-radius: 10px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .world-name {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 10px;
            color: #00ffff;
        }
        
        .world-description {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        
        .world-price {
            background: linear-gradient(45deg, #ffff00, #ff8800);
            color: #000;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 700;
            display: inline-block;
            margin-bottom: 10px;
        }
        
        .world-action {
            background: linear-gradient(45deg, #00ff00, #00cc00);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #000;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .world-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,255,0,0.3);
        }
        
        .world-action:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }
        
        .back-button {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: center;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,0,0,0.3);
        }
        
        /* Interface do Jogo */
        #gameUI {
            position: absolute;
            top: 15px;
            left: 15px;
            font-size: 16px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
            display: none;
        }
        
        .ui-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 20px;
        }
        
        .health-bar-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .health-bar {
            width: 150px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s ease;
            border-radius: 8px;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 15px;
            border: 1px solid #00ffff;
        }
        
        .stat-icon {
            width: 16px;
            height: 16px;
            background: #ffff00;
            border-radius: 50%;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border: 3px solid #ff0000;
            border-radius: 20px;
            display: none;
            z-index: 20;
        }
        
        #gameOver h2 {
            color: #ff0000;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff0000;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #888;
            text-align: center;
            display: none;
        }
        
        .world-select-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(45deg, #9400d3, #4b0082);
            border: none;
            padding: 10px 15px;
            border-radius: 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 15;
            display: none;
        }
        
        .world-select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(148,0,211,0.3);
        }

        /* Loading screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0,0,50,0.95) 0%, rgba(20,0,50,0.95) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            border-radius: 12px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #333;
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 1.5em;
            color: #00ffff;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        
        <!-- Menu Principal -->
        <div id="mainMenu">
            <canvas id="menuBackground" width="900" height="600"></canvas>
            <div class="menu-overlay"></div>
            <div class="menu-content">
                <h1>WAVESLAYERS</h1>
                <p style="font-size: 1.2em; color: #ccc; margin-bottom: 40px;">Conquiste as Galáxias</p>
                <button class="menu-button" onclick="startGame()">🚀 Iniciar Jogo</button>
                <button class="menu-button" onclick="openWorldsMenu()">🌍 Mundos</button>
                <button class="menu-button" onclick="showInstructions()">📋 Controles</button>
            </div>
        </div>
        
        <!-- Menu de Mundos -->
        <div id="worldsMenu">
            <div class="worlds-header">
                <h2>MUNDOS DISPONÍVEIS</h2>
                <div class="coins-display">
                    <div class="stat-icon"></div>
                    <span id="coinsAmount">0</span> Moedas
                </div>
            </div>
            <div class="worlds-grid" id="worldsGrid">
                <!-- Mundos serão inseridos aqui dinamicamente -->
            </div>
            <button class="back-button" onclick="closeWorldsMenu()">← Voltar ao Menu</button>
        </div>

        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div class="loading-spinner"></div>
            <div class="loading-text">
                <div id="loadingMessage">Carregando mundo...</div>
            </div>
        </div>
        
        <!-- Interface do Jogo -->
        <div id="gameUI">
            <div class="ui-row">
                <div class="health-bar-container">
                    <span>VIDA:</span>
                    <div class="health-bar">
                        <div class="health-fill" id="healthFill"></div>
                        <div class="health-text" id="healthText">100/100</div>
                    </div>
                </div>
                <div class="stat-item">
                    <div class="stat-icon"></div>
                    <span id="coinsUI">0</span>
                </div>
            </div>
            <div class="ui-row">
                <div class="stat-item">
                    <span>PONTOS: <span id="score">0</span></span>
                </div>
                <div class="stat-item">
                    <span>NÍVEL: <span id="level">1</span></span>
                </div>
                <div class="stat-item">
                    <span>MUNDO: <span id="currentWorldName">Terra</span></span>
                </div>
            </div>
        </div>
        
        <button class="world-select-btn" id="worldSelectBtn" onclick="openWorldsMenu()">🌍 Mundos</button>
        
        <div id="gameOver">
            <h2>MISSÃO FALHOU</h2>
            <p style="font-size: 1.2em; margin-bottom: 20px;">Pontuação Final: <span id="finalScore">0</span></p>
            <p style="font-size: 1em; color: #ffff00; margin-bottom: 20px;">Moedas Coletadas: <span id="coinsEarned">0</span></p>
            <button class="menu-button" onclick="restartGame()">🔄 Tentar Novamente</button>
            <button class="menu-button" onclick="goToMainMenu()">🏠 Menu Principal</button>
        </div>
        
        <div id="instructions">
            Use WASD ou setas para mover • ESPAÇO para atirar • P para pausar
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameOver'
        let gameRunning = false;
        let isPaused = false;
        let score = 0;
        let level = 1;
        let lastTime = 0;
        let coins = parseInt(localStorage.getItem('waveslayers_coins') || '100');
        let coinsThisRound = 0;
        let currentWorldId = localStorage.getItem('waveslayers_current_world') || 'earth';
        
        // Menu animation objects
        let menuStars = [];
        let menuShips = [];
        let menuBullets = [];
        let menuExplosions = [];
        let menuAnimationRunning = false;
        
        // Menu Ship class
        class MenuShip {
            constructor(x, y, type, team, target = null) {
                this.x = x;
                this.y = y;
                this.type = type; // 'player', 'enemy'
                this.team = team;
                this.target = target;
                this.width = type === 'player' ? 20 : 24;
                this.height = type === 'player' ? 20 : 24;
                this.speed = 2 + Math.random() * 2;
                this.angle = Math.random() * Math.PI * 2;
                this.health = 100;
                this.maxHealth = 100;
                this.shootTimer = Math.random() * 1000;
                this.behavior = Math.random() < 0.5 ? 'patrol' : 'chase';
                this.patrolTarget = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                };
                this.life = 8000 + Math.random() * 5000; // Life span
                this.maxLife = this.life;
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.shootTimer -= deltaTime;
                
                // Find nearest enemy
                if (this.behavior === 'chase' && !this.target) {
                    let nearestEnemy = null;
                    let nearestDistance = Infinity;
                    
                    menuShips.forEach(ship => {
                        if (ship.team !== this.team && ship.health > 0) {
                            const dist = Math.hypot(ship.x - this.x, ship.y - this.y);
                            if (dist < nearestDistance && dist < 200) {
                                nearestDistance = dist;
                                nearestEnemy = ship;
                            }
                        }
                    });
                    
                    this.target = nearestEnemy;
                }
                
                // Movement AI
                let targetX, targetY;
                
                if (this.behavior === 'chase' && this.target && this.target.health > 0) {
                    targetX = this.target.x;
                    targetY = this.target.y;
                } else {
                    // Patrol behavior
                    const distToPatrol = Math.hypot(this.patrolTarget.x - this.x, this.patrolTarget.y - this.y);
                    if (distToPatrol < 50) {
                        this.patrolTarget = {
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height
                        };
                    }
                    targetX = this.patrolTarget.x;
                    targetY = this.patrolTarget.y;
                }
                
                // Move towards target
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.hypot(dx, dy);
                
                if (distance > 0) {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                    this.angle = Math.atan2(dy, dx);
                }
                
                // Keep in bounds with wrapping
                if (this.x < -50) this.x = canvas.width + 50;
                if (this.x > canvas.width + 50) this.x = -50;
                if (this.y < -50) this.y = canvas.height + 50;
                if (this.y > canvas.height + 50) this.y = -50;
                
                // Shooting
                if (this.shootTimer <= 0 && this.target && this.target.health > 0) {
                    const distToTarget = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                    if (distToTarget < 150) {
                        this.shoot();
                        this.shootTimer = 800 + Math.random() * 1200;
                    }
                }
            }
            
            shoot() {
                const bulletSpeed = 6;
                const bulletX = this.x + Math.cos(this.angle) * this.width;
                const bulletY = this.y + Math.sin(this.angle) * this.height;
                const vx = Math.cos(this.angle) * bulletSpeed;
                const vy = Math.sin(this.angle) * bulletSpeed;
                
                menuBullets.push(new MenuBullet(bulletX, bulletY, vx, vy, this.team, this.type));
            }
            
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.explode();
                    return true;
                }
                return false;
            }
            
            explode() {
                menuExplosions.push(new MenuExplosion(this.x, this.y));
            }
            
            draw(ctx) {
                if (this.health <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                if (this.type === 'player') {
                    this.drawPlayerShip(ctx);
                } else {
                    this.drawEnemyShip(ctx);
                }
                
                ctx.restore();
            }
            
            drawPlayerShip(ctx) {
                // Blue player ship
                ctx.fillStyle = '#00aaff';
                ctx.fillRect(-10, -6, 20, 4);
                ctx.fillRect(-8, -4, 16, 8);
                ctx.fillRect(-6, -8, 12, 4);
                ctx.fillRect(-6, 4, 12, 4);
                
                ctx.fillStyle = '#0088cc';
                ctx.fillRect(-4, -2, 8, 4);
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(6, -1, 4, 2);
            }
            
            drawEnemyShip(ctx) {
                // Red enemy ship
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(-12, -8, 24, 6);
                ctx.fillRect(-10, -6, 20, 12);
                ctx.fillRect(-8, -10, 16, 6);
                ctx.fillRect(-8, 4, 16, 6);
                
                ctx.fillStyle = '#cc0000';
                ctx.fillRect(-6, -4, 12, 8);
                
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(8, -2, 4, 4);
            }
            
            isDead() {
                return this.health <= 0 || this.life <= 0;
            }
        }
        
        // Menu Bullet class
        class MenuBullet {
            constructor(x, y, vx, vy, team, shipType) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.team = team;
                this.shipType = shipType;
                this.width = 4;
                this.height = 2;
                this.life = 2000;
                this.damage = 25;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
            }
            
            draw(ctx) {
                ctx.fillStyle = this.shipType === 'player' ? '#ffff00' : '#ff6666';
                ctx.fillRect(this.x - 2, this.y - 1, this.width, this.height);
                
                // Glow effect
                ctx.shadowColor = this.shipType === 'player' ? '#ffff00' : '#ff6666';
                ctx.shadowBlur = 3;
                ctx.fillRect(this.x - 2, this.y - 1, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.x < -10 || this.x > canvas.width + 10 || 
                       this.y < -10 || this.y > canvas.height + 10 || 
                       this.life <= 0;
            }
        }
        
        // Menu Explosion class
        class MenuExplosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.particles = [];
                
                for (let i = 0; i < 12; i++) {
                    const angle = (Math.PI * 2 * i) / 12;
                    const speed = 2 + Math.random() * 4;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 800 + Math.random() * 400,
                        maxLife: 800 + Math.random() * 400,
                        size: 2 + Math.random() * 3,
                        color: Math.random() < 0.5 ? '#ff6600' : '#ffaa00'
                    });
                }
            }
            
            update(deltaTime) {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life -= deltaTime;
                    particle.vy += 0.05; // gravity
                    return particle.life > 0;
                });
            }
            
            draw(ctx) {
                this.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = particle.color;
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                });
                ctx.globalAlpha = 1;
            }
            
            isDead() {
                return this.particles.length === 0;
            }
        }
        
        // Menu Star class
        class MenuStar {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 1 + 0.3;
                this.size = Math.random() * 2 + 0.5;
                this.brightness = Math.random() * 0.8 + 0.2;
                this.twinkle = Math.random() * Math.PI * 2;
            }
            
            update(deltaTime) {
                this.y += this.speed;
                this.twinkle += 0.02;
                
                if (this.y > canvas.height + 10) {
                    this.y = -10;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            draw(ctx) {
                const twinkleBrightness = this.brightness + Math.sin(this.twinkle) * 0.3;
                ctx.globalAlpha = Math.max(0.1, twinkleBrightness);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        function initMenuAnimation() {
            const menuCanvas = document.getElementById('menuBackground');
            if (!menuCanvas) return;
            
            // Create background stars
            menuStars = [];
            for (let i = 0; i < 80; i++) {
                menuStars.push(new MenuStar());
            }
            
            // Create initial ships
            menuShips = [];
            menuBullets = [];
            menuExplosions = [];
            
            spawnMenuShips();
            menuAnimationRunning = true;
        }
        
        function spawnMenuShips() {
            // Spawn player ships
            for (let i = 0; i < 3; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                menuShips.push(new MenuShip(x, y, 'player', 'player'));
            }
            
            // Spawn enemy ships
            for (let i = 0; i < 4; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                menuShips.push(new MenuShip(x, y, 'enemy', 'enemy'));
            }
        }
        
        function updateMenuAnimation(deltaTime) {
            if (!menuAnimationRunning) return;
            
            const menuCanvas = document.getElementById('menuBackground');
            if (!menuCanvas) return;
            
            const menuCtx = menuCanvas.getContext('2d');
            
            // Clear canvas with space gradient
            const gradient = menuCtx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#000428');
            gradient.addColorStop(0.5, '#004e92');
            gradient.addColorStop(1, '#000000');
            menuCtx.fillStyle = gradient;
            menuCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw stars
            menuStars.forEach(star => {
                star.update(deltaTime);
                star.draw(menuCtx);
            });
            
            // Update ships
            menuShips = menuShips.filter(ship => {
                ship.update(deltaTime);
                ship.draw(menuCtx);
                return !ship.isDead();
            });
            
            // Update bullets
            menuBullets = menuBullets.filter(bullet => {
                bullet.update(deltaTime);
                bullet.draw(menuCtx);
                return !bullet.isOffScreen();
            });
            
            // Update explosions
            menuExplosions = menuExplosions.filter(explosion => {
                explosion.update(deltaTime);
                explosion.draw(menuCtx);
                return !explosion.isDead();
            });
            
            // Check bullet collisions
            for (let i = menuBullets.length - 1; i >= 0; i--) {
                const bullet = menuBullets[i];
                for (let j = menuShips.length - 1; j >= 0; j--) {
                    const ship = menuShips[j];
                    
                    if (ship.team !== bullet.team && ship.health > 0) {
                        const dx = bullet.x - ship.x;
                        const dy = bullet.y - ship.y;
                        const distance = Math.hypot(dx, dy);
                        
                        if (distance < ship.width / 2) {
                            menuBullets.splice(i, 1);
                            ship.takeDamage(bullet.damage);
                            break;
                        }
                    }
                }
            }
            
            // Spawn new ships periodically
            if (menuShips.length < 8 && Math.random() < 0.002) {
                const type = Math.random() < 0.4 ? 'player' : 'enemy';
                const edge = Math.floor(Math.random() * 4);
                let x, y;
                
                switch (edge) {
                    case 0: x = -30; y = Math.random() * canvas.height; break;
                    case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                    case 2: x = Math.random() * canvas.width; y = -30; break;
                    case 3: x = Math.random() * canvas.width; y = canvas.height + 30; break;
                }
                
                menuShips.push(new MenuShip(x, y, type, type));
            }
        }
        
        // Player stats
        let playerHealth = 100;
        let playerMaxHealth = 100;
        
        // Input handling
        const keys = {};
        
        // Game objects
        let player;
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let particles = [];
        let powerups = [];
        let stars = [];
        
        // Timers
        let enemySpawnTimer = 0;
        let powerupSpawnTimer = 0;
        
        // Worlds system
        const worlds = {
            earth: {
                id: 'earth',
                name: 'Terra',
                description: 'O lar da humanidade. Céus azuis e nuvens brancas.',
                price: 0,
                unlocked: true,
                colors: {
                    bg: ['#87CEEB', '#E0F6FF'],
                    stars: '#FFFFFF',
                    enemies: ['#FF6B6B', '#4ECDC4', '#45B7D1']
                },
                difficulty: 1
            },
            mars: {
                id: 'mars',
                name: 'Marte',
                description: 'O planeta vermelho. Tempestades de areia e paisagens áridas.',
                price: 250,
                unlocked: false,
                colors: {
                    bg: ['#CD5C5C', '#A0522D'],
                    stars: '#FFD700',
                    enemies: ['#FF4500', '#DC143C', '#B22222']
                },
                difficulty: 1.5
            },
            jupiter: {
                id: 'jupiter',
                name: 'Júpiter',
                description: 'Gigante gasoso. Tempestades colossais e radiação intensa.',
                price: 500,
                unlocked: false,
                colors: {
                    bg: ['#DEB887', '#F4A460'],
                    stars: '#FFA500',
                    enemies: ['#FF8C00', '#DAA520', '#B8860B']
                },
                difficulty: 2
            },
            saturn: {
                id: 'saturn',
                name: 'Saturno',
                description: 'Senhor dos anéis. Beleza hipnotizante e gravidade traiçoeira.',
                price: 750,
                unlocked: false,
                colors: {
                    bg: ['#F0E68C', '#EEE8AA'],
                    stars: '#FFFFE0',
                    enemies: ['#FFD700', '#FFA500', '#FF8C00']
                },
                difficulty: 2.5
            },
            neptune: {
                id: 'neptune',
                name: 'Netuno',
                description: 'Mundo gelado. Ventos supersônicos e mistérios profundos.',
                price: 1000,
                unlocked: false,
                colors: {
                    bg: ['#4169E1', '#000080'],
                    stars: '#ADD8E6',
                    enemies: ['#0000FF', '#4169E1', '#6495ED']
                },
                difficulty: 3
            },
            blackhole: {
                id: 'blackhole',
                name: 'Buraco Negro',
                description: 'O vazio absoluto. Onde apenas os mais corajosos se aventuram.',
                price: 2000,
                unlocked: false,
                colors: {
                    bg: ['#2F2F2F', '#000000'],
                    stars: '#800080',
                    enemies: ['#8B008B', '#4B0082', '#9400D3']
                },
                difficulty: 4
            }
        };
        
        // Load unlocked worlds
        const unlockedWorlds = JSON.parse(localStorage.getItem('waveslayers_unlocked_worlds') || '["earth"]');
        unlockedWorlds.forEach(worldId => {
            if (worlds[worldId]) {
                worlds[worldId].unlocked = true;
            }
        });
        
        // Player class
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 70;
                this.width = 24;
                this.height = 24;
                this.speed = 6;
                this.shootCooldown = 0;
                this.invulnerable = 0;
                this.powerLevel = 1;
            }
            
            update(deltaTime) {
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) this.x -= this.speed;
                if (keys['ArrowRight'] || keys['d'] || keys['D']) this.x += this.speed;
                if (keys['ArrowUp'] || keys['w'] || keys['W']) this.y -= this.speed;
                if (keys['ArrowDown'] || keys['s'] || keys['S']) this.y += this.speed;
                
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
                
                if ((keys[' '] || keys['Space']) && this.shootCooldown <= 0) {
                    this.shoot();
                    this.shootCooldown = 150;
                }
                
                if (this.shootCooldown > 0) this.shootCooldown -= deltaTime;
                if (this.invulnerable > 0) this.invulnerable -= deltaTime;
            }
            
            shoot() {
                const world = worlds[currentWorldId];
                if (this.powerLevel === 1) {
                    bullets.push(new Bullet(this.x + this.width/2 - 2, this.y, 0, -10, true));
                } else if (this.powerLevel === 2) {
                    bullets.push(new Bullet(this.x + this.width/2 - 6, this.y, 0, -10, true));
                    bullets.push(new Bullet(this.x + this.width/2 + 2, this.y, 0, -10, true));
                } else {
                    bullets.push(new Bullet(this.x + this.width/2 - 2, this.y, 0, -10, true));
                    bullets.push(new Bullet(this.x + this.width/2 - 12, this.y, -2, -10, true));
                    bullets.push(new Bullet(this.x + this.width/2 + 8, this.y, 2, -10, true));
                }
            }
            
            takeDamage(damage) {
                if (this.invulnerable <= 0) {
                    playerHealth = Math.max(0, playerHealth - damage);
                    this.invulnerable = 1500;
                    createExplosion(this.x + this.width/2, this.y + this.height/2, '#ff0000', 8);
                    
                    if (playerHealth <= 0) {
                        gameOver();
                    }
                }
            }
            
            draw() {
                const flash = this.invulnerable > 0 && Math.floor(this.invulnerable / 100) % 2;
                if (!flash) {
                    this.drawPixelSprite();
                }
            }
            
            drawPixelSprite() {
                const pixels = [
                    '      ****      ',
                    '     ******     ',
                    '    ********    ',
                    '   **********   ',
                    '  ************  ',
                    ' ************** ',
                    '****************',
                    '****************',
                    '***  ******  ***',
                    '**   ****   ***',
                    '*     **     **',
                    '      **      '
                ];
                
                const pixelSize = 2;
                for (let y = 0; y < pixels.length; y++) {
                    for (let x = 0; x < pixels[y].length; x++) {
                        if (pixels[y][x] === '*') {
                            ctx.fillStyle = '#00ccff';
                            ctx.fillRect(
                                this.x + x * pixelSize,
                                this.y + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                        }
                    }
                }
            }
        }
        
        // Bullet class
        class Bullet {
            constructor(x, y, vx, vy, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = 4;
                this.height = 8;
                this.isPlayer = isPlayer;
                this.damage = isPlayer ? 25 : 20;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
            }
            
            draw() {
                const world = worlds[currentWorldId];
                ctx.fillStyle = this.isPlayer ? '#ffff00' : world.colors.enemies[0];
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                ctx.shadowColor = this.isPlayer ? '#ffff00' : world.colors.enemies[0];
                ctx.shadowBlur = 5;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.y < -10 || this.y > canvas.height + 10 || 
                       this.x < -10 || this.x > canvas.width + 10;
            }
        }
        
        // Enemy class
        class Enemy {
            constructor(x, y, type = 1) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = type === 1 ? 20 : type === 2 ? 30 : 40;
                this.height = this.width;
                const world = worlds[currentWorldId];
                this.speed = (type === 1 ? 2 : type === 2 ? 1.5 : 1) * world.difficulty;
                this.hp = Math.ceil(type * world.difficulty * 25);
                this.maxHp = this.hp;
                this.shootTimer = Math.random() * 2000;
                this.zigzag = Math.random() * Math.PI * 2;
                this.coinValue = type * Math.ceil(world.difficulty);
            }
            
            update(deltaTime) {
                this.y += this.speed;
                this.x += Math.sin(this.zigzag) * 0.8;
                this.zigzag += 0.02;
                
                this.shootTimer -= deltaTime;
                if (this.shootTimer <= 0 && this.y > 50 && this.y < canvas.height - 100) {
                    this.shoot();
                    this.shootTimer = 1500 + Math.random() * 2000;
                }
            }
            
            shoot() {
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const speed = 4;
                
                enemyBullets.push(new Bullet(
                    this.x + this.width/2,
                    this.y + this.height,
                    (dx / dist) * speed,
                    (dy / dist) * speed,
                    false
                ));
            }
            
            takeDamage(damage) {
                this.hp -= damage;
                return this.hp <= 0;
            }
            
            draw() {
                if (this.type === 1) {
                    this.drawType1();
                } else if (this.type === 2) {
                    this.drawType2();
                } else {
                    this.drawType3();
                }
                
                if (this.hp < this.maxHp) {
                    const barWidth = this.width;
                    const barHeight = 4;
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(this.x, this.y - 10, barWidth, barHeight);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x, this.y - 10, (this.hp / this.maxHp) * barWidth, barHeight);
                }
            }
            
            drawType1() {
                const pixels = [
                    ' *** *** ',
                    '*********',
                    '**** ****',
                    ' ******* ',
                    '  *****  ',
                    '   ***   '
                ];
                const world = worlds[currentWorldId];
                this.drawPixels(pixels, world.colors.enemies[0], 2);
            }
            
            drawType2() {
                const pixels = [
                    '  *******  ',
                    ' ********* ',
                    '***********',
                    '***  *  ***',
                    '**  ***  **',
                    '*  *****  *',
                    '   *****   ',
                    '    ***    '
                ];
                const world = worlds[currentWorldId];
                this.drawPixels(pixels, world.colors.enemies[1], 2);
            }
            
            drawType3() {
                const pixels = [
                    '    *****    ',
                    '   *******   ',
                    '  *********  ',
                    ' *********** ',
                    '*************',
                    '**  *****  **',
                    '*   *****   *',
                    '    *****    ',
                    '   *******   ',
                    '    *****    '
                ];
                const world = worlds[currentWorldId];
                this.drawPixels(pixels, world.colors.enemies[2], 2);
            }
            
            drawPixels(pixels, color, pixelSize) {
                ctx.fillStyle = color;
                for (let y = 0; y < pixels.length; y++) {
                    for (let x = 0; x < pixels[y].length; x++) {
                        if (pixels[y][x] === '*') {
                            ctx.fillRect(
                                this.x + x * pixelSize,
                                this.y + y * pixelSize,
                                pixelSize,
                                pixelSize
                            );
                        }
                    }
                }
            }
            
            isOffScreen() {
                return this.y > canvas.height + 50;
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 4 + 2;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
                this.vy += 0.1;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
            
            isDead() {
                return this.life <= 0;
            }
        }
        
        // Star background
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.speed = Math.random() * 3 + 0.5;
                this.size = Math.random() * 2 + 1;
                this.brightness = Math.random();
            }
            
            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = -10;
                    this.x = Math.random() * canvas.width;
                }
            }
            
            draw() {
                const world = worlds[currentWorldId];
                ctx.globalAlpha = this.brightness;
                ctx.fillStyle = world.colors.stars;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        
        // Powerup class
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 16;
                this.height = 16;
                this.speed = 2;
                this.bob = 0;
            }
            
            update() {
                this.y += this.speed;
                this.bob += 0.1;
            }
            
            draw() {
                const offsetY = Math.sin(this.bob) * 3;
                let color = this.type === 'weapon' ? '#00ff00' : 
                           this.type === 'health' ? '#ff00ff' : '#00ffff';
                
                ctx.fillStyle = color;
                ctx.fillRect(this.x, this.y + offsetY, this.width, this.height);
                
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
                ctx.fillRect(this.x, this.y + offsetY, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.y > canvas.height + 20;
            }
        }
        
        // Game functions
        function createExplosion(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const speed = Math.random() * 5 + 2;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    color,
                    500 + Math.random() * 500
                ));
            }
        }
        
        function spawnEnemy() {
            const world = worlds[currentWorldId];
            const rand = Math.random();
            const type = rand < 0.6 ? 1 : rand < 0.8 ? 2 : 3;
            const enemy = new Enemy(
                Math.random() * (canvas.width - 50) + 25,
                -50,
                type
            );
            enemies.push(enemy);
        }
        
        function spawnPowerup(x, y) {
            if (Math.random() < 0.25) {
                const types = ['weapon', 'health'];
                const type = types[Math.floor(Math.random() * types.length)];
                powerups.push(new Powerup(x - 8, y - 8, type));
            }
        }
        
        function checkCollisions() {
            // Player bullets vs enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    if (bullet.x < enemy.x + enemy.width &&
                        bullet.x + bullet.width > enemy.x &&
                        bullet.y < enemy.y + enemy.height &&
                        bullet.y + bullet.height > enemy.y) {
                        
                        bullets.splice(i, 1);
                        
                        if (enemy.takeDamage(bullet.damage)) {
                            const world = worlds[currentWorldId];
                            createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, world.colors.enemies[0]);
                            score += enemy.type * 10 * Math.ceil(world.difficulty);
                            coins += enemy.coinValue;
                            coinsThisRound += enemy.coinValue;
                            spawnPowerup(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
            
            // Enemy bullets vs player
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                if (bullet.x < player.x + player.width &&
                    bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height &&
                    bullet.y + bullet.height > player.y) {
                    
                    enemyBullets.splice(i, 1);
                    player.takeDamage(bullet.damage);
                }
            }
            
            // Enemies vs player
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (player.x < enemy.x + enemy.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + enemy.height &&
                    player.y + player.height > enemy.y) {
                    
                    const world = worlds[currentWorldId];
                    createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, world.colors.enemies[0]);
                    enemies.splice(i, 1);
                    player.takeDamage(40);
                }
            }
            
            // Player vs powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                if (player.x < powerup.x + powerup.width &&
                    player.x + player.width > powerup.x &&
                    player.y < powerup.y + powerup.height &&
                    player.y + player.height > powerup.y) {
                    
                    collectPowerup(powerup.type);
                    powerups.splice(i, 1);
                }
            }
        }
        
        function collectPowerup(type) {
            if (type === 'weapon') {
                player.powerLevel = Math.min(3, player.powerLevel + 1);
            } else if (type === 'health') {
                playerHealth = Math.min(playerMaxHealth, playerHealth + 30);
            }
        }
        
        function updateHealthBar() {
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercentage + '%';
            document.getElementById('healthText').textContent = `${playerHealth}/${playerMaxHealth}`;
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('coinsUI').textContent = coins;
            document.getElementById('currentWorldName').textContent = worlds[currentWorldId].name;
            updateHealthBar();
        }
        
        function drawBackground() {
            const world = worlds[currentWorldId];
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, world.colors.bg[0]);
            gradient.addColorStop(1, world.colors.bg[1]);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        function gameOver() {
            gameRunning = false;
            gameState = 'gameOver';
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('coinsEarned').textContent = coinsThisRound;
            saveGameData();
        }
        
        function saveGameData() {
            localStorage.setItem('waveslayers_coins', coins.toString());
            localStorage.setItem('waveslayers_current_world', currentWorldId);
            const unlockedWorldIds = Object.keys(worlds).filter(id => worlds[id].unlocked);
            localStorage.setItem('waveslayers_unlocked_worlds', JSON.stringify(unlockedWorldIds));
        }
        
        function startGame() {
            gameState = 'playing';
            gameRunning = true;
            isPaused = false;
            score = 0;
            level = 1;
            playerHealth = playerMaxHealth;
            coinsThisRound = 0;
            
            player = new Player();
            bullets = [];
            enemies = [];
            enemyBullets = [];
            particles = [];
            powerups = [];
            
            enemySpawnTimer = 0;
            powerupSpawnTimer = 0;
            
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('worldSelectBtn').style.display = 'block';
            document.getElementById('gameOver').style.display = 'none';
            
            // Stop menu animation
            menuAnimationRunning = false;
        }
        
        function restartGame() {
            startGame();
        }
        
        function goToMainMenu() {
            gameState = 'menu';
            gameRunning = false;
            document.getElementById('mainMenu').style.display = 'flex';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('worldSelectBtn').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('worldsMenu').style.display = 'none';
            
            // Start menu animation
            initMenuAnimation();
        }
        
        function openWorldsMenu() {
            document.getElementById('worldsMenu').style.display = 'flex';
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('worldSelectBtn').style.display = 'none';
            updateCoinsDisplay();
            renderWorldsGrid();
            
            // Stop menu animation
            menuAnimationRunning = false;
        }
        
        function closeWorldsMenu() {
            document.getElementById('worldsMenu').style.display = 'none';
            if (gameState === 'playing') {
                document.getElementById('gameUI').style.display = 'block';
                document.getElementById('worldSelectBtn').style.display = 'block';
            } else {
                document.getElementById('mainMenu').style.display = 'flex';
                // Restart menu animation
                initMenuAnimation();
            }
        }
        
        function updateCoinsDisplay() {
            document.getElementById('coinsAmount').textContent = coins;
        }
        
        function renderWorldsGrid() {
            const grid = document.getElementById('worldsGrid');
            grid.innerHTML = '';
            
            Object.values(worlds).forEach(world => {
                const card = document.createElement('div');
                card.className = `world-card ${world.unlocked ? 'unlocked' : 'locked'}`;
                
                const preview = document.createElement('div');
                preview.className = 'world-preview';
                preview.style.background = `linear-gradient(135deg, ${world.colors.bg[0]}, ${world.colors.bg[1]})`;
                
                // Add some stars to preview
                for (let i = 0; i < 8; i++) {
                    const star = document.createElement('div');
                    star.style.position = 'absolute';
                    star.style.width = '2px';
                    star.style.height = '2px';
                    star.style.background = world.colors.stars;
                    star.style.left = Math.random() * 100 + '%';
                    star.style.top = Math.random() * 100 + '%';
                    preview.appendChild(star);
                }
                
                card.innerHTML = `
                    <div class="world-name">${world.name}</div>
                    <div class="world-description">${world.description}</div>
                    ${!world.unlocked ? `<div class="world-price">💰 ${world.price} Moedas</div>` : ''}
                    <button class="world-action" 
                            ${!world.unlocked && coins < world.price ? 'disabled' : ''} 
                            onclick="${world.unlocked ? `selectWorld('${world.id}')` : `buyWorld('${world.id}')`}">
                        ${world.unlocked ? (world.id === currentWorldId ? '🌟 Atual' : '🚀 Selecionar') : 
                          (coins >= world.price ? '💳 Comprar' : '🔒 Bloqueado')}
                    </button>
                `;
                
                card.insertBefore(preview, card.firstChild);
                grid.appendChild(card);
            });
        }
        
        function buyWorld(worldId) {
            const world = worlds[worldId];
            if (coins >= world.price && !world.unlocked) {
                coins -= world.price;
                world.unlocked = true;
                saveGameData();
                updateCoinsDisplay();
                renderWorldsGrid();
                
                // Show success message
                alert(`🎉 Mundo ${world.name} desbloqueado com sucesso!`);
            }
        }
        
        function selectWorld(worldId) {
            if (worlds[worldId].unlocked) {
                showLoadingScreen(`Viajando para ${worlds[worldId].name}...`);
                
                setTimeout(() => {
                    currentWorldId = worldId;
                    saveGameData();
                    
                    // Reset stars for new world
                    stars = [];
                    for (let i = 0; i < 120; i++) {
                        stars.push(new Star());
                    }
                    
                    hideLoadingScreen();
                    closeWorldsMenu();
                    
                    if (gameState === 'playing') {
                        // Reset some game elements for new world
                        enemies = [];
                        enemyBullets = [];
                        particles = [];
                    }
                }, 1500);
            }
        }
        
        function showLoadingScreen(message) {
            document.getElementById('loadingMessage').textContent = message;
            document.getElementById('loadingScreen').style.display = 'flex';
        }
        
        function hideLoadingScreen() {
            document.getElementById('loadingScreen').style.display = 'none';
        }
        
        function showInstructions() {
            alert(`🎮 CONTROLES DO WAVESLAYERS:

🚀 MOVIMENTO:
• WASD ou Setas: Mover nave
• Espaço: Atirar
• P: Pausar/Despausar

💰 SISTEMA DE MOEDAS:
• Destrua inimigos para ganhar moedas
• Use moedas para desbloquear novos mundos
• Cada mundo tem desafios únicos

⚡ POWER-UPS:
• Verde: Melhora armas
• Rosa: Restaura vida

🌍 MUNDOS:
• Cada mundo tem inimigos únicos
• Dificuldade aumenta por mundo
• Explore galáxias distantes!

Boa sorte, comandante! 🚀✨`);
        }
        
        // Initialize game
        function init() {
            player = new Player();
            
            // Create stars
            for (let i = 0; i < 120; i++) {
                stars.push(new Star());
            }
            
            // Initialize menu animation
            initMenuAnimation();
            
            // Event listeners
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if ((e.key === 'p' || e.key === 'P') && gameState === 'playing') {
                    isPaused = !isPaused;
                }
                e.preventDefault();
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });
            
            updateCoinsDisplay();
        }
        
        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            drawBackground();
            
            // Update and draw stars
            stars.forEach(star => {
                star.update();
                star.draw();
            });
            
            if (gameState === 'playing' && gameRunning && !isPaused) {
                // Update player
                player.update(deltaTime);
                
                // Spawn enemies
                enemySpawnTimer += deltaTime;
                const world = worlds[currentWorldId];
                const spawnRate = Math.max(300, 1500 - level * 80) / world.difficulty;
                if (enemySpawnTimer > spawnRate) {
                    spawnEnemy();
                    enemySpawnTimer = 0;
                }
                
                // Update bullets
                bullets = bullets.filter(bullet => {
                    bullet.update();
                    bullet.draw();
                    return !bullet.isOffScreen();
                });
                
                enemyBullets = enemyBullets.filter(bullet => {
                    bullet.update();
                    bullet.draw();
                    return !bullet.isOffScreen();
                });
                
                // Update enemies
                enemies = enemies.filter(enemy => {
                    enemy.update(deltaTime);
                    enemy.draw();
                    return !enemy.isOffScreen();
                });
                
                // Update particles
                particles = particles.filter(particle => {
                    particle.update(deltaTime);
                    particle.draw();
                    return !particle.isDead();
                });
                
                // Update powerups
                powerups = powerups.filter(powerup => {
                    powerup.update();
                    powerup.draw();
                    return !powerup.isOffScreen();
                });
                
                // Check collisions
                checkCollisions();
                
                // Draw player
                player.draw();
                
                // Update level
                const newLevel = Math.floor(score / 750) + 1;
                if (newLevel > level) {
                    level = newLevel;
                }
                
                // Update UI
                updateUI();
            } else if (gameState === 'playing' && isPaused) {
                // Draw game elements but don't update
                bullets.forEach(bullet => bullet.draw());
                enemyBullets.forEach(bullet => bullet.draw());
                enemies.forEach(enemy => enemy.draw());
                particles.forEach(particle => particle.draw());
                powerups.forEach(powerup => powerup.draw());
                player.draw();
                
                // Draw pause overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#00ffff';
                ctx.font = '48px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSADO', canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Orbitron';
                ctx.fillText('Pressione P para continuar', canvas.width / 2, canvas.height / 2 + 50);
                ctx.textAlign = 'start';
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Start game
        init();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>